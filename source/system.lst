     1                                  ; ------------------------------------------------------------------
     2                                  ; MichalOS Kernel
     3                                  ; ------------------------------------------------------------------
     4                                  
     5                                  	BITS 16
     6                                  	
     7                                  	ORG 32768
     8                                  	
     9                                  ; ------------------------------------------------------------------
    10                                  ; MACROS
    11                                  ; ------------------------------------------------------------------
    12                                  	
    13                                  %macro clr 1
    14                                  	xor %1, %1
    15                                  %endmacro
    16                                  
    17                                  %macro mov16 3
    18                                  	mov %1, (%2 + %3 * 256)
    19                                  %endmacro
    20                                  
    21                                  %define ADLIB_BUFFER 0500h
    22                                  %define DESKTOP_BACKGROUND 0600h
    23                                  %define SYSTEM_FONT 1600h
    24                                  %define FILE_MANAGER 2600h
    25                                  %define disk_buffer 0E000h
    26                                  
    27                                  ; ------------------------------------------------------------------
    28                                  ; MichalOS memory map:
    29                                  ; Segment 0000h:
    30                                  ;   - 0000h - 03FFh = Interrupt vector table
    31                                  ;   - 0400h - 04FFh = BIOS data area
    32                                  ;   - 0500h - 05FFh = AdLib register buffer
    33                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    34                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    35                                  ;   - 2600h - 35FFh = File manager (FILEMAN.APP)
    36                                  ; Segment 0360h:
    37                                  ;   - 0000h - 00FFh = System variables
    38                                  ;      - 0000h = RET instruction
    39                                  ;      - 0001h - 0050h = Footer buffer
    40                                  ;      - 0051h - 0081h = File selector filter buffer
    41                                  ;      - 0082h = System state (byte)
    42                                  ;         - 0 if a GUI application is running
    43                                  ;         - 1 if a non-GUI application is running (no header/footer)
    44                                  ;      - 0083h = Sound state (byte)
    45                                  ;         - 0 if sound disabled
    46                                  ;         - 1 if sound enabled
    47                                  ;      - 0084h = Default boot device (byte)
    48                                  ;      - 0085h = Default button for os_dialog_box (0 = OK, 1 = Cancel) (byte)
    49                                  ;      - 0086h = int_filename_convert error status (byte)
    50                                  ;         - 0 if filename too long
    51                                  ;         - 1 if filename empty
    52                                  ;         - 2 if no extension found
    53                                  ;         - 3 if no basename found
    54                                  ;         - 4 if extension too short
    55                                  ;      - 0087h = Flag for os_file_selector input (byte)
    56                                  ;      - 0088h = Maximum number of characters that os_input_string can input (byte)
    57                                  ;      - 0089h = Width of os_list_dialog (word)
    58                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    59                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    60                                  ;   - 0100h - 7FFEh = Application
    61                                  ;   - 7FFEh - Application return flag
    62                                  ;      - 0 = return to the desktop after an application quits
    63                                  ;      - 1 = launch another application (00F0h-00FFh) after an application quits
    64                                  ;      (example: when a user opens an app through Terminal, then terminal stores its name to 00F0h-00FFh so it starts after the requested application exits)
    65                                  ;   - 7FFFh - Application launch flag
    66                                  ;      - 0 = return to the desktop after an application quits
    67                                  ;      - 1 = launch another application (filename passed in AX) after an application quits
    68                                  ;         - Note: after launching another application this flag is set to 0
    69                                  ;   - 8000h - DEA7h = MichalOS kernel
    70                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    71                                  ;      - described in CONFIG.ASM
    72                                  ;   - E000h - FFFFh = Disk buffer
    73                                  ; End of memory: 2048 bytes stack
    74                                  ; ------------------------------------------------------------------
    75                                  
    76                                  ; ------------------------------------------------------------------
    77                                  ; OS CALL VECTORS
    78                                  
    79                                  os_call_vectors:
    80 00000000 E95601                  	jmp os_main					; 8000h -- Called from bootloader
    81 00000003 E9B018                  	jmp os_print_string			; 8003h
    82 00000006 E91E19                  	jmp os_move_cursor			; 8006h
    83 00000009 E90519                  	jmp os_clear_screen			; 8009h
    84 0000000C E93419                  	jmp os_print_horiz_line		; 800Ch
    85 0000000F E90220                  	jmp os_print_newline		; 800Fh
    86 00000012 E92213                  	jmp os_wait_for_key			; 8012h
    87 00000015 E9C213                  	jmp os_check_for_key		; 8015h
    88 00000018 E9122C                  	jmp os_int_to_string		; 8018h
    89 0000001B E9F526                  	jmp os_speaker_tone			; 801Bh
    90 0000001E E93227                  	jmp os_speaker_off			; 801Eh
    91 00000021 E9260C                  	jmp os_load_file			; 8021h
    92 00000024 E96215                  	jmp os_pause				; 8024h
    93 00000027 E93316                  	jmp os_fatal_error			; 8027h
    94 0000002A E91A1F                  	jmp os_draw_background		; 802Ah
    95 0000002D E96C2A                  	jmp os_string_length		; 802Dh
    96 00000030 E9C22A                  	jmp os_string_uppercase		; 8030h
    97 00000033 E9DC2A                  	jmp os_string_lowercase		; 8033h
    98 00000036 E94A22                  	jmp os_input_string			; 8036h
    99 00000039 E9F32A                  	jmp os_string_copy			; 8039h
   100 0000003C E9CF20                  	jmp os_dialog_box			; 803Ch
   101 0000003F E9F62A                  	jmp os_string_join			; 803Fh
   102 00000042 E9D80A                  	jmp os_get_file_list		; 8042h
   103 00000045 E9462B                  	jmp os_string_compare		; 8045h
   104 00000048 E9032B                  	jmp os_string_chomp			; 8048h
   105 0000004B E9982B                  	jmp os_string_to_hex		; 804Bh
   106 0000004E E9CC27                  	jmp os_adlib_regwrite		; 804Eh
   107 00000051 E96C14                  	jmp os_bcd_to_int			; 8051h
   108 00000054 E93E2C                  	jmp os_get_time_string		; 8054h
   109 00000057 E98724                  	jmp os_draw_logo			; 8057h
   110 0000005A E92C19                  	jmp os_file_selector		; 805Ah
   111 0000005D E97C2C                  	jmp os_get_date_string		; 805Dh
   112 00000060 E91C18                  	jmp os_send_via_serial		; 8060h
   113 00000063 E92B18                  	jmp os_get_via_serial		; 8063h
   114 00000066 E96C2A                  	jmp os_find_char_in_string	; 8066h
   115 00000069 E9C418                  	jmp os_get_cursor_pos		; 8069h
   116 0000006C E9D621                  	jmp os_print_space			; 806Ch
   117 0000006F E9FE24                  	jmp os_option_menu			; 806Fh
   118 00000072 E9D821                  	jmp os_print_digit			; 8072h
   119 00000075 E9E721                  	jmp os_print_1hex			; 8075h
   120 00000078 E9ED21                  	jmp os_print_2hex			; 8078h
   121 0000007B E9F821                  	jmp os_print_4hex			; 807Bh
   122 0000007E E93748                  	jmp os_set_timer_speed		; 807Eh
   123 00000081 E9220A                  	jmp os_report_free_space	; 8081h
   124 00000084 E9062A                  	jmp os_string_add			; 8084h
   125 00000087 E9BB26                  	jmp os_speaker_note_length	; 8087h
   126 0000008A E9CF18                  	jmp os_show_cursor			; 808Ah
   127 0000008D E9D718                  	jmp os_hide_cursor			; 808Dh
   128 00000090 E98E1F                  	jmp os_dump_registers		; 8090h
   129 00000093 E9A21B                  	jmp os_list_dialog_tooltip	; 8093h
   130 00000096 E9130D                  	jmp os_write_file			; 8096h
   131 00000099 E9F20E                  	jmp os_file_exists			; 8099h
   132 0000009C E9100F                  	jmp os_create_file			; 809Ch
   133 0000009F E9EB0F                  	jmp os_remove_file			; 809Fh
   134 000000A2 E96A10                  	jmp os_rename_file			; 80A2h
   135 000000A5 E99C10                  	jmp os_get_file_size		; 80A5h
   136 000000A8 E9CD1F                  	jmp os_input_dialog			; 80A8h
   137 000000AB E9C71B                  	jmp os_list_dialog			; 80ABh
   138 000000AE E9042A                  	jmp os_string_reverse		; 80AEh
   139 000000B1 E92E2B                  	jmp os_string_to_int		; 80B1h
   140 000000B4 E9BA18                  	jmp os_draw_block			; 80B4h
   141 000000B7 E9E113                  	jmp os_get_random			; 80B7h
   142 000000BA E9F02C                  	jmp os_print_32int			; 80BAh
   143 000000BD E9AB17                  	jmp os_serial_port_enable	; 80BDh
   144 000000C0 E9982B                  	jmp os_sint_to_string		; 80C0h
   145 000000C3 E9DF2A                  	jmp os_string_parse			; 80C3h
   146 000000C6 E9F12C                  	jmp os_run_basic			; 80C6h
   147 000000C9 E90C29                  	jmp os_adlib_calcfreq		; 80C9h
   148 000000CC E9C247                  	jmp os_attach_app_timer		; 80CCh
   149 000000CF E94E2C                  	jmp os_string_tokenize		; 80CFh
   150 000000D2 E9F414                  	jmp os_clear_registers		; 80D2h
   151 000000D5 E90818                  	jmp os_format_string		; 80D5h
   152 000000D8 E9C717                  	jmp os_putchar				; 80D8h
   153 000000DB E97E26                  	jmp os_start_adlib			; 80DBh
   154 000000DE E9BF47                  	jmp os_return_app_timer		; 80DEh
   155 000000E1 E9D923                  	jmp os_reset_font			; 80E1h
   156 000000E4 E9DC17                  	jmp os_print_string_box		; 80E4h
   157 000000E7 E9BF17                  	jmp os_put_chars			; 80E7h
   158 000000EA E90E27                  	jmp os_check_adlib			; 80EAh
   159 000000ED E9D348                  	jmp os_draw_line			; 80EDh
   160 000000F0 E9E24A                  	jmp os_draw_polygon			; 80F0h
   161 000000F3 E9624B                  	jmp os_draw_circle			; 80F3h
   162 000000F6 E94B4B                  	jmp os_clear_graphics		; 80F6h
   163 000000F9 E97610                  	jmp os_get_file_datetime	; 80F9h
   164 000000FC E96929                  	jmp os_string_encrypt		; 80FCh
   165 000000FF E99E48                  	jmp os_put_pixel			; 80FFh
   166 00000102 E9A248                  	jmp os_get_pixel			; 8102h
   167 00000105 E9F323                  	jmp os_draw_icon			; 8105h
   168 00000108 E9A026                  	jmp os_stop_adlib			; 8108h
   169 0000010B E93629                  	jmp os_adlib_noteoff		; 810Bh
   170 0000010E E96916                  	jmp os_int_1Ah				; 810Eh
   171 00000111 E9C713                  	jmp os_int_to_bcd			; 8111h
   172 00000114 E9C514                  	jmp os_illegal_call			; 8114h ; FREE!!!!!!!!!!!!!!!!!!!
   173 00000117 E9A81F                  	jmp os_password_dialog		; 8117h
   174 0000011A E9BD27                  	jmp os_adlib_mute			; 811Ah
   175 0000011D E9214A                  	jmp os_draw_rectangle		; 811Dh
   176 00000120 E93816                  	jmp os_get_memory			; 8120h
   177 00000123 E93A22                  	jmp os_color_selector		; 8123h
   178 00000126 E92247                  	jmp os_modify_int_handler	; 8126h
   179 00000129 E90D2C                  	jmp os_32int_to_string		; 8129h
   180 0000012C E92923                  	jmp os_print_footer			; 812Ch
   181 0000012F E9D422                  	jmp os_print_8hex			; 812Fh
   182 00000132 E93E2C                  	jmp os_string_to_32int		; 8132h
   183 00000135 E9BD13                  	jmp os_math_power			; 8135h
   184 00000138 E9FF13                  	jmp os_math_root			; 8138h
   185 0000013B E9AF21                  	jmp os_input_password		; 813Bh
   186 0000013E E92447                  	jmp os_get_int_handler		; 813Eh
   187 00000141 E99814                  	jmp os_illegal_call			; 8141h ; FREE!!!!!!!!!!!!!!!!!!!
   188 00000144 E9D222                  	jmp os_temp_box				; 8144h
   189 00000147 E9B427                  	jmp os_adlib_unmute			; 8147h
   190 0000014A E9A809                  	jmp os_read_root			; 814Ah
   191 0000014D E98C14                  	jmp os_illegal_call			; 814Dh ; FREE!!!!!!!!!!!!!!!!!!!
   192 00000150 E98914                  	jmp os_illegal_call			; 8150h ; FREE!!!!!!!!!!!!!!!!!!!
   193 00000153 E98614                  	jmp os_illegal_call			; 8153h ; FREE!!!!!!!!!!!!!!!!!!!
   194 00000156 E9AE11                  	jmp disk_convert_l2hts		; 8156h
   195                                  	
   196                                  ; ------------------------------------------------------------------
   197                                  ; START OF MAIN KERNEL CODE
   198                                  
   199                                  os_main:
   200 00000159 CD12                    	int 12h						; Get RAM size
   201 0000015B 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   202 0000015C C1E006                  	shl ax, 6					; Convert kB to segments
   203                                  
   204 0000015F FA                      	cli
   205                                  
   206 00000160 2D0010                  	sub ax, 65536 / 16			; Set the stack to the top of the memory
   207 00000163 8ED0                    	mov ss, ax
   208 00000165 BCFEFF                  	mov sp, 0FFFEh
   209                                  
   210                                  ;	xor ax, ax
   211                                  ;	mov ss, ax					; Set stack segment and pointer
   212                                  ;	mov sp, 0FFFEh
   213                                  
   214 00000168 FB                      	sti
   215                                  
   216 00000169 FC                      	cld							; The default direction for string operations
   217                                  								; will be 'up' - incrementing address in RAM
   218                                  
   219 0000016A 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   220 0000016C 8ED8                    	mov ds, ax			
   221 0000016E 8EC0                    	mov es, ax
   222 00000170 8E26[9405]              	mov fs, [driversgmt]
   223 00000174 050010                  	add ax, 1000h
   224 00000177 8EE8                    	mov gs, ax
   225                                  	
   226 00000179 C6060000C3              	mov byte [0000h], 0xC3
   227 0000017E 88168400                	mov [0084h], dl
   228 00000182 8816[3613]              	mov [bootdev], dl			; Save boot device number
   229 00000186 C6068800FF              	mov byte [0088h], 255
   230 0000018B C70689004C00            	mov word [0089h], 76
   231 00000191 C606E00000              	mov byte [00E0h], 0
   232                                  
   233 00000196 891E[3213]              	mov [Sides], bx
   234 0000019A 890E[3413]              	mov [SecsPerTrack], cx
   235                                  
   236                                  	clr ax
    14 0000019E 31C0                <1>  xor %1, %1
   237 000001A0 E8C816                  	call os_serial_port_enable
   238                                  
   239                                  	; Load the files
   240                                  	
   241 000001A3 06                      	push es
   242 000001A4 8E06[9405]              	mov es, [driversgmt]
   243                                  	
   244 000001A8 B8[2707]                	mov ax, fileman_name
   245 000001AB B90026                  	mov cx, FILE_MANAGER
   246 000001AE E8990A                  	call os_load_file
   247                                  	
   248 000001B1 B8[5407]                	mov ax, bg_name
   249 000001B4 B90006                  	mov cx, DESKTOP_BACKGROUND
   250 000001B7 E8900A                  	call os_load_file
   251 000001BA 7305                    	jnc .background_ok
   252                                  	
   253 000001BC C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   254                                  	
   255                                  .background_ok:	
   256 000001C1 B8[4B07]                	mov ax, font_name
   257 000001C4 B90016                  	mov cx, SYSTEM_FONT
   258 000001C7 E8800A                  	call os_load_file
   259                                  	
   260 000001CA 07                      	pop es
   261                                  	
   262 000001CB FA                      	cli
   263                                  
   264 000001CC 8CCF                    	mov di, cs
   265                                  
   266 000001CE B100                    	mov cl, 00h					; Divide by 0 error handler
   267 000001D0 BE[CB48]                	mov si, os_compat_int00
   268 000001D3 E87546                  	call os_modify_int_handler
   269                                  
   270 000001D6 B10C                    	mov cl, 0Ch					; Stack overflow
   271 000001D8 BE[0849]                	mov si, os_compat_int0C
   272 000001DB E86D46                  	call os_modify_int_handler
   273                                  
   274 000001DE B105                    	mov cl, 05h					; Debugger
   275 000001E0 BE[ED48]                	mov si, os_compat_int05
   276 000001E3 E86546                  	call os_modify_int_handler
   277                                  	
   278 000001E6 B106                    	mov cl, 06h					; Bad instruction error handler
   279 000001E8 BE[2249]                	mov si, os_compat_int06
   280 000001EB E85D46                  	call os_modify_int_handler
   281                                  
   282 000001EE B107                    	mov cl, 07h					; Processor extension error handler
   283 000001F0 BE[3C49]                	mov si, os_compat_int07
   284 000001F3 E85546                  	call os_modify_int_handler
   285                                  
   286 000001F6 B11C                    	mov cl, 1Ch					; RTC handler
   287 000001F8 BE[6149]                	mov si, os_compat_int1C
   288 000001FB E84D46                  	call os_modify_int_handler
   289                                  	
   290 000001FE FB                      	sti
   291                                  
   292                                  ;	int 5
   293                                  	
   294 000001FF E87912                  	call os_seed_random
   295                                  
   296 00000202 BF0001                  	mov di, 100h
   297 00000205 B000                    	mov al, 0
   298 00000207 B9FF7E                  	mov cx, 7EFFh
   299 0000020A F3AA                    	rep stosb
   300                                  
   301 0000020C E8AE22                  	call os_reset_font
   302                                  
   303 0000020F B80310                  	mov ax, 1003h				; Set text output with certain attributes
   304 00000212 B300                    	mov bl, 0					; to be bright, and not blinking
   305 00000214 CD10                    	int 10h
   306                                  	
   307 00000216 B80503                  	mov ax, 0305h
   308 00000219 BB0401                  	mov bx, 0104h
   309 0000021C CD16                    	int 16h
   310                                  	
   311 0000021E C606820000              	mov byte [0082h], 0
   312                                  	
   313 00000223 B8[4007]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   314 00000226 B9A8DE                  	mov cx, 57000
   315 00000229 E81E0A                  	call os_load_file
   316                                  
   317 0000022C A0EDDE                  	mov al, [57069]				; Copy the default sound volume (on/off)
   318 0000022F A28300                  	mov [0083h], al
   319                                  	
   320 00000232 0F828B02                	jc load_demotour			; If failed, it doesn't exist, so the system is run for the first time
   321                                  	
   322                                  logoinput:
   323 00000236 B8[2B4D]                	mov ax, osname				; Set up the welcome screen
   324 00000239 BB[6F07]                	mov bx, empty_string
   325 0000023C B90700                  	mov cx, 07h					; Colour: black
   326 0000023F E8051D                  	call os_draw_background
   327                                  
   328 00000242 BA0009                  	mov dx, 9 * 256
   329 00000245 E8DF16                  	call os_move_cursor
   330                                  
   331 00000248 B82009                  	mov ax, 0920h
   332 0000024B BB0400                  	mov bx, 00000100b
   333 0000024E B93002                  	mov cx, 560
   334 00000251 CD10                    	int 10h
   335                                  	
   336 00000253 BE[260A]                	mov si, logo
   337 00000256 E8A222                  	call os_draw_icon
   338                                  
   339 00000259 BA0216                  	mov dx, 22 * 256 + 2
   340 0000025C E8C816                  	call os_move_cursor
   341                                  
   342 0000025F BE[D202]                	mov si, passwordmsg
   343 00000262 E85116                  	call os_print_string
   344 00000265 E8FF16                  	call os_hide_cursor
   345                                  
   346 00000268 B80B02                  	mov ax, 523
   347 0000026B B90200                  	mov cx, 2
   348 0000026E E8D424                  	call os_speaker_note_length
   349                                  
   350 00000271 E8C310                  	call os_wait_for_key
   351                                  	
   352                                  enterpressed:
   353 00000274 E8E516                  	call os_show_cursor
   354 00000277 803EAADE00              	cmp byte [57002], 0				; Is the password disabled?
   355 0000027C 743D                    	je checkformenu				; If it is, continue
   356                                  
   357                                  .try:	
   358 0000027E BA0016                  	mov dx, 22 * 256					; Clean the text on the screen
   359 00000281 E8A316                  	call os_move_cursor
   360                                  
   361 00000284 B82009                  	mov ax, 0920h
   362 00000287 BB0700                  	mov bx, 7
   363 0000028A B95000                  	mov cx, 80
   364 0000028D CD10                    	int 10h
   365                                  	
   366 0000028F BA0216                  	mov dx, 22 * 256 + 2					; Ask for the password
   367 00000292 E89216                  	call os_move_cursor
   368 00000295 BE[ED02]                	mov si, passentermsg
   369 00000298 E81B16                  	call os_print_string
   370                                  	
   371 0000029B B80001                  	mov ax, 100h
   372 0000029E B307                    	mov bl, 7
   373 000002A0 C606880020              	mov byte [0088h], 32
   374 000002A5 E84520                  	call os_input_password
   375 000002A8 C6068800FF              	mov byte [0088h], 255
   376                                  
   377 000002AD BE0001                  	mov si, 100h
   378 000002B0 E8B527                  	call os_string_encrypt
   379                                  
   380 000002B3 BFABDE                  	mov di, 57003
   381 000002B6 E8D528                  	call os_string_compare
   382 000002B9 73C3                    	jnc .try
   383                                  	
   384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end LOGO!
   385                                  	
   386                                  checkformenu:
   387 000002BB E8A916                  	call os_hide_cursor
   388 000002BE E8B102                  	call background
   389                                  
   390                                  checkformenuloop:	
   391 000002C1 E87310                  	call os_wait_for_key
   392 000002C4 3C20                    	cmp al, 32					; Space pressed?
   393 000002C6 0F847F00                	je near option_screen		; Open the menu
   394 000002CA 3C61                    	cmp al, 'a'					; a pressed?
   395 000002CC 0F84DE01                	je near load_fileman		; Open the file manager
   396 000002D0 EBEF                    	jmp checkformenuloop
   397                                  	
   398 000002D2 507265737320616E79-     	passwordmsg			db 'Press any key to log in...', 0
   398 000002DB 206B657920746F206C-
   398 000002E4 6F6720696E2E2E2E00 
   399 000002ED 456E74657220796F75-     	passentermsg		db 'Enter your password: ', 0
   399 000002F6 722070617373776F72-
   399 000002FF 643A2000           
   400                                  
   401 00000303 4D696368616C4F5320-     	os_init_msg			db 'MichalOS Desktop', 0
   401 0000030C 4465736B746F7000   
   402 00000314 5B53706163655D204F-     	os_version_msg		db '[Space] Open the main menu [A] Open the file manager', 0
   402 0000031D 70656E20746865206D-
   402 00000326 61696E206D656E7520-
   402 0000032F 5B415D204F70656E20-
   402 00000338 7468652066696C6520-
   402 00000341 6D616E6167657200   
   403                                  
   404                                  ; TODO: THE FOLLOWING CODE NEEDS TO BE REWRITTEN
   405                                  	
   406                                  option_screen:
   407 00000349 E83502                  	call menu_background
   408                                  
   409 0000034C B8[7007]                	mov ax, menuoptions
   410 0000034F BB0D00                  	mov bx, 13
   411 00000352 E81B22                  	call os_option_menu
   412                                  
   413 00000355 0F8262FF                	jc checkformenu
   414                                  	
   415 00000359 83F801                  	cmp ax, 1
   416 0000035C 0F841500                	je near app_selector
   417                                  
   418 00000360 83F802                  	cmp ax, 2
   419 00000363 0F848000                	je near game_selector
   420                                  	
   421 00000367 83F803                  	cmp ax, 3
   422 0000036A 0F84C8FE                	je near logoinput
   423                                  	
   424 0000036E 83F804                  	cmp ax, 4
   425 00000371 0F84C349                	je near os_shutdown
   426                                  
   427                                  app_selector:
   428 00000375 E80902                  	call menu_background
   429                                  
   430 00000378 B8[C808]                	mov ax, progoptions
   431 0000037B BB1400                  	mov bx, 20
   432 0000037E E8EF21                  	call os_option_menu
   433                                  
   434 00000381 72C6                    	jc option_screen
   435                                  
   436 00000383 83F801                  	cmp ax, 1
   437 00000386 0F842401                	je near load_fileman
   438                                  
   439 0000038A 83F80D                  	cmp ax, 13
   440 0000038D 0F842500                	je near debug_stuff
   441                                  	
   442 00000391 89C6                    	mov si, ax
   443 00000393 83EE02                  	sub si, 2
   444 00000396 D1E6                    	shl si, 1
   445 00000398 81C6[CD05]              	add si, appindex1
   446 0000039C AD                      	lodsw
   447 0000039D 89C6                    	mov si, ax
   448 0000039F BF0001                  	mov di, 0100h
   449 000003A2 E88A27                  	call os_string_copy
   450                                  	
   451 000003A5 B80001                  	mov ax, 0100h
   452 000003A8 BB[1E07]                	mov bx, app_prefix
   453 000003AB B9F000                  	mov cx, 00F0h
   454 000003AE E88727                  	call os_string_join
   455                                  	
   456 000003B1 89CB                    	mov bx, cx
   457 000003B3 E93201                  	jmp start_program
   458                                  	
   459                                  debug_stuff:
   460 000003B6 E8C801                  	call menu_background
   461                                  
   462 000003B9 B8[F607]                	mov ax, debugoptions
   463 000003BC BB1F00                  	mov bx, 31
   464 000003BF E8AE21                  	call os_option_menu
   465                                  	
   466 000003C2 72B1                    	jc app_selector
   467                                  	
   468 000003C4 89C6                    	mov si, ax
   469 000003C6 4E                      	dec si
   470 000003C7 D1E6                    	shl si, 1
   471 000003C9 81C6[E305]              	add si, debugindex1
   472 000003CD AD                      	lodsw
   473 000003CE 89C6                    	mov si, ax
   474 000003D0 BF0001                  	mov di, 0100h
   475 000003D3 E85927                  	call os_string_copy
   476                                  	
   477 000003D6 B80001                  	mov ax, 0100h
   478 000003D9 BB[1E07]                	mov bx, app_prefix
   479 000003DC B9F000                  	mov cx, 00F0h
   480 000003DF E85627                  	call os_string_join
   481                                  	
   482 000003E2 89CB                    	mov bx, cx
   483 000003E4 E90101                  	jmp start_program
   484                                  	
   485                                  	
   486                                  game_selector:
   487 000003E7 E89701                  	call menu_background
   488                                  
   489 000003EA B8[9107]                	mov ax, gameoptions
   490 000003ED BB1300                  	mov bx, 19
   491 000003F0 E87D21                  	call os_option_menu
   492                                  
   493 000003F3 0F8252FF                	jc option_screen
   494                                  
   495 000003F7 89C6                    	mov si, ax
   496 000003F9 4E                      	dec si
   497 000003FA D1E6                    	shl si, 1
   498 000003FC 81C6[FB05]              	add si, gameindex1
   499 00000400 AD                      	lodsw
   500                                  	
   501                                  launch_program:
   502 00000401 C606FF7F00              	mov byte [32767], 0
   503                                  
   504 00000406 E86901                  	call background
   505                                  	
   506 00000409 60                      	pusha
   507 0000040A 89C6                    	mov si, ax
   508 0000040C 89F3                    	mov bx, si
   509 0000040E 89F0                    	mov ax, si
   510 00000410 E88926                  	call os_string_length
   511 00000413 89DE                    	mov si, bx
   512 00000415 01C6                    	add si, ax				; SI now points to end of filename...
   513 00000417 4E                      	dec si
   514 00000418 4E                      	dec si
   515 00000419 4E                      	dec si					; ...and now to start of extension!
   516 0000041A BF[1F07]                	mov di, app_ext
   517 0000041D B90300                  	mov cx, 3
   518 00000420 F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   519 00000422 7521                    	jne launch_basic		; If not, try 'BAS'
   520 00000424 61                      	popa
   521                                  	
   522 00000425 B90001                  	mov cx, 100h			; Where to load the program file
   523 00000428 E81F08                  	call os_load_file		; Load filename pointed to by AX
   524                                  
   525 0000042B 0F828CFE                	jc checkformenu
   526                                  	
   527 0000042F 60                      	pusha
   528 00000430 B9FD7E                  	mov cx, 7EFDh
   529 00000433 29D9                    	sub cx, bx
   530 00000435 BF0001                  	mov di, 100h
   531 00000438 01DF                    	add di, bx
   532 0000043A B000                    	mov al, 0
   533 0000043C F3AA                    	rep stosb
   534 0000043E 61                      	popa
   535                                  	
   536 0000043F E81A15                  	call os_show_cursor
   537                                  	
   538 00000442 E9CB00                  	jmp execute_bin_program
   539                                  
   540                                  launch_basic:
   541 00000445 61                      	popa
   542                                  	
   543 00000446 60                      	pusha
   544 00000447 89C6                    	mov si, ax
   545 00000449 89F3                    	mov bx, si
   546 0000044B 89F0                    	mov ax, si
   547 0000044D E84C26                  	call os_string_length
   548 00000450 89DE                    	mov si, bx
   549 00000452 01C6                    	add si, ax				; SI now points to end of filename...
   550 00000454 4E                      	dec si
   551 00000455 4E                      	dec si
   552 00000456 4E                      	dec si					; ...and now to start of extension!
   553 00000457 BF[2307]                	mov di, bas_ext
   554 0000045A B90300                  	mov cx, 3
   555 0000045D F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   556 0000045F 753A                    	jne program_error		; If not, error out
   557 00000461 61                      	popa
   558                                  
   559 00000462 B90001                  	mov cx, 100h			; Where to load the program file
   560 00000465 E8E207                  	call os_load_file		; Load filename pointed to by AX
   561                                  
   562 00000468 0F824FFE                	jc checkformenu
   563                                  	
   564 0000046C 60                      	pusha
   565 0000046D B9FD7E                  	mov cx, 7EFDh
   566 00000470 29D9                    	sub cx, bx
   567 00000472 BF0001                  	mov di, 100h
   568 00000475 01DF                    	add di, bx
   569 00000477 B000                    	mov al, 0
   570 00000479 F3AA                    	rep stosb
   571 0000047B 61                      	popa
   572                                  
   573 0000047C E8DD14                  	call os_show_cursor
   574                                  	
   575 0000047F B80001                  	mov ax, 100h
   576                                  	clr si
    14 00000482 31F6                <1>  xor %1, %1
   577 00000484 E83329                  	call os_run_basic
   578                                  
   579 00000487 BE[5B07]                	mov si, basic_finished_msg
   580 0000048A E82914                  	call os_print_string
   581 0000048D E8A70E                  	call os_wait_for_key
   582                                  
   583 00000490 E87E14                  	call os_clear_screen
   584                                  	
   585 00000493 C606820000              	mov byte [0082h], 0
   586                                  	
   587 00000498 E920FE                  	jmp checkformenu
   588                                  	
   589                                  program_error:
   590 0000049B 61                      	popa
   591 0000049C E8D300                  	call background
   592 0000049F B8[9605]                	mov ax, prog_msg
   593                                  	clr bx
    14 000004A2 31DB                <1>  xor %1, %1
   594                                  	clr cx
    14 000004A4 31C9                <1>  xor %1, %1
   595                                  	clr dx
    14 000004A6 31D2                <1>  xor %1, %1
   596 000004A8 E8631C                  	call os_dialog_box
   597 000004AB E90DFE                  	jmp checkformenu
   598                                  	
   599                                  load_fileman:
   600 000004AE 1E                      	push ds
   601 000004AF 8E1E[9405]              	mov ds, [driversgmt]
   602 000004B3 BE0026                  	mov si, FILE_MANAGER
   603 000004B6 BF0001                  	mov di, 0100h
   604 000004B9 B90010                  	mov cx, 1000h
   605 000004BC F3A4                    	rep movsb
   606 000004BE 1F                      	pop ds
   607 000004BF EB4F                    	jmp execute_bin_program
   608                                  	
   609                                  load_demotour:
   610 000004C1 C606830001              	mov byte [0083h], 1
   611 000004C6 B8[3307]                	mov ax, demotour_name
   612 000004C9 B90001                  	mov cx, 100h
   613 000004CC E87B07                  	call os_load_file
   614 000004CF E8F710                  	call os_clear_registers
   615 000004D2 E8(0001)                	call 100h
   616 000004D5 E95EFD                  	jmp logoinput
   617                                  	
   618                                  load_command:
   619 000004D8 B8[2606]                	mov ax, cmd_name
   620 000004DB BB[1E07]                	mov bx, app_prefix
   621 000004DE B9F000                  	mov cx, 00F0h
   622 000004E1 E85426                  	call os_string_join
   623 000004E4 89CB                    	mov bx, cx
   624 000004E6 EB00                    	jmp start_program
   625                                  	
   626                                  start_program:				; BX = program name
   627 000004E8 60                      	pusha
   628 000004E9 B9FD7E                  	mov cx, 7EFDh
   629 000004EC BF0001                  	mov di, 100h
   630 000004EF B000                    	mov al, 0
   631 000004F1 F3AA                    	rep stosb
   632 000004F3 61                      	popa
   633                                  	
   634 000004F4 89D8                    	mov ax, bx
   635 000004F6 B90001                  	mov cx, 100h			; Where to load the program file
   636 000004F9 E84E07                  	call os_load_file		; Load filename pointed to by AX
   637                                  
   638 000004FC 0F828E00                	jc systemfilemissing
   639                                  	
   640 00000500 E85914                  	call os_show_cursor
   641                                  
   642 00000503 EB0B                    	jmp execute_bin_program
   643                                  	
   644                                  return_to_app:
   645 00000505 B8F000                  	mov ax, 00F0h
   646 00000508 B90001                  	mov cx, 100h			; Where to load the program file
   647 0000050B E83C07                  	call os_load_file		; Load filename pointed to by AX
   648                                  
   649 0000050E 727E                    	jc systemfilemissing	
   650                                  
   651                                  execute_bin_program:
   652 00000510 E8FE13                  	call os_clear_screen	; Clear the screen before running
   653                                  
   654 00000513 C606820000              	mov byte [0082h], 0
   655                                  	
   656 00000518 C606[7109]01            	mov byte [app_running], 1
   657                                  
   658 0000051D 8926[6F09]              	mov [origstack], sp
   659                                  	
   660 00000521 E8A510                  	call os_clear_registers
   661                                  	
   662 00000524 E8(0001)                	call 100h	
   663                                  	
   664                                  finish:
   665 00000527 C606[7109]00            	mov byte [app_running], 0
   666                                  	
   667 0000052C E87C22                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   668 0000052F E82122                  	call os_speaker_off
   669                                  
   670 00000532 50                      	push ax
   671 00000533 8CC8                    	mov ax, cs
   672 00000535 8ED8                    	mov ds, ax
   673 00000537 8EC0                    	mov es, ax
   674 00000539 58                      	pop ax
   675                                  	
   676 0000053A 60                      	pusha
   677 0000053B B40F                    	mov ah, 0Fh				; Get the current video mode
   678 0000053D CD10                    	int 10h
   679                                  	
   680 0000053F 3C03                    	cmp al, 3
   681 00000541 7405                    	je .skip_gfx
   682                                  	
   683 00000543 B80300                  	mov ax, 3
   684 00000546 CD10                    	int 10h
   685                                  
   686                                  .skip_gfx:
   687 00000548 B80310                  	mov ax, 1003h			; Set text output with certain attributes
   688                                  	clr bx					; to be bright, and not blinking
    14 0000054B 31DB                <1>  xor %1, %1
   689 0000054D CD10                    	int 10h
   690                                  
   691 0000054F C606820000              	mov byte [0082h], 0
   692 00000554 C606850000              	mov byte [0085h], 0
   693                                  	
   694 00000559 E8611F                  	call os_reset_font
   695 0000055C 61                      	popa
   696                                  	
   697 0000055D 803EFF7F01              	cmp byte [7FFFh], 1
   698 00000562 0F849BFE                	je near launch_program
   699                                  	
   700 00000566 803EFE7F01              	cmp byte [7FFEh], 1
   701 0000056B 0F8496FF                	je near return_to_app
   702                                  	
   703 0000056F E949FD                  	jmp checkformenu		; When finished, go back to the program list
   704                                  
   705                                  	
   706                                  ; TODO: THE CODE ABOVE NEEDS TO BE REWRITTEN
   707                                  	
   708                                  background:
   709 00000572 60                      	pusha
   710 00000573 B8[0303]                	mov ax, os_init_msg		; Draw main screen layout
   711 00000576 BB[1403]                	mov bx, os_version_msg
   712 00000579 B90001                  	mov cx, 256				; Colour: white text on light blue
   713 0000057C E8C819                  	call os_draw_background
   714 0000057F 61                      	popa
   715 00000580 C3                      	ret
   716                                  
   717                                  menu_background:
   718 00000581 60                      	pusha
   719 00000582 803EEFDE01              	cmp byte [57071], 1
   720 00000587 7403                    	je .done
   721                                  	
   722 00000589 E8E6FF                  	call background
   723                                  	
   724                                  .done:
   725 0000058C 61                      	popa
   726 0000058D C3                      	ret
   727                                  	
   728                                  systemfilemissing:
   729 0000058E B8[B705]                	mov ax, noprogerror
   730 00000591 E8C910                  	call os_fatal_error
   731                                  	
   732                                  	; And now data for the above code...
   733                                  
   734 00000594 0000                    	driversgmt				dw 0000h
   735                                  	
   736 00000596 546869732066696C65-     	prog_msg				db 'This file is not an application!', 0
   736 0000059F 206973206E6F742061-
   736 000005A8 6E206170706C696361-
   736 000005B1 74696F6E2100       
   737                                  
   738 000005B7 53797374656D206669-     	noprogerror				db 'System file not found', 0
   738 000005C0 6C65206E6F7420666F-
   738 000005C9 756E6400           
   739                                  
   740 000005CD [0F06][1406][1B06]-     	appindex1				dw edit_name, viewer_name, calc_name, clock_name, cmd_name, config_name, ascii_name, pixel_name, player_name, hwcheck_name, about_name
   740 000005D3 [2006][2606][2F06]-
   740 000005D9 [3606][3F06][4506]-
   740 000005DF [4C06][5406]       
   741 000005E3 [5A06][6306][6B06]-     	debugindex1				dw debug1_name, debug2_name, debug3_name, debug4_name, debug5_name, debug6_name, debug7_name, debug8_name, debug11_name, debug12_name, debug13_name, debug14_name
   741 000005E9 [7206][7A06][8106]-
   741 000005EF [8906][8F06][9406]-
   741 000005F5 [9A06][A006][A506] 
   742 000005FB [AC06][B306][C006]-     	gameindex1				dw cf_name, inkspill_name, spaceinv_name, asmtris_name, sudoku_name, fisher_name, miketron_name, muncher_name, hangman_name, snake_name
   742 00000601 [CD06][D906][E406]-
   742 00000607 [EF06][FC06][0807]-
   742 0000060D [1407]             
   743                                  	
   744 0000060F 4544495400              	edit_name				db 'EDIT', 0
   745 00000614 56494557455200          	viewer_name				db 'VIEWER', 0
   746 0000061B 43414C4300              	calc_name				db 'CALC', 0
   747 00000620 434C4F434B00            	clock_name				db 'CLOCK', 0
   748 00000626 5445524D494E414C00      	cmd_name				db 'TERMINAL', 0
   749 0000062F 434F4E46494700          	config_name				db 'CONFIG', 0
   750 00000636 415343494941525400      	ascii_name				db 'ASCIIART', 0
   751 0000063F 504958454C00            	pixel_name				db 'PIXEL', 0
   752 00000645 504C4159455200          	player_name				db 'PLAYER', 0
   753 0000064C 4857434845434B00        	hwcheck_name			db 'HWCHECK', 0
   754 00000654 41424F555400            	about_name				db 'ABOUT', 0
   755                                  
   756 0000065A 4449534B5445535400      	debug1_name				db 'DISKTEST', 0
   757 00000663 4B42445445535400        	debug2_name				db 'KBDTEST', 0
   758 0000066B 53455249414C00          	debug3_name				db 'SERIAL', 0
   759 00000672 5254435445535400        	debug4_name				db 'RTCTEST', 0
   760 0000067A 534543544F5200          	debug5_name				db 'SECTOR', 0
   761 00000681 4D454D4544495400        	debug6_name				db 'MEMEDIT', 0
   762 00000689 424F58455300            	debug7_name				db 'BOXES', 0
   763 0000068F 444F545300              	debug8_name				db 'DOTS', 0
   764 00000694 434845434B00            	debug11_name			db 'CHECK', 0
   765 0000069A 524454534300            	debug12_name			db 'RDTSC', 0
   766 000006A0 5445535400              	debug13_name			db 'TEST', 0
   767 000006A5 53544154494300          	debug14_name			db 'STATIC', 0
   768                                  	
   769 000006AC 43462E42415300          	cf_name					db 'CF.BAS', 0
   770 000006B3 494E4B5350494C4C2E-     	inkspill_name			db 'INKSPILL.BAS', 0
   770 000006BC 42415300           
   771 000006C0 5350414345494E562E-     	spaceinv_name			db 'SPACEINV.APP', 0
   771 000006C9 41505000           
   772 000006CD 41534D545249532E41-     	asmtris_name			db 'ASMTRIS.APP', 0
   772 000006D6 505000             
   773 000006D9 5355444F4B552E4150-     	sudoku_name				db 'SUDOKU.APP', 0
   773 000006E2 5000               
   774 000006E4 4649534845522E4150-     	fisher_name				db 'FISHER.APP', 0
   774 000006ED 5000               
   775 000006EF 4D494B4554524F4E2E-     	miketron_name			db 'MIKETRON.BAS', 0
   775 000006F8 42415300           
   776 000006FC 4D554E434845522E42-     	muncher_name			db 'MUNCHER.BAS', 0
   776 00000705 415300             
   777 00000708 48414E474D414E2E41-     	hangman_name			db 'HANGMAN.APP', 0
   777 00000711 505000             
   778 00000714 534E414B452E415050-     	snake_name				db 'SNAKE.APP', 0
   778 0000071D 00                 
   779                                  	
   780 0000071E 2E                      	app_prefix				db '.'
   781 0000071F 41505000                	app_ext					db 'APP', 0
   782 00000723 42415300                	bas_ext					db 'BAS', 0
   783                                  
   784 00000727 46494C454D414E2E41-     	fileman_name			db 'FILEMAN.APP', 0
   784 00000730 505000             
   785 00000733 44454D4F544F55522E-     	demotour_name			db 'DEMOTOUR.APP', 0
   785 0000073C 41505000           
   786 00000740 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   786 00000749 4700               
   787 0000074B 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   788 00000754 42472E53595300          	bg_name					db 'BG.SYS', 0
   789                                  	
   790 0000075B 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   790 00000764 6772616D20656E6465-
   790 0000076D 6400               
   791                                  
   792 0000076F 00                      	empty_string			db 0
   793                                  	
   794 00000770 50726F6772616D732C-     	menuoptions				db 'Programs,Games,Log out,Shut down', 0
   794 00000779 47616D65732C4C6F67-
   794 00000782 206F75742C53687574-
   794 0000078B 20646F776E00       
   795 00000791 436F736D696320466C-     	gameoptions				db 'Cosmic Flight,InkSpill,Space Inventors,aSMtris,Sudoku,Deep Sea Fisher,MikeTron,Muncher,Hangman,Snake', 0
   795 0000079A 696768742C496E6B53-
   795 000007A3 70696C6C2C53706163-
   795 000007AC 6520496E76656E746F-
   795 000007B5 72732C61534D747269-
   795 000007BE 732C5375646F6B752C-
   795 000007C7 446565702053656120-
   795 000007D0 4669736865722C4D69-
   795 000007D9 6B6554726F6E2C4D75-
   795 000007E2 6E636865722C48616E-
   795 000007EB 676D616E2C536E616B-
   795 000007F4 6500               
   796 000007F6 4469736B2064657465-     	debugoptions			db 'Disk detection test,Keyboard tester,Serial communication tester,RTC clock tester,Disk Sector inspector,Memory editor,Boxes,Dots,Disk sector checker,TSC register tester,Simple test app,TV static generator (CGA)', 0
   796 000007FF 6374696F6E20746573-
   796 00000808 742C4B6579626F6172-
   796 00000811 64207465737465722C-
   796 0000081A 53657269616C20636F-
   796 00000823 6D6D756E6963617469-
   796 0000082C 6F6E20746573746572-
   796 00000835 2C52544320636C6F63-
   796 0000083E 6B207465737465722C-
   796 00000847 4469736B2053656374-
   796 00000850 6F7220696E73706563-
   796 00000859 746F722C4D656D6F72-
   796 00000862 7920656469746F722C-
   796 0000086B 426F7865732C446F74-
   796 00000874 732C4469736B207365-
   796 0000087D 63746F722063686563-
   796 00000886 6B65722C5453432072-
   796 0000088F 656769737465722074-
   796 00000898 65737465722C53696D-
   796 000008A1 706C65207465737420-
   796 000008AA 6170702C5456207374-
   796 000008B3 617469632067656E65-
   796 000008BC 7261746F7220284347-
   796 000008C5 412900             
   797 000008C8 46696C65206D616E61-     	progoptions				db 'File manager,Text editor,Image viewer,Calculator,Clock,Terminal,Settings,ASCII art editor,Pixel art editor,Music player,Hardware checker,About MichalOS,Other stuff...', 0
   797 000008D1 6765722C5465787420-
   797 000008DA 656469746F722C496D-
   797 000008E3 616765207669657765-
   797 000008EC 722C43616C63756C61-
   797 000008F5 746F722C436C6F636B-
   797 000008FE 2C5465726D696E616C-
   797 00000907 2C53657474696E6773-
   797 00000910 2C4153434949206172-
   797 00000919 7420656469746F722C-
   797 00000922 506978656C20617274-
   797 0000092B 20656469746F722C4D-
   797 00000934 7573696320706C6179-
   797 0000093D 65722C486172647761-
   797 00000946 726520636865636B65-
   797 0000094F 722C41626F7574204D-
   797 00000958 696368616C4F532C4F-
   797 00000961 746865722073747566-
   797 0000096A 662E2E2E00         
   798                                  	
   799                                  ; ------------------------------------------------------------------
   800                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   801                                  
   802                                  	; System runtime variables
   803                                  								
   804 0000096F 0000                    	origstack		dw 0		; SP before launching a program
   805                                  
   806 00000971 00                      	app_running		db 0		; Is a program running?
   807                                  	
   808                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   809                                  	
   810                                  ; ------------------------------------------------------------------
   811                                  ; FEATURES -- Code to pull into the kernel
   812                                  
   813                                  	%INCLUDE "features/icons.asm"
   814                              <1> ; ==================================================================
   815                              <1> ; MichalOS Icons
   816                              <1> ; ==================================================================
   817                              <1> 
   818 00000972 0910                <1> 	bomblogo	db 9, 16
   819 00000974 000000000020006000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00100000b, 00000000b, 01100000b, 00000000b
   820 0000097D 000000000402018000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000100b, 00000010b, 00000001b, 10000000b, 00000000b
   821 00000986 000000000084800000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 10000100b, 10000000b, 00000000b, 00000000b
   822 0000098F 0000006AA501508880  <1> 				db 00000000b, 00000000b, 00000000b, 01101010b, 10100101b, 00000001b, 01010000b, 10001000b, 10000000b
   823 00000998 0000030000A8004000  <1> 				db 00000000b, 00000000b, 00000011b, 00000000b, 00000000b, 10101000b, 00000000b, 01000000b, 00000000b
   824 000009A1 000057540018202400  <1> 				db 00000000b, 00000000b, 01010111b, 01010100b, 00000000b, 00011000b, 00100000b, 00100100b, 00000000b
   825 000009AA 0000FFFC0080200200  <1> 				db 00000000b, 00000000b, 11111111b, 11111100b, 00000000b, 10000000b, 00100000b, 00000010b, 00000000b
   826 000009B3 005FFFFFD400200000  <1> 				db 00000000b, 01011111b, 11111111b, 11111111b, 11010100b, 00000000b, 00100000b, 00000000b, 00000000b
   827 000009BC 01FFFFFFFD00000000  <1> 				db 00000001b, 11111111b, 11111111b, 11111111b, 11111101b, 00000000b, 00000000b, 00000000b, 00000000b
   828 000009C5 07FFFFFFFF40000000  <1> 				db 00000111b, 11111111b, 11111111b, 11111111b, 11111111b, 01000000b, 00000000b, 00000000b, 00000000b
   829 000009CE 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   830 000009D7 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   831 000009E0 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   832 000009E9 03FFFFFFFF00000000  <1> 				db 00000011b, 11111111b, 11111111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   833 000009F2 00FFFFFFFC00000000  <1> 				db 00000000b, 11111111b, 11111111b, 11111111b, 11111100b, 00000000b, 00000000b, 00000000b, 00000000b
   834 000009FB 000AFFFE8000000000  <1> 				db 00000000b, 00001010b, 11111111b, 11111110b, 10000000b, 00000000b, 00000000b, 00000000b, 00000000b
   835                              <1> 
   836 00000A04 0408                <1> 	filelogo	db 4, 8
   837 00000A06 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
   838 00000A0A 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
   839 00000A0E 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
   840 00000A12 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   841 00000A16 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   842 00000A1A 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   843 00000A1E 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   844 00000A22 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
   845                              <1> 	
   846 00000A26 1207                <1> 	logo		db 18, 7
   847 00000A28 00000EEAAAAC400400- <1> 				db 00000000b, 00000000b, 00001110b, 11101010b, 10101010b, 10101100b, 01000000b, 00000100b, 00000000b, 00000000b, 01000000b, 00000000b, 	00000000b, 00010011b, 11101010b, 10111111b, 10101010b, 10110000b
   847 00000A31 0040000013EABFAAB0  <1>
   848 00000A3A 00000CEAAAECE46C00- <1> 				db 00000000b, 00000000b, 00001100b, 11101010b, 10101010b, 11101100b, 11100100b, 01101100b, 00000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
   848 00000A43 00C00000333FCCFFF0  <1>
   849 00000A4C 00000CC000CCC20C80- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000010b, 00001100b, 10000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
   849 00000A55 00C00000333FCCFFF0  <1>
   850 00000A5E 00000CC000CCC00CC6- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11000110b, 10101000b, 11011010b, 10010010b, 10101001b, 00110011b, 00111111b, 11001111b, 01010101b, 10110000b
   850 00000A67 A8DA92A9333FCF55B0  <1>
   851 00000A70 00000CC000CCC00CCC- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11001100b, 00000000b, 11000000b, 00110001b, 10101011b, 00110011b, 00111111b, 11001111b, 11111111b, 00110000b
   851 00000A79 00C031AB333FCFFF30  <1>
   852 00000A82 00000EAAAACCC00CC9- <1> 				db 00000000b, 00000000b, 00001110b, 10101010b, 10101010b, 11001100b, 11000000b, 00001100b, 11001001b, 01010100b, 11000000b, 00110010b, 01010110b, 00110011b, 01101010b, 10011110b, 10101010b, 01110000b
   852 00000A8B 54C03256336A9EAA70  <1>
   853 00000A94 00000AAAAAA8000000- <1> 				db 00000000b, 00000000b, 00001010b, 10101010b, 10101010b, 10101000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000010b, 10101010b, 10101010b, 10101010b, 10100000b
   853 00000A9D 0000000002AAAAAAA0  <1>
   854                              <1> 			
   814                                   	%INCLUDE "features/disk.asm"
   815                              <1> ; ==================================================================
   816                              <1> ; FAT12 FLOPPY DISK ROUTINES
   817                              <1> ; ==================================================================
   818                              <1> 
   819                              <1> ; os_report_free_space -- Returns the amount of free space on disk
   820                              <1> ; OUT: AX = Number of sectors free
   821                              <1> 
   822                              <1> os_report_free_space:
   823 00000AA6 60                  <1> 	pusha
   824 00000AA7 C706[F10A]0000      <1> 	mov word [.counter], 0
   825 00000AAD C706[F30A]0000      <1> 	mov word [.sectors_read], 0
   826                              <1> 	
   827 00000AB3 E8AE07              <1> 	call disk_read_fat				; Read the FAT into memory
   828 00000AB6 BE00E0              <1> 	mov si, disk_buffer
   829                              <1> 	
   830                              <1> .loop:
   831                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
   832                              <1> 
   833 00000AB9 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
   834 00000ABB 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
   835 00000ABE 8A5C02              <1> 	mov bl, [si + 2]
   836                              <1> 	
   837 00000AC1 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
   838                              <1> 	
   839 00000AC4 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
   840 00000AC7 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
   841                              <1> 		
   842 00000ACA 83F800              <1> 	cmp ax, 0
   843 00000ACD 7504                <1> 	jne .no_increment_1
   844                              <1> 	
   845 00000ACF FF06[F10A]          <1> 	inc word [.counter]
   846                              <1> 	
   847                              <1> .no_increment_1:
   848 00000AD3 83FB00              <1> 	cmp bx, 0
   849                              <1> 		
   850 00000AD6 7504                <1> 	jne .no_increment_2
   851                              <1> 	
   852 00000AD8 FF06[F10A]          <1> 	inc word [.counter]
   853                              <1> 	
   854                              <1> .no_increment_2:
   855 00000ADC 83C603              <1> 	add si, 3						; Increment the pointer
   856 00000ADF 8306[F30A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
   857                              <1> 	
   858 00000AE4 813E[F30A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
   859 00000AEA 7CCD                <1> 	jl .loop
   860                              <1> 	
   861 00000AEC 61                  <1> 	popa
   862 00000AED A1[F10A]            <1> 	mov ax, [.counter]
   863                              <1> 
   864 00000AF0 C3                  <1> 	ret
   865                              <1> 	
   866 00000AF1 0000                <1> 	.counter		dw 0
   867 00000AF3 0000                <1> 	.sectors_read	dw 0
   868                              <1> 	
   869                              <1> ; --------------------------------------------------------------------------
   870                              <1> ; os_read_root -- Get the root directory contents
   871                              <1> ; IN: SI = where to store the root directory; OUT: carry set if error
   872                              <1> 
   873                              <1> os_read_root:
   874 00000AF5 60                  <1> 	pusha
   875                              <1> 
   876 00000AF6 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   877 00000AF9 E80B08              <1> 	call disk_convert_l2hts
   878                              <1> 
   879 00000AFC 8CDB                <1> 	mov bx, ds
   880 00000AFE 8EC3                <1> 	mov es, bx
   881 00000B00 89F3                <1> 	mov bx, si
   882                              <1> 
   883 00000B02 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   884 00000B04 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
   885                              <1> 
   886 00000B06 60                  <1> 	pusha				; Prepare to enter loop
   887                              <1> 
   888                              <1> 
   889                              <1> .read_root_dir_loop:
   890 00000B07 61                  <1> 	popa
   891 00000B08 60                  <1> 	pusha
   892                              <1> 
   893 00000B09 F9                  <1> 	stc				; A few BIOSes do not set properly on error
   894 00000B0A CD13                <1> 	int 13h				; Read sectors
   895                              <1> 
   896 00000B0C 7308                <1> 	jnc .root_dir_finished
   897 00000B0E E8E707              <1> 	call disk_reset_floppy		; Reset controller and try again
   898 00000B11 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
   899                              <1> 
   900 00000B13 61                  <1> 	popa
   901 00000B14 EB04                <1> 	jmp .read_failure		; Fatal double error
   902                              <1> 
   903                              <1> 
   904                              <1> .root_dir_finished:
   905 00000B16 61                  <1> 	popa				; Restore registers from main loop
   906                              <1> 
   907 00000B17 61                  <1> 	popa				; And restore from start of this system call
   908                              <1> 
   909 00000B18 F8                  <1> 	clc				; Clear carry (for success)
   910 00000B19 C3                  <1> 	ret
   911                              <1> 
   912                              <1> .read_failure:
   913 00000B1A 61                  <1> 	popa
   914                              <1> 
   915 00000B1B F9                  <1> 	stc				; Set carry flag (for failure)
   916 00000B1C C3                  <1> 	ret
   917                              <1> 
   918                              <1> ; ------------------------------------------------------------------
   919                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   920                              <1> ; IN/OUT: AX = location to store zero-terminated filename string,
   921                              <1> ;         If [0087h] = 1, then BX = location of file extension list
   922                              <1> 
   923                              <1> os_get_file_list:
   924 00000B1D 60                  <1> 	pusha
   925                              <1> 
   926 00000B1E C606[020C]00        <1> 	mov byte [.num_entries], 0
   927 00000B23 891E[030C]          <1> 	mov [.extension_list], bx
   928                              <1> 	
   929 00000B27 BE[070C]            <1> 	mov si, .msg_load
   930 00000B2A E82B19              <1> 	call os_print_footer
   931                              <1> 	
   932 00000B2D A3[050C]            <1> 	mov word [.file_list_tmp], ax
   933                              <1> 
   934 00000B30 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   935                              <1> 
   936 00000B36 E8BF07              <1> 	call disk_reset_floppy		; Just in case disk was changed
   937                              <1> 
   938 00000B39 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   939 00000B3C E8C807              <1> 	call disk_convert_l2hts
   940                              <1> 
   941 00000B3F BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   942 00000B42 89F3                <1> 	mov bx, si
   943                              <1> 
   944 00000B44 B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
   945                              <1> 
   946 00000B47 60                  <1> 	pusha				; Prepare to enter loop
   947                              <1> 
   948                              <1> 
   949                              <1> .read_root_dir:
   950 00000B48 61                  <1> 	popa
   951 00000B49 60                  <1> 	pusha
   952                              <1> 
   953 00000B4A F9                  <1> 	stc
   954 00000B4B CD13                <1> 	int 13h				; Read sectors
   955 00000B4D E8A807              <1> 	call disk_reset_floppy		; Check we've read them OK
   956 00000B50 730B                <1> 	jnc .show_dir_init		; No errors, continue
   957                              <1> 
   958 00000B52 E8A307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   959 00000B55 73F1                <1> 	jnc .read_root_dir
   960                              <1> 
   961 00000B57 B8[260C]            <1> 	mov ax, .error
   962 00000B5A E8000B              <1> 	call os_fatal_error
   963                              <1> 	
   964                              <1> .show_dir_init:
   965 00000B5D 61                  <1> 	popa
   966                              <1> 
   967 00000B5E B80000              <1> 	mov ax, 0
   968 00000B61 BE00E0              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   969                              <1> 
   970 00000B64 8B3E[050C]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   971                              <1> 
   972                              <1> 
   973                              <1> .start_entry:
   974 00000B68 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   975 00000B6B 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   976 00000B6D 7478                <1> 	je .skip
   977                              <1> 
   978 00000B6F A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   979 00000B71 7574                <1> 	jnz .skip			; Yes, ignore it
   980                              <1> 
   981 00000B73 8A04                <1> 	mov al, [si]
   982 00000B75 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   983 00000B77 746E                <1> 	je .skip
   984                              <1> 
   985 00000B79 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   986 00000B7B 7470                <1> 	je .done
   987                              <1> 	
   988 00000B7D B90100              <1> 	mov cx, 1			; Set char counter
   989 00000B80 89F2                <1> 	mov dx, si			; Beginning of possible entry
   990                              <1> 
   991                              <1> .testdirentry:
   992 00000B82 46                  <1> 	inc si
   993 00000B83 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   994 00000B85 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   995 00000B87 7C5C                <1> 	jl .nxtdirentry
   996 00000B89 3C7E                <1> 	cmp al, '~'
   997 00000B8B 7758                <1> 	ja .nxtdirentry
   998                              <1> 
   999 00000B8D 41                  <1> 	inc cx
  1000 00000B8E 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
  1001 00000B91 7402                <1> 	je .gotfilename
  1002 00000B93 EBED                <1> 	jmp .testdirentry
  1003                              <1> 
  1004                              <1> 
  1005                              <1> .gotfilename:				; Got a filename that passes testing
  1006 00000B95 89D6                <1> 	mov si, dx			; DX = where getting string
  1007                              <1> 
  1008 00000B97 803E870001          <1> 	cmp byte [0087h], 1
  1009 00000B9C 7522                <1> 	jne .no_extension_check
  1010                              <1> 	
  1011 00000B9E 8B1E[030C]          <1> 	mov bx, [.extension_list]
  1012 00000BA2 0FB60F              <1> 	movzx cx, byte [bx]
  1013                              <1> 
  1014                              <1> .extension_loop:
  1015 00000BA5 60                  <1> 	pusha
  1016 00000BA6 83C608              <1> 	add si, 8
  1017                              <1> 	
  1018 00000BA9 49                  <1> 	dec cx
  1019 00000BAA 89CF                <1> 	mov di, cx
  1020 00000BAC C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1021 00000BAF 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1022 00000BB0 033E[030C]          <1> 	add di, [.extension_list]	
  1023                              <1> 	
  1024 00000BB4 B90300              <1> 	mov cx, 3
  1025 00000BB7 F3A6                <1> 	rep cmpsb
  1026 00000BB9 61                  <1> 	popa
  1027 00000BBA 7404                <1> 	je .no_extension_check
  1028                              <1> 	
  1029 00000BBC E2E7                <1> 	loop .extension_loop
  1030                              <1> 	
  1031 00000BBE EB25                <1> 	jmp .nxtdirentry
  1032                              <1> 	
  1033                              <1> .no_extension_check:
  1034 00000BC0 31C9                <1> 	xor cx, cx
  1035                              <1> 	
  1036                              <1> .loopy:
  1037 00000BC2 AC                  <1> 	lodsb
  1038 00000BC3 3C20                <1> 	cmp al, ' '
  1039 00000BC5 7401                <1> 	je .ignore_space
  1040 00000BC7 AA                  <1> 	stosb
  1041                              <1> 	
  1042                              <1> .ignore_space:
  1043 00000BC8 41                  <1> 	inc cx
  1044 00000BC9 83F908              <1> 	cmp cx, 8
  1045 00000BCC 7407                <1> 	je .add_dot
  1046 00000BCE 83F90B              <1> 	cmp cx, 11
  1047 00000BD1 7409                <1> 	je .done_copy
  1048 00000BD3 EBED                <1> 	jmp .loopy
  1049                              <1> 
  1050                              <1> .add_dot:
  1051 00000BD5 26C6052E            <1> 	mov byte [es:di], '.'
  1052 00000BD9 47                  <1> 	inc di
  1053 00000BDA EBE6                <1> 	jmp .loopy
  1054                              <1> 
  1055                              <1> .done_copy:
  1056 00000BDC 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
  1057 00000BE0 47                  <1> 	inc di
  1058 00000BE1 FE06[020C]          <1> 	inc byte [.num_entries]
  1059                              <1> 	
  1060                              <1> .nxtdirentry:
  1061 00000BE5 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
  1062                              <1> 
  1063                              <1> .skip:
  1064 00000BE7 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
  1065 00000BEA E97BFF              <1> 	jmp .start_entry
  1066                              <1> 
  1067                              <1> 
  1068                              <1> .done:
  1069 00000BED 803E[020C]00        <1> 	cmp byte [.num_entries], 0
  1070 00000BF2 7401                <1> 	je .no_dec
  1071                              <1> 	
  1072 00000BF4 4F                  <1> 	dec di
  1073                              <1> 
  1074                              <1> .no_dec:
  1075 00000BF5 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
  1076                              <1> 
  1077 00000BF9 60                  <1> 	pusha
  1078 00000BFA 31F6                <1> 	xor si, si
  1079 00000BFC E85918              <1> 	call os_print_footer
  1080 00000BFF 61                  <1> 	popa
  1081                              <1> 
  1082 00000C00 61                  <1> 	popa
  1083                              <1> 
  1084 00000C01 C3                  <1> 	ret
  1085                              <1> 
  1086 00000C02 00                  <1> 	.num_entries		db 0
  1087 00000C03 0000                <1> 	.extension_list		dw 0
  1088 00000C05 0000                <1> 	.file_list_tmp		dw 0
  1089 00000C07 2052656164696E6720- <1> 	.msg_load			db ' Reading directory contents...', 0
  1089 00000C10 6469726563746F7279- <1>
  1089 00000C19 20636F6E74656E7473- <1>
  1089 00000C22 2E2E2E00            <1>
  1090 00000C26 6F735F6765745F6669- <1> 	.error				db 'os_get_file_list: Floppy reset fail', 0
  1090 00000C2F 6C655F6C6973743A20- <1>
  1090 00000C38 466C6F707079207265- <1>
  1090 00000C41 736574206661696C00  <1>
  1091                              <1> 	
  1092                              <1> ; ------------------------------------------------------------------
  1093                              <1> ; os_load_file -- Load a file into RAM
  1094                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
  1095                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
  1096                              <1> 
  1097                              <1> os_load_file:
  1098 00000C4A 06                  <1> 	push es
  1099 00000C4B 8C06[A00D]          <1> 	mov [.old_segment], es
  1100                              <1> 
  1101 00000C4F 0E                  <1> 	push cs
  1102 00000C50 07                  <1> 	pop es
  1103                              <1> 	
  1104 00000C51 E8A11E              <1> 	call os_string_uppercase
  1105                              <1> 
  1106 00000C54 60                  <1> 	pusha							; Message display routine
  1107 00000C55 89C3                <1> 	mov bx, ax
  1108 00000C57 B8[A20D]            <1> 	mov ax, .msg_load
  1109 00000C5A B95200              <1> 	mov cx, 82
  1110 00000C5D E8D81E              <1> 	call os_string_join
  1111 00000C60 BE5200              <1> 	mov si, 82
  1112 00000C63 E8F217              <1> 	call os_print_footer
  1113 00000C66 61                  <1> 	popa
  1114                              <1> 	
  1115 00000C67 E83D05              <1> 	call int_filename_convert
  1116                              <1> 
  1117 00000C6A A3[780D]            <1> 	mov [.filename_loc], ax		; Store filename location
  1118 00000C6D 890E[7A0D]          <1> 	mov [.load_position], cx	; And where to load the file!
  1119                              <1> 
  1120 00000C71 6631C0              <1> 	xor eax, eax			; Needed for some older BIOSes
  1121                              <1> 
  1122 00000C74 E88106              <1> 	call disk_reset_floppy		; In case floppy has been changed
  1123 00000C77 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
  1124                              <1> 
  1125 00000C79 B8[800D]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
  1126 00000C7C E9DE09              <1> 	jmp os_fatal_error
  1127                              <1> 
  1128                              <1> 
  1129                              <1> .floppy_ok:				; Ready to read first block of data
  1130 00000C7F B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1131 00000C82 E88206              <1> 	call disk_convert_l2hts
  1132                              <1> 
  1133 00000C85 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
  1134 00000C88 89F3                <1> 	mov bx, si
  1135                              <1> 
  1136 00000C8A B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
  1137                              <1> 
  1138 00000C8D 60                  <1> 	pusha				; Prepare to enter loop
  1139                              <1> 
  1140                              <1> 
  1141                              <1> .read_root_dir:
  1142 00000C8E 61                  <1> 	popa
  1143 00000C8F 60                  <1> 	pusha
  1144                              <1> 
  1145 00000C90 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
  1146                              <1> 	
  1147 00000C91 CD13                <1> 	int 13h				; Read sectors
  1148 00000C93 7308                <1> 	jnc .search_root_dir		; No errors = continue
  1149                              <1> 
  1150 00000C95 E86006              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
  1151 00000C98 73F4                <1> 	jnc .read_root_dir
  1152                              <1> 
  1153 00000C9A 61                  <1> 	popa
  1154 00000C9B EB38                <1> 	jmp .root_problem		; Double error = exit
  1155                              <1> 
  1156                              <1> .search_root_dir:
  1157 00000C9D 61                  <1> 	popa
  1158                              <1> 
  1159 00000C9E B9E000              <1> 	mov cx, 224		; Search all entries in root dir
  1160 00000CA1 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
  1161                              <1> 
  1162                              <1> .next_root_entry:
  1163 00000CA4 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
  1164 00000CA7 BF00E0              <1> 	mov di, disk_buffer		; Point root dir at next entry
  1165 00000CAA 01DF                <1> 	add di, bx
  1166                              <1> 
  1167 00000CAC 8A05                <1> 	mov al, [di]			; First character of name
  1168                              <1> 
  1169 00000CAE 3C00                <1> 	cmp al, 0			; Last file name already checked?
  1170 00000CB0 7423                <1> 	je .root_problem
  1171                              <1> 
  1172 00000CB2 3CE5                <1> 	cmp al, 229			; Was this file deleted?
  1173 00000CB4 74EE                <1> 	je .next_root_entry		; If yes, skip it
  1174                              <1> 
  1175 00000CB6 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
  1176                              <1> 
  1177 00000CB9 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
  1178 00000CBB 74E7                <1> 	je .next_root_entry
  1179                              <1> 
  1180 00000CBD A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
  1181 00000CBF 75E3                <1> 	jnz .next_root_entry
  1182                              <1> 
  1183 00000CC1 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
  1184                              <1> 
  1185 00000CC5 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
  1186 00000CC7 E82B1E              <1> 	call os_string_uppercase
  1187                              <1> 
  1188 00000CCA 8B36[780D]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
  1189                              <1> 
  1190 00000CCE E8BD1E              <1> 	call os_string_compare		; Current entry same as requested?
  1191 00000CD1 7208                <1> 	jc .found_file_to_load
  1192                              <1> 
  1193 00000CD3 E2CF                <1> 	loop .next_root_entry
  1194                              <1> 
  1195                              <1> .root_problem:
  1196 00000CD5 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
  1197 00000CD8 07                  <1> 	pop es
  1198                              <1> 
  1199 00000CD9 F9                  <1> 	stc				; return with size = 0 and carry set
  1200 00000CDA C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> 
  1203                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
  1204 00000CDB 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
  1205 00000CDF 66A3[7C0D]          <1> 	mov [.file_size], eax
  1206                              <1> 
  1207 00000CE3 6683F800            <1> 	cmp eax, 0			; If the file size is zero, don't bother trying
  1208 00000CE7 747B                <1> 	je .end				; to read more clusters
  1209                              <1> 
  1210 00000CE9 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
  1211 00000CEC A3[740D]            <1> 	mov word [.cluster], ax
  1212                              <1> 
  1213 00000CEF B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
  1214 00000CF2 E81206              <1> 	call disk_convert_l2hts
  1215                              <1> 
  1216 00000CF5 BB00E0              <1> 	mov bx, disk_buffer		; ES:BX points to our buffer
  1217                              <1> 
  1218 00000CF8 B402                <1> 	mov ah, 2			; int 13h params: read sectors
  1219 00000CFA B009                <1> 	mov al, 9			; And read 9 of them
  1220                              <1> 
  1221 00000CFC 60                  <1> 	pusha
  1222                              <1> 
  1223                              <1> .read_fat:
  1224 00000CFD 61                  <1> 	popa				; In case registers altered by int 13h
  1225 00000CFE 60                  <1> 	pusha
  1226                              <1> 
  1227 00000CFF F9                  <1> 	stc
  1228 00000D00 CD13                <1> 	int 13h
  1229 00000D02 7308                <1> 	jnc .read_fat_ok
  1230                              <1> 
  1231 00000D04 E8F105              <1> 	call disk_reset_floppy
  1232 00000D07 73F4                <1> 	jnc .read_fat
  1233                              <1> 
  1234 00000D09 61                  <1> 	popa
  1235 00000D0A EBC9                <1> 	jmp .root_problem
  1236                              <1> 
  1237                              <1> 
  1238                              <1> .read_fat_ok:
  1239 00000D0C 61                  <1> 	popa
  1240                              <1> 
  1241                              <1> 
  1242                              <1> .load_file_sector:
  1243 00000D0D A1[740D]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
  1244 00000D10 83C01F              <1> 	add ax, 31
  1245                              <1> 
  1246 00000D13 E8F105              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
  1247                              <1> 
  1248 00000D16 8B1E[7A0D]          <1> 	mov bx, [.load_position]
  1249 00000D1A 8E06[A00D]          <1> 	mov es, [.old_segment]
  1250                              <1> 
  1251 00000D1E B80102              <1> 	mov ax, 0201h			; AH = read sectors, AL = just read 1
  1252                              <1> 
  1253 00000D21 F9                  <1> 	stc
  1254 00000D22 CD13                <1> 	int 13h
  1255                              <1> 
  1256 00000D24 0E                  <1> 	push cs
  1257 00000D25 07                  <1> 	pop es
  1258                              <1> 	
  1259 00000D26 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
  1260                              <1> 
  1261 00000D28 E8CD05              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
  1262 00000D2B 73E0                <1> 	jnc .load_file_sector
  1263                              <1> 
  1264 00000D2D B8[800D]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
  1265 00000D30 E92A09              <1> 	jmp os_fatal_error
  1266                              <1> 
  1267                              <1> 
  1268                              <1> .calculate_next_cluster:
  1269 00000D33 A1[740D]            <1> 	mov ax, [.cluster]
  1270 00000D36 BB0300              <1> 	mov bx, 3
  1271 00000D39 F7E3                <1> 	mul bx
  1272 00000D3B BB0200              <1> 	mov bx, 2
  1273 00000D3E F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
  1274 00000D40 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1275 00000D43 01C6                <1> 	add si, ax
  1276 00000D45 3E8B04              <1> 	mov ax, word [ds:si]
  1277                              <1> 
  1278 00000D48 83FA00              <1> 	cmp dx, 0			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
  1279 00000D4B 7405                <1> 	je .even			; If [CLUSTER] = even, drop last 4 bits of word
  1280                              <1> 					; with next cluster; if odd, drop first 4 bits
  1281                              <1> 
  1282                              <1> .odd:
  1283 00000D4D C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
  1284 00000D50 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1285                              <1> 
  1286                              <1> .even:
  1287 00000D52 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
  1288                              <1> 
  1289                              <1> .calculate_cluster_cont:
  1290 00000D55 A3[740D]            <1> 	mov word [.cluster], ax		; Store cluster
  1291                              <1> 
  1292 00000D58 3DF80F              <1> 	cmp ax, 0FF8h
  1293 00000D5B 7D07                <1> 	jge .end
  1294                              <1> 
  1295 00000D5D 8306[A00D]20        <1> 	add word [.old_segment], 512 / 16
  1296 00000D62 EBA9                <1> 	jmp .load_file_sector		; Onto next sector!
  1297                              <1> 
  1298                              <1> 
  1299                              <1> .end:
  1300 00000D64 668B1E[7C0D]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
  1301 00000D69 60                  <1> 	pusha
  1302 00000D6A 31F6                <1> 	xor si, si
  1303 00000D6C E8E916              <1> 	call os_print_footer
  1304 00000D6F 61                  <1> 	popa
  1305 00000D70 07                  <1> 	pop es
  1306                              <1> 
  1307 00000D71 F8                  <1> 	clc				; Carry clear = good load
  1308 00000D72 C3                  <1> 	ret
  1309                              <1> 
  1310                              <1> 
  1311 00000D73 00                  <1> 	.bootd					db 0 		; Boot device number
  1312 00000D74 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
  1313 00000D76 0000                <1> 	.pointer				dw 0 		; Pointer into disk_buffer, for loading 'file2load'
  1314                              <1> 
  1315 00000D78 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
  1316 00000D7A 0000                <1> 	.load_position			dw 0		; Where we'll load the file
  1317 00000D7C 00000000            <1> 	.file_size				dd 0		; Size of the file
  1318                              <1> 
  1319 00000D80 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy reset fail', 0
  1319 00000D89 696C653A20466C6F70- <1>
  1319 00000D92 707920726573657420- <1>
  1319 00000D9B 6661696C00          <1>
  1320                              <1> 
  1321 00000DA0 0000                <1> 	.old_segment			dw 0
  1322                              <1> 	
  1323 00000DA2 204C6F6164696E6720- <1> 	.msg_load				db ' Loading ', 0
  1323 00000DAB 00                  <1>
  1324                              <1> 	
  1325                              <1> ; --------------------------------------------------------------------------
  1326                              <1> ; os_write_file -- Save (max 64K) file to disk
  1327                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
  1328                              <1> ; OUT: Carry clear if OK, set if failure
  1329                              <1> 
  1330                              <1> os_write_file:
  1331 00000DAC 60                  <1> 	pusha
  1332                              <1> 	
  1333 00000DAD 8C06[830F]          <1> 	mov [.old_segment], es
  1334                              <1> 	
  1335 00000DB1 0E                  <1> 	push cs
  1336 00000DB2 07                  <1> 	pop es
  1337                              <1> 		
  1338 00000DB3 60                  <1> 	pusha							; Message display routine
  1339 00000DB4 89C3                <1> 	mov bx, ax
  1340 00000DB6 B8[850F]            <1> 	mov ax, .msg_save
  1341 00000DB9 B95200              <1> 	mov cx, 82
  1342 00000DBC E8791D              <1> 	call os_string_join
  1343 00000DBF BE5200              <1> 	mov si, 82
  1344 00000DC2 E89316              <1> 	call os_print_footer
  1345 00000DC5 61                  <1> 	popa
  1346                              <1> 
  1347 00000DC6 89C6                <1> 	mov si, ax
  1348 00000DC8 E8D11C              <1> 	call os_string_length
  1349 00000DCB 83F800              <1> 	cmp ax, 0
  1350 00000DCE 0F849601            <1> 	je near .failure
  1351 00000DD2 89F0                <1> 	mov ax, si
  1352                              <1> 
  1353 00000DD4 E81E1D              <1> 	call os_string_uppercase
  1354                              <1> 
  1355 00000DD7 E8CD03              <1> 	call int_filename_convert	; Make filename FAT12-style
  1356 00000DDA 0F828A01            <1> 	jc near .failure
  1357                              <1> 
  1358 00000DDE 890E[770F]          <1> 	mov word [.filesize], cx
  1359 00000DE2 891E[7D0F]          <1> 	mov word [.location], bx
  1360 00000DE6 A3[810F]            <1> 	mov word [.filename], ax
  1361                              <1> 
  1362 00000DE9 E8A201              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
  1363 00000DEC 0F837801            <1> 	jnc near .failure
  1364                              <1> 
  1365                              <1> 
  1366                              <1> 	; First, zero out the .free_clusters list from any previous execution
  1367 00000DF0 60                  <1> 	pusha
  1368                              <1> 
  1369 00000DF1 BF00FF              <1> 	mov di, .free_clusters
  1370 00000DF4 B98000              <1> 	mov cx, 128
  1371                              <1> .clean_free_loop:
  1372 00000DF7 C7050000            <1> 	mov word [di], 0
  1373 00000DFB 47                  <1> 	inc di
  1374 00000DFC 47                  <1> 	inc di
  1375 00000DFD E2F8                <1> 	loop .clean_free_loop
  1376                              <1> 
  1377 00000DFF 61                  <1> 	popa
  1378                              <1> 
  1379                              <1> 
  1380                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
  1381                              <1> 
  1382 00000E00 89C8                <1> 	mov ax, cx
  1383 00000E02 31D2                <1> 	xor dx, dx
  1384 00000E04 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
  1385 00000E07 F7F3                <1> 	div bx
  1386 00000E09 83FA00              <1> 	cmp dx, 0
  1387 00000E0C 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
  1388 00000E0E EB03                <1> 	jmp .carry_on
  1389                              <1> 
  1390                              <1> .add_a_bit:
  1391 00000E10 83C001              <1> 	add ax, 1
  1392                              <1> .carry_on:
  1393                              <1> 
  1394 00000E13 A3[7F0F]            <1> 	mov word [.clusters_needed], ax
  1395                              <1> 
  1396 00000E16 A1[810F]            <1> 	mov word ax, [.filename]	; Get filename back
  1397                              <1> 
  1398 00000E19 E89301              <1> 	call os_create_file		; Create empty root dir entry for this file
  1399 00000E1C 0F824801            <1> 	jc near .failure		; If we can't write to the media, jump out
  1400                              <1> 
  1401 00000E20 8B1E[770F]          <1> 	mov word bx, [.filesize]
  1402 00000E24 83FB00              <1> 	cmp bx, 0
  1403 00000E27 0F842F01            <1> 	je near .finished
  1404                              <1> 
  1405 00000E2B E83604              <1> 	call disk_read_fat		; Get FAT copy into RAM
  1406 00000E2E BE03E0              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
  1407                              <1> 
  1408 00000E31 BB0200              <1> 	mov bx, 2			; Current cluster counter
  1409 00000E34 8B0E[7F0F]          <1> 	mov word cx, [.clusters_needed]
  1410 00000E38 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
  1411                              <1> 
  1412                              <1> .find_free_cluster:
  1413 00000E3A AD                  <1> 	lodsw				; Get a word
  1414 00000E3B 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
  1415 00000E3E 740D                <1> 	jz .found_free_even		; Free entry?
  1416                              <1> 
  1417                              <1> .more_odd:
  1418 00000E40 43                  <1> 	inc bx				; If not, bump our counter
  1419 00000E41 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
  1420                              <1> 
  1421 00000E42 AD                  <1> 	lodsw				; Get word
  1422 00000E43 C1E804              <1> 	shr ax, 4			; Shift for odd
  1423 00000E46 09C0                <1> 	or ax, ax			; Free entry?
  1424 00000E48 7413                <1> 	jz .found_free_odd
  1425                              <1> 
  1426                              <1> .more_even:
  1427 00000E4A 43                  <1> 	inc bx				; If not, keep going
  1428 00000E4B EBED                <1> 	jmp .find_free_cluster
  1429                              <1> 
  1430                              <1> 
  1431                              <1> .found_free_even:
  1432 00000E4D 56                  <1> 	push si
  1433 00000E4E BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1434 00000E51 01D6                <1> 	add si, dx
  1435 00000E53 891C                <1> 	mov word [si], bx
  1436 00000E55 5E                  <1> 	pop si
  1437                              <1> 
  1438 00000E56 49                  <1> 	dec cx				; Got all the clusters we need?
  1439 00000E57 E314                <1> 	jcxz .finished_list
  1440                              <1> 
  1441 00000E59 42                  <1> 	inc dx				; Next word in our list
  1442 00000E5A 42                  <1> 	inc dx
  1443 00000E5B EBE3                <1> 	jmp .more_odd
  1444                              <1> 
  1445                              <1> .found_free_odd:
  1446 00000E5D 56                  <1> 	push si
  1447 00000E5E BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1448 00000E61 01D6                <1> 	add si, dx
  1449 00000E63 891C                <1> 	mov word [si], bx
  1450 00000E65 5E                  <1> 	pop si
  1451                              <1> 
  1452 00000E66 49                  <1> 	dec cx
  1453 00000E67 E304                <1> 	jcxz .finished_list
  1454                              <1> 
  1455 00000E69 42                  <1> 	inc dx				; Next word in our list
  1456 00000E6A 42                  <1> 	inc dx
  1457 00000E6B EBDD                <1> 	jmp .more_even
  1458                              <1> 
  1459                              <1> 
  1460                              <1> 
  1461                              <1> .finished_list:
  1462                              <1> 
  1463                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
  1464                              <1> 	; that correspond to free clusters on the disk; the next job is to
  1465                              <1> 	; create a cluster chain in the FAT for our file
  1466                              <1> 
  1467 00000E6D 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
  1468 00000E6F C706[7B0F]0100      <1> 	mov word [.count], 1		; General cluster counter
  1469                              <1> 
  1470                              <1> .chain_loop:
  1471 00000E75 A1[7B0F]            <1> 	mov word ax, [.count]		; Is this the last cluster?
  1472 00000E78 3B06[7F0F]          <1> 	cmp word ax, [.clusters_needed]
  1473 00000E7C 7454                <1> 	je .last_cluster
  1474                              <1> 
  1475 00000E7E BF00FF              <1> 	mov di, .free_clusters
  1476                              <1> 
  1477 00000E81 01CF                <1> 	add di, cx
  1478 00000E83 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1479                              <1> 
  1480 00000E85 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
  1481 00000E87 31D2                <1> 	xor dx, dx
  1482 00000E89 BB0300              <1> 	mov bx, 3
  1483 00000E8C F7E3                <1> 	mul bx
  1484 00000E8E BB0200              <1> 	mov bx, 2
  1485 00000E91 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1486 00000E93 BE00E0              <1> 	mov si, disk_buffer
  1487 00000E96 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1488 00000E98 3E8B04              <1> 	mov ax, word [ds:si]
  1489                              <1> 
  1490 00000E9B 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1491 00000E9D 741B                <1> 	jz .even
  1492                              <1> 
  1493                              <1> .odd:
  1494 00000E9F 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
  1495 00000EA2 BF00FF              <1> 	mov di, .free_clusters
  1496 00000EA5 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1497 00000EA7 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
  1498 00000EAA C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
  1499 00000EAD 01D8                <1> 	add ax, bx
  1500                              <1> 
  1501 00000EAF 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1502                              <1> 
  1503 00000EB2 FF06[7B0F]          <1> 	inc word [.count]
  1504 00000EB6 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1505 00000EB7 41                  <1> 	inc cx
  1506                              <1> 
  1507 00000EB8 EBBB                <1> 	jmp .chain_loop
  1508                              <1> 
  1509                              <1> .even:
  1510 00000EBA 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
  1511 00000EBD BF00FF              <1> 	mov di, .free_clusters
  1512 00000EC0 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1513 00000EC2 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
  1514                              <1> 
  1515 00000EC5 01D8                <1> 	add ax, bx
  1516                              <1> 
  1517 00000EC7 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1518                              <1> 
  1519 00000ECA FF06[7B0F]          <1> 	inc word [.count]
  1520 00000ECE 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1521 00000ECF 41                  <1> 	inc cx
  1522                              <1> 
  1523 00000ED0 EBA3                <1> 	jmp .chain_loop
  1524                              <1> 
  1525                              <1> 
  1526                              <1> 
  1527                              <1> .last_cluster:
  1528 00000ED2 BF00FF              <1> 	mov di, .free_clusters
  1529 00000ED5 01CF                <1> 	add di, cx
  1530 00000ED7 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1531                              <1> 
  1532 00000ED9 89D8                <1> 	mov ax, bx
  1533                              <1> 
  1534 00000EDB 31D2                <1> 	xor dx, dx
  1535 00000EDD BB0300              <1> 	mov bx, 3
  1536 00000EE0 F7E3                <1> 	mul bx
  1537 00000EE2 BB0200              <1> 	mov bx, 2
  1538 00000EE5 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1539 00000EE7 BE00E0              <1> 	mov si, disk_buffer
  1540 00000EEA 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1541 00000EEC 3E8B04              <1> 	mov ax, word [ds:si]
  1542                              <1> 
  1543 00000EEF 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1544 00000EF1 7408                <1> 	jz .even_last
  1545                              <1> 
  1546                              <1> .odd_last:
  1547 00000EF3 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
  1548 00000EF6 83C080              <1> 	add ax, 0FF80h
  1549 00000EF9 EB06                <1> 	jmp .finito
  1550                              <1> 
  1551                              <1> .even_last:
  1552 00000EFB 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
  1553 00000EFE 05F80F              <1> 	add ax, 0FF8h
  1554                              <1> 
  1555                              <1> 
  1556                              <1> .finito:
  1557 00000F01 3E8904              <1> 	mov word [ds:si], ax
  1558                              <1> 
  1559 00000F04 E88803              <1> 	call disk_write_fat		; Save our FAT back to disk
  1560                              <1> 
  1561                              <1> 
  1562                              <1> 	; Now it's time to save the sectors to disk!
  1563                              <1> 
  1564 00000F07 31C9                <1> 	xor cx, cx
  1565                              <1> 
  1566                              <1> .save_loop:
  1567 00000F09 BF00FF              <1> 	mov di, .free_clusters
  1568 00000F0C 01CF                <1> 	add di, cx
  1569 00000F0E 8B05                <1> 	mov word ax, [di]
  1570                              <1> 
  1571 00000F10 83F800              <1> 	cmp ax, 0
  1572 00000F13 0F842200            <1> 	je near .write_root_entry
  1573                              <1> 
  1574 00000F17 60                  <1> 	pusha
  1575                              <1> 
  1576 00000F18 83C01F              <1> 	add ax, 31
  1577                              <1> 
  1578 00000F1B E8E903              <1> 	call disk_convert_l2hts
  1579                              <1> 
  1580 00000F1E 8B1E[7D0F]          <1> 	mov word bx, [.location]
  1581 00000F22 8E06[830F]          <1> 	mov es, [.old_segment]
  1582                              <1> 	
  1583 00000F26 B80103              <1> 	mov ax, 0301h
  1584 00000F29 F9                  <1> 	stc
  1585 00000F2A CD13                <1> 	int 13h
  1586                              <1> 
  1587 00000F2C 0E                  <1> 	push cs
  1588 00000F2D 07                  <1> 	pop es
  1589                              <1> 		
  1590 00000F2E 61                  <1> 	popa
  1591                              <1> 
  1592 00000F2F 8106[7D0F]0002      <1> 	add word [.location], 512
  1593 00000F35 41                  <1> 	inc cx
  1594 00000F36 41                  <1> 	inc cx
  1595 00000F37 EBD0                <1> 	jmp .save_loop
  1596                              <1> 
  1597                              <1> 
  1598                              <1> .write_root_entry:
  1599                              <1> 
  1600                              <1> 	; Now it's time to head back to the root directory, find our
  1601                              <1> 	; entry and update it with the cluster in use and file size
  1602                              <1> 
  1603 00000F39 E87203              <1> 	call disk_read_root_dir
  1604                              <1> 
  1605 00000F3C A1[810F]            <1> 	mov word ax, [.filename]
  1606 00000F3F E8EA02              <1> 	call disk_get_root_entry
  1607                              <1> 
  1608 00000F42 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
  1609                              <1> 
  1610 00000F45 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
  1611                              <1> 
  1612 00000F48 8B0E[770F]          <1> 	mov word cx, [.filesize]
  1613 00000F4C 894D1C              <1> 	mov word [di+28], cx
  1614                              <1> 
  1615 00000F4F C6451E00            <1> 	mov byte [di+30], 0		; File size
  1616 00000F53 C6451F00            <1> 	mov byte [di+31], 0
  1617                              <1> 
  1618 00000F57 E87F03              <1> 	call disk_write_root_dir
  1619                              <1> 
  1620                              <1> .finished:
  1621 00000F5A 61                  <1> 	popa
  1622 00000F5B 60                  <1> 	pusha
  1623 00000F5C 31F6                <1> 	xor si, si
  1624 00000F5E E8F714              <1> 	call os_print_footer
  1625 00000F61 61                  <1> 	popa
  1626 00000F62 8E06[830F]          <1> 	mov es, [.old_segment]
  1627                              <1> 
  1628 00000F66 F8                  <1> 	clc
  1629 00000F67 C3                  <1> 	ret
  1630                              <1> 
  1631                              <1> .failure:
  1632 00000F68 61                  <1> 	popa
  1633 00000F69 60                  <1> 	pusha
  1634 00000F6A BE0000              <1> 	mov si, 0
  1635 00000F6D E8E814              <1> 	call os_print_footer
  1636 00000F70 61                  <1> 	popa
  1637 00000F71 8E06[830F]          <1> 	mov es, [.old_segment]
  1638                              <1> 
  1639 00000F75 F9                  <1> 	stc				; Couldn't write!
  1640 00000F76 C3                  <1> 	ret
  1641                              <1> 
  1642                              <1> 
  1643 00000F77 0000                <1> 	.filesize				dw 0
  1644 00000F79 0000                <1> 	.cluster				dw 0
  1645 00000F7B 0000                <1> 	.count					dw 0
  1646 00000F7D 0000                <1> 	.location				dw 0
  1647                              <1> 
  1648 00000F7F 0000                <1> 	.clusters_needed		dw 0
  1649                              <1> 
  1650 00000F81 0000                <1> 	.filename				dw 0
  1651                              <1> 
  1652                              <1> 	.free_clusters			equ 65280
  1653                              <1> 
  1654 00000F83 0000                <1> 	.old_segment			dw 0
  1655                              <1> 
  1656 00000F85 20536176696E672000  <1> 	.msg_save				db ' Saving ', 0
  1657                              <1> 	
  1658                              <1> ; --------------------------------------------------------------------------
  1659                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1660                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1661                              <1> 
  1662                              <1> os_file_exists:
  1663 00000F8E E8641B              <1> 	call os_string_uppercase
  1664 00000F91 E81302              <1> 	call int_filename_convert	; Make FAT12-style filename
  1665                              <1> 
  1666 00000F94 50                  <1> 	push ax
  1667 00000F95 E8041B              <1> 	call os_string_length
  1668 00000F98 83F800              <1> 	cmp ax, 0
  1669 00000F9B 740F                <1> 	je .failure
  1670 00000F9D 58                  <1> 	pop ax
  1671                              <1> 
  1672 00000F9E 50                  <1> 	push ax
  1673 00000F9F E80C03              <1> 	call disk_read_root_dir
  1674                              <1> 
  1675 00000FA2 58                  <1> 	pop ax				; Restore filename
  1676                              <1> 
  1677 00000FA3 BF00E0              <1> 	mov di, disk_buffer
  1678                              <1> 
  1679 00000FA6 E88302              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1680                              <1> 
  1681 00000FA9 9C                  <1> 	pushf
  1682                              <1> 
  1683 00000FAA 9D                  <1> 	popf
  1684 00000FAB C3                  <1> 	ret
  1685                              <1> 
  1686                              <1> .failure:
  1687 00000FAC 58                  <1> 	pop ax
  1688                              <1> 
  1689 00000FAD F9                  <1> 	stc
  1690 00000FAE C3                  <1> 	ret
  1691                              <1> 
  1692                              <1> 
  1693                              <1> ; --------------------------------------------------------------------------
  1694                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1695                              <1> ; IN: AX = location of filename; OUT: Nothing
  1696                              <1> 
  1697                              <1> os_create_file:
  1698 00000FAF F8                  <1> 	clc
  1699                              <1> 
  1700 00000FB0 E8421B              <1> 	call os_string_uppercase
  1701 00000FB3 E8F101              <1> 	call int_filename_convert	; Make FAT12-style filename
  1702 00000FB6 60                  <1> 	pusha
  1703                              <1> 
  1704 00000FB7 50                  <1> 	push ax				; Save filename for now
  1705                              <1> 
  1706 00000FB8 E8D3FF              <1> 	call os_file_exists		; Does the file already exist?
  1707 00000FBB 731B                <1> 	jnc .exists_error
  1708                              <1> 
  1709                              <1> 
  1710                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1711                              <1> 
  1712 00000FBD BF00E0              <1> 	mov di, disk_buffer		; So point DI at it!
  1713                              <1> 
  1714 00000FC0 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1715                              <1> .next_entry:
  1716 00000FC3 8A05                <1> 	mov byte al, [di]
  1717 00000FC5 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1718 00000FC7 7412                <1> 	je .found_free_entry
  1719 00000FC9 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1720 00000FCB 740E                <1> 	je .found_free_entry
  1721 00000FCD 83C720              <1> 	add di, 32			; If not, go onto next entry
  1722 00000FD0 E2F1                <1> 	loop .next_entry
  1723                              <1> 	
  1724 00000FD2 B8[6F10]            <1> 	mov ax, .err_msg		; Is the root directory full?
  1725 00000FD5 E88506              <1> 	call os_fatal_error
  1726                              <1> 
  1727                              <1> .exists_error:				; We also get here if above loop finds nothing
  1728 00000FD8 58                  <1> 	pop ax				; Get filename back
  1729                              <1> 
  1730 00000FD9 EB7C                <1> 	jmp .failure
  1731                              <1> 
  1732                              <1> .found_free_entry:
  1733 00000FDB 5E                  <1> 	pop si				; Get filename back
  1734 00000FDC B90B00              <1> 	mov cx, 11
  1735 00000FDF F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1736                              <1> 
  1737                              <1> 	; Get the time information
  1738                              <1> 	
  1739 00000FE1 60                  <1> 	pusha
  1740 00000FE2 B402                <1> 	mov ah, 2
  1741 00000FE4 E89307              <1> 	call os_int_1Ah
  1742                              <1> 
  1743 00000FE7 88E8                <1> 	mov al, ch			; Hours
  1744 00000FE9 E8D404              <1> 	call os_bcd_to_int
  1745 00000FEC 89C3                <1> 	mov bx, ax
  1746 00000FEE C1E306              <1> 	shl bx, 6
  1747                              <1> 	
  1748 00000FF1 88C8                <1> 	mov al, cl			; Minutes
  1749 00000FF3 E8CA04              <1> 	call os_bcd_to_int
  1750 00000FF6 09C3                <1> 	or bx, ax
  1751 00000FF8 C1E305              <1> 	shl bx, 5
  1752                              <1> 	
  1753 00000FFB D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
  1754 00000FFD 88F0                <1> 	mov al, dh
  1755 00000FFF E8BE04              <1> 	call os_bcd_to_int
  1756 00001002 09C3                <1> 	or bx, ax
  1757                              <1> 	
  1758 00001004 891E[5D10]          <1> 	mov [.creation_time], bx
  1759 00001008 891E[6510]          <1> 	mov [.write_time], bx
  1760                              <1> 
  1761                              <1> 	; Get date information
  1762                              <1> 	
  1763 0000100C B404                <1> 	mov ah, 4
  1764 0000100E E86907              <1> 	call os_int_1Ah
  1765                              <1> 
  1766 00001011 52                  <1> 	push dx
  1767 00001012 88E8                <1> 	mov al, ch			; Century
  1768 00001014 E8A904              <1> 	call os_bcd_to_int
  1769 00001017 BB6400              <1> 	mov bx, 100
  1770 0000101A F7E3                <1> 	mul bx
  1771 0000101C 89C3                <1> 	mov bx, ax
  1772                              <1> 	
  1773 0000101E 88C8                <1> 	mov al, cl			; Years
  1774 00001020 E89D04              <1> 	call os_bcd_to_int
  1775 00001023 01C3                <1> 	add bx, ax
  1776                              <1> 	
  1777 00001025 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
  1778                              <1> 	
  1779 00001029 C1E304              <1> 	shl bx, 4
  1780 0000102C 5A                  <1> 	pop dx
  1781                              <1> 	
  1782 0000102D 88F0                <1> 	mov al, dh			; Months
  1783 0000102F E88E04              <1> 	call os_bcd_to_int
  1784 00001032 09C3                <1> 	or bx, ax
  1785 00001034 C1E305              <1> 	shl bx, 5
  1786                              <1> 	
  1787 00001037 88D0                <1> 	mov al, dl			; Days
  1788 00001039 E88404              <1> 	call os_bcd_to_int
  1789 0000103C 09C3                <1> 	or bx, ax
  1790                              <1> 	
  1791 0000103E 891E[5F10]          <1> 	mov [.creation_date], bx
  1792 00001042 891E[6710]          <1> 	mov [.write_date], bx
  1793 00001046 61                  <1> 	popa
  1794                              <1> 	
  1795 00001047 BE[5A10]            <1> 	mov si, .table		; Copy over all the attributes
  1796 0000104A B91500              <1> 	mov cx, 21
  1797 0000104D F3A4                <1> 	rep movsb
  1798                              <1> 	
  1799 0000104F E88702              <1> 	call disk_write_root_dir
  1800 00001052 7203                <1> 	jc .failure
  1801                              <1> 
  1802 00001054 61                  <1> 	popa
  1803                              <1> 
  1804 00001055 F8                  <1> 	clc				; Clear carry for success
  1805 00001056 C3                  <1> 	ret
  1806                              <1> 
  1807                              <1> .failure:
  1808 00001057 61                  <1> 	popa
  1809                              <1> 
  1810 00001058 F9                  <1> 	stc
  1811 00001059 C3                  <1> 	ret
  1812                              <1> 
  1813                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
  1814                              <1> 	.table:
  1815 0000105A 00                  <1> 		.atttribute		db 0
  1816 0000105B 00<rep 2h>          <1> 		.reserved		times 2 db 0
  1817 0000105D 0000                <1> 		.creation_time	dw 0
  1818 0000105F 0000                <1> 		.creation_date	dw 0
  1819 00001061 00<rep 4h>          <1> 		.reserved2		times 4 db 0
  1820 00001065 0000                <1> 		.write_time		dw 0
  1821 00001067 0000                <1> 		.write_date		dw 0
  1822 00001069 00<rep 6h>          <1> 		.reserved3		times 6 db 0
  1823 0000106F 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
  1823 00001078 682073706163652069- <1>
  1823 00001081 6E206469726563746F- <1>
  1823 0000108A 727900              <1>
  1824                              <1> 
  1825                              <1> ; --------------------------------------------------------------------------
  1826                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1827                              <1> ; IN: AX = location of filename to remove
  1828                              <1> 
  1829                              <1> os_remove_file:
  1830 0000108D 60                  <1> 	pusha
  1831 0000108E E8641A              <1> 	call os_string_uppercase
  1832 00001091 E81301              <1> 	call int_filename_convert	; Make filename FAT12-style
  1833 00001094 50                  <1> 	push ax				; Save filename
  1834                              <1> 
  1835 00001095 F8                  <1> 	clc
  1836                              <1> 
  1837 00001096 E81502              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1838                              <1> 
  1839 00001099 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1840                              <1> 
  1841 0000109C 58                  <1> 	pop ax				; Get chosen filename back
  1842                              <1> 
  1843 0000109D E88C01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1844 000010A0 7268                <1> 	jc .failure			; If entry can't be found
  1845                              <1> 
  1846                              <1> 
  1847 000010A2 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1848 000010A6 A3[0D11]            <1> 	mov word [.cluster], ax		; And save it
  1849                              <1> 
  1850 000010A9 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1851                              <1> 
  1852 000010AC 47                  <1> 	inc di
  1853                              <1> 
  1854 000010AD 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
  1855                              <1> .clean_loop:
  1856 000010AF C60500              <1> 	mov byte [di], 0
  1857 000010B2 47                  <1> 	inc di
  1858 000010B3 41                  <1> 	inc cx
  1859 000010B4 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1860 000010B7 7CF6                <1> 	jl .clean_loop
  1861                              <1> 
  1862 000010B9 E81D02              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1863                              <1> 
  1864                              <1> 
  1865 000010BC E8A501              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1866 000010BF BF00E0              <1> 	mov di, disk_buffer		; And DI points to it
  1867                              <1> 
  1868                              <1> 
  1869                              <1> .more_clusters:
  1870 000010C2 A1[0D11]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1871                              <1> 
  1872 000010C5 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1873 000010C8 743D                <1> 	je .nothing_to_do
  1874                              <1> 
  1875 000010CA BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1876 000010CD F7E3                <1> 	mul bx
  1877 000010CF BB0200              <1> 	mov bx, 2
  1878 000010D2 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1879 000010D4 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1880 000010D7 01C6                <1> 	add si, ax
  1881 000010D9 3E8B04              <1> 	mov ax, word [ds:si]
  1882                              <1> 
  1883 000010DC 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1884                              <1> 
  1885 000010DE 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1886                              <1> 					; with next cluster; if odd, drop first 4 bits
  1887                              <1> .odd:
  1888 000010E0 50                  <1> 	push ax
  1889 000010E1 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1890 000010E4 3E8904              <1> 	mov word [ds:si], ax
  1891 000010E7 58                  <1> 	pop ax
  1892                              <1> 
  1893 000010E8 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1894 000010EB EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1895                              <1> 
  1896                              <1> .even:
  1897 000010ED 50                  <1> 	push ax
  1898 000010EE 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1899 000010F1 3E8904              <1> 	mov word [ds:si], ax
  1900 000010F4 58                  <1> 	pop ax
  1901                              <1> 
  1902 000010F5 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1903                              <1> 
  1904                              <1> .calculate_cluster_cont:
  1905 000010F8 A3[0D11]            <1> 	mov word [.cluster], ax		; Store cluster
  1906                              <1> 
  1907 000010FB 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1908 000010FE 7302                <1> 	jae .end
  1909                              <1> 
  1910 00001100 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1911                              <1> 
  1912                              <1> .end:
  1913 00001102 E88A01              <1> 	call disk_write_fat
  1914 00001105 7203                <1> 	jc .failure
  1915                              <1> 
  1916                              <1> .nothing_to_do:
  1917 00001107 61                  <1> 	popa
  1918                              <1> 
  1919 00001108 F8                  <1> 	clc
  1920 00001109 C3                  <1> 	ret
  1921                              <1> 
  1922                              <1> .failure:
  1923 0000110A 61                  <1> 	popa
  1924                              <1> 
  1925 0000110B F9                  <1> 	stc
  1926 0000110C C3                  <1> 	ret
  1927                              <1> 
  1928                              <1> 
  1929 0000110D 0000                <1> 	.cluster dw 0
  1930                              <1> 
  1931                              <1> 
  1932                              <1> ; --------------------------------------------------------------------------
  1933                              <1> ; os_rename_file -- Change the name of a file on the disk
  1934                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1935                              <1> ; OUT: carry set on error
  1936                              <1> 
  1937                              <1> os_rename_file:
  1938 0000110F 53                  <1> 	push bx
  1939 00001110 50                  <1> 	push ax
  1940                              <1> 
  1941 00001111 F8                  <1> 	clc
  1942                              <1> 
  1943 00001112 E89901              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1944                              <1> 
  1945 00001115 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1946                              <1> 
  1947 00001118 58                  <1> 	pop ax				; Get chosen filename back
  1948                              <1> 
  1949 00001119 E8D919              <1> 	call os_string_uppercase
  1950 0000111C E88800              <1> 	call int_filename_convert
  1951 0000111F 721E                <1> 	jc .fail_read
  1952                              <1> 	
  1953 00001121 E80801              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1954 00001124 7219                <1> 	jc .fail_read			; Quit out if file not found
  1955                              <1> 
  1956 00001126 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1957                              <1> 
  1958 00001127 89D8                <1> 	mov ax, bx
  1959                              <1> 
  1960 00001129 E8C919              <1> 	call os_string_uppercase
  1961 0000112C E87800              <1> 	call int_filename_convert
  1962 0000112F 7211                <1> 	jc .fail_write
  1963                              <1> 	
  1964 00001131 89C6                <1> 	mov si, ax
  1965                              <1> 
  1966 00001133 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1967 00001136 F3A4                <1> 	rep movsb
  1968                              <1> 
  1969 00001138 E89E01              <1> 	call disk_write_root_dir	; Save root dir to disk
  1970 0000113B 7205                <1> 	jc .fail_write
  1971                              <1> 
  1972                              <1> 
  1973 0000113D F8                  <1> 	clc
  1974 0000113E C3                  <1> 	ret
  1975                              <1> 
  1976                              <1> .fail_read:
  1977 0000113F 58                  <1> 	pop ax
  1978                              <1> 
  1979 00001140 F9                  <1> 	stc
  1980 00001141 C3                  <1> 	ret
  1981                              <1> 
  1982                              <1> .fail_write:
  1983                              <1> 
  1984 00001142 F9                  <1> 	stc
  1985 00001143 C3                  <1> 	ret
  1986                              <1> 
  1987                              <1> 
  1988                              <1> ; --------------------------------------------------------------------------
  1989                              <1> ; os_get_file_size -- Get file size information for specified file
  1990                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
  1991                              <1> ; or carry set if file not found
  1992                              <1> 
  1993                              <1> os_get_file_size:
  1994 00001144 60                  <1> 	pusha
  1995                              <1> 
  1996 00001145 E8AD19              <1> 	call os_string_uppercase
  1997 00001148 E85C00              <1> 	call int_filename_convert
  1998                              <1> 
  1999 0000114B F8                  <1> 	clc
  2000                              <1> 
  2001 0000114C 50                  <1> 	push ax
  2002                              <1> 
  2003 0000114D E85E01              <1> 	call disk_read_root_dir
  2004 00001150 7219                <1> 	jc .failure
  2005                              <1> 
  2006 00001152 58                  <1> 	pop ax
  2007                              <1> 
  2008 00001153 BF00E0              <1> 	mov di, disk_buffer
  2009                              <1> 
  2010 00001156 E8D300              <1> 	call disk_get_root_entry
  2011 00001159 7210                <1> 	jc .failure
  2012                              <1> 
  2013 0000115B 668B5D1C            <1> 	mov ebx, [di+28]
  2014                              <1> 
  2015 0000115F 66891E[6E11]        <1> 	mov [.tmp], ebx
  2016                              <1> 
  2017 00001164 61                  <1> 	popa
  2018                              <1> 
  2019 00001165 668B1E[6E11]        <1> 	mov ebx, [.tmp]
  2020                              <1> 
  2021                              <1> 
  2022 0000116A C3                  <1> 	ret
  2023                              <1> 
  2024                              <1> .failure:
  2025 0000116B 61                  <1> 	popa
  2026 0000116C F9                  <1> 	stc
  2027                              <1> 
  2028 0000116D C3                  <1> 	ret
  2029                              <1> 
  2030                              <1> 
  2031 0000116E 00000000            <1> 	.tmp	dd 0
  2032                              <1> 
  2033                              <1> ; --------------------------------------------------------------------------
  2034                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
  2035                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
  2036                              <1> ; or carry set if file not found
  2037                              <1> 
  2038                              <1> os_get_file_datetime:
  2039 00001172 60                  <1> 	pusha
  2040                              <1> 
  2041 00001173 E87F19              <1> 	call os_string_uppercase
  2042 00001176 E82E00              <1> 	call int_filename_convert
  2043                              <1> 
  2044 00001179 F8                  <1> 	clc
  2045                              <1> 
  2046 0000117A 50                  <1> 	push ax
  2047                              <1> 
  2048 0000117B E83001              <1> 	call disk_read_root_dir
  2049 0000117E 7220                <1> 	jc .failure
  2050                              <1> 
  2051 00001180 58                  <1> 	pop ax
  2052                              <1> 
  2053 00001181 BF00E0              <1> 	mov di, disk_buffer
  2054                              <1> 
  2055 00001184 E8A500              <1> 	call disk_get_root_entry
  2056 00001187 7217                <1> 	jc .failure
  2057                              <1> 
  2058 00001189 8B4516              <1> 	mov ax, [di+22]
  2059 0000118C 8B5D18              <1> 	mov bx, [di+24]
  2060                              <1> 
  2061 0000118F A3[A311]            <1> 	mov [.tmp], ax
  2062 00001192 891E[A511]          <1> 	mov [.tmp + 2], bx
  2063                              <1> 
  2064 00001196 61                  <1> 	popa
  2065                              <1> 
  2066 00001197 8B1E[A311]          <1> 	mov bx, [.tmp]
  2067 0000119B 8B0E[A511]          <1> 	mov cx, [.tmp + 2]
  2068                              <1> 
  2069                              <1> 
  2070 0000119F C3                  <1> 	ret
  2071                              <1> 
  2072                              <1> .failure:
  2073 000011A0 61                  <1> 	popa
  2074 000011A1 F9                  <1> 	stc
  2075                              <1> 
  2076 000011A2 C3                  <1> 	ret
  2077                              <1> 
  2078                              <1> 
  2079 000011A3 00000000            <1> 	.tmp	dd 0
  2080                              <1> 
  2081                              <1> 
  2082                              <1> ; ==================================================================
  2083                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  2084                              <1> 
  2085                              <1> ; ------------------------------------------------------------------
  2086                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  2087                              <1> ; IN: AX = filename string
  2088                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  2089                              <1> 
  2090                              <1> 
  2091                              <1> int_filename_convert:
  2092 000011A7 60                  <1> 	pusha
  2093                              <1> 
  2094 000011A8 89C6                <1> 	mov si, ax
  2095                              <1> 
  2096 000011AA E8EF18              <1> 	call os_string_length
  2097 000011AD 83F80C              <1> 	cmp ax, 12			; Filename too long?
  2098 000011B0 7F49                <1> 	jg .failure0			; Fail if so
  2099                              <1> 
  2100 000011B2 83F800              <1> 	cmp ax, 0
  2101 000011B5 744B                <1> 	je .failure1			; Similarly, fail if zero-char string
  2102                              <1> 
  2103 000011B7 89C2                <1> 	mov dx, ax			; Store string length for now
  2104                              <1> 
  2105 000011B9 BF[1F12]            <1> 	mov di, .dest_string
  2106                              <1> 
  2107 000011BC B90000              <1> 	mov cx, 0
  2108                              <1> .copy_loop:
  2109 000011BF AC                  <1> 	lodsb
  2110 000011C0 3C2E                <1> 	cmp al, '.'
  2111 000011C2 7408                <1> 	je .extension_found
  2112 000011C4 AA                  <1> 	stosb
  2113 000011C5 41                  <1> 	inc cx
  2114 000011C6 39D1                <1> 	cmp cx, dx
  2115 000011C8 7F3F                <1> 	jg .failure2			; No extension found = wrong
  2116 000011CA EBF3                <1> 	jmp .copy_loop
  2117                              <1> 
  2118                              <1> .extension_found:
  2119 000011CC 83F900              <1> 	cmp cx, 0
  2120 000011CF 743F                <1> 	je .failure3			; Fail if extension dot is first char
  2121                              <1> 
  2122 000011D1 83F908              <1> 	cmp cx, 8
  2123 000011D4 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  2124                              <1> 
  2125                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  2126                              <1> 	; with spaces, if necessary
  2127                              <1> 
  2128                              <1> .add_spaces:
  2129 000011D6 C60520              <1> 	mov byte [di], ' '
  2130 000011D9 47                  <1> 	inc di
  2131 000011DA 41                  <1> 	inc cx
  2132 000011DB 83F908              <1> 	cmp cx, 8
  2133 000011DE 7CF6                <1> 	jl .add_spaces
  2134                              <1> 
  2135                              <1> 	; Finally, copy over the extension
  2136                              <1> .do_extension:
  2137 000011E0 AC                  <1> 	lodsb				; 3 characters
  2138 000011E1 3C00                <1> 	cmp al, 0
  2139 000011E3 7432                <1> 	je .failure4
  2140 000011E5 AA                  <1> 	stosb
  2141 000011E6 AC                  <1> 	lodsb
  2142 000011E7 3C00                <1> 	cmp al, 0
  2143 000011E9 742C                <1> 	je .failure4
  2144 000011EB AA                  <1> 	stosb
  2145 000011EC AC                  <1> 	lodsb
  2146 000011ED 3C00                <1> 	cmp al, 0
  2147 000011EF 7426                <1> 	je .failure4
  2148 000011F1 AA                  <1> 	stosb
  2149                              <1> 
  2150 000011F2 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  2151                              <1> 
  2152 000011F5 61                  <1> 	popa
  2153 000011F6 B8[1F12]            <1> 	mov ax, .dest_string
  2154 000011F9 F8                  <1> 	clc				; Clear carry for success
  2155 000011FA C3                  <1> 	ret
  2156                              <1> 
  2157                              <1> 
  2158                              <1> .failure0:
  2159 000011FB C606860000          <1> 	mov byte [0086h], 0
  2160 00001200 EB1A                <1> 	jmp .failure
  2161                              <1> 	
  2162                              <1> .failure1:
  2163 00001202 C606860001          <1> 	mov byte [0086h], 1
  2164 00001207 EB13                <1> 	jmp .failure
  2165                              <1> 	
  2166                              <1> .failure2:
  2167 00001209 C606860002          <1> 	mov byte [0086h], 2
  2168 0000120E EB0C                <1> 	jmp .failure
  2169                              <1> 	
  2170                              <1> .failure3:
  2171 00001210 C606860003          <1> 	mov byte [0086h], 3
  2172 00001215 EB05                <1> 	jmp .failure
  2173                              <1> 	
  2174                              <1> .failure4:
  2175 00001217 C606860004          <1> 	mov byte [0086h], 4
  2176                              <1> 
  2177                              <1> .failure:	
  2178 0000121C 61                  <1> 	popa
  2179 0000121D F9                  <1> 	stc				; Set carry for failure
  2180 0000121E C3                  <1> 	ret
  2181                              <1> 
  2182 0000121F 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  2183                              <1> 
  2184                              <1> 
  2185                              <1> ; --------------------------------------------------------------------------
  2186                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  2187                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  2188                              <1> ; or carry set if file not found
  2189                              <1> 
  2190                              <1> disk_get_root_entry:
  2191 0000122C 60                  <1> 	pusha
  2192                              <1> 
  2193 0000122D A3[6012]            <1> 	mov word [.filename], ax
  2194                              <1> 
  2195 00001230 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  2196 00001233 B80000              <1> 	mov ax, 0			; Searching at offset 0
  2197                              <1> 
  2198                              <1> .to_next_root_entry:
  2199 00001236 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  2200                              <1> 
  2201 00001238 8B36[6012]          <1> 	mov word si, [.filename]	; Start searching for filename
  2202 0000123C B90B00              <1> 	mov cx, 11
  2203 0000123F F3A6                <1> 	rep cmpsb
  2204 00001241 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  2205                              <1> 
  2206 00001243 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  2207                              <1> 
  2208 00001246 BF00E0              <1> 	mov di, disk_buffer		; Point to next root dir entry
  2209 00001249 01C7                <1> 	add di, ax
  2210                              <1> 
  2211 0000124B 87D1                <1> 	xchg dx, cx			; Get the original CX back
  2212 0000124D E2E7                <1> 	loop .to_next_root_entry
  2213                              <1> 
  2214 0000124F 61                  <1> 	popa
  2215                              <1> 
  2216 00001250 F9                  <1> 	stc				; Set carry if entry not found
  2217 00001251 C3                  <1> 	ret
  2218                              <1> 
  2219                              <1> 
  2220                              <1> .found_file:
  2221 00001252 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  2222                              <1> 
  2223 00001255 893E[6212]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  2224                              <1> 
  2225 00001259 61                  <1> 	popa
  2226                              <1> 
  2227 0000125A 8B3E[6212]          <1> 	mov word di, [.tmp]
  2228                              <1> 
  2229 0000125E F8                  <1> 	clc
  2230 0000125F C3                  <1> 	ret
  2231                              <1> 
  2232                              <1> 
  2233 00001260 0000                <1> 	.filename	dw 0
  2234 00001262 0000                <1> 	.tmp		dw 0
  2235                              <1> 
  2236                              <1> 
  2237                              <1> ; --------------------------------------------------------------------------
  2238                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  2239                              <1> ; IN: Nothing; OUT: carry set if failure
  2240                              <1> 
  2241                              <1> disk_read_fat:
  2242 00001264 60                  <1> 	pusha
  2243                              <1> 
  2244 00001265 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2245 00001268 E89C00              <1> 	call disk_convert_l2hts
  2246                              <1> 
  2247 0000126B BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2248 0000126E 8CCB                <1> 	mov bx, cs
  2249 00001270 8EC3                <1> 	mov es, bx
  2250 00001272 89F3                <1> 	mov bx, si
  2251                              <1> 
  2252 00001274 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2253 00001276 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  2254                              <1> 
  2255 00001278 60                  <1> 	pusha				; Prepare to enter loop
  2256                              <1> 
  2257                              <1> 
  2258                              <1> .read_fat_loop:
  2259 00001279 61                  <1> 	popa
  2260 0000127A 60                  <1> 	pusha
  2261                              <1> 
  2262 0000127B F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2263 0000127C CD13                <1> 	int 13h				; Read sectors
  2264                              <1> 
  2265 0000127E 7308                <1> 	jnc .fat_done
  2266 00001280 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  2267 00001283 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  2268                              <1> 
  2269 00001285 61                  <1> 	popa
  2270 00001286 EB04                <1> 	jmp .read_failure		; Fatal double error
  2271                              <1> 
  2272                              <1> .fat_done:
  2273 00001288 61                  <1> 	popa				; Restore registers from main loop
  2274                              <1> 
  2275 00001289 61                  <1> 	popa				; And restore registers from start of system call
  2276 0000128A F8                  <1> 	clc
  2277 0000128B C3                  <1> 	ret
  2278                              <1> 
  2279                              <1> .read_failure:
  2280 0000128C 61                  <1> 	popa
  2281 0000128D F9                  <1> 	stc				; Set carry flag (for failure)
  2282 0000128E C3                  <1> 	ret
  2283                              <1> 
  2284                              <1> 
  2285                              <1> ; --------------------------------------------------------------------------
  2286                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  2287                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  2288                              <1> 
  2289                              <1> disk_write_fat:
  2290 0000128F 60                  <1> 	pusha
  2291                              <1> 
  2292 00001290 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2293 00001293 E87100              <1> 	call disk_convert_l2hts
  2294                              <1> 
  2295 00001296 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2296 00001299 8CDB                <1> 	mov bx, ds
  2297 0000129B 8EC3                <1> 	mov es, bx
  2298 0000129D 89F3                <1> 	mov bx, si
  2299                              <1> 
  2300 0000129F B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2301 000012A1 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  2302                              <1> 
  2303 000012A3 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2304 000012A4 CD13                <1> 	int 13h				; Write sectors
  2305                              <1> 
  2306 000012A6 7203                <1> 	jc .write_failure		; Fatal double error
  2307                              <1> 
  2308 000012A8 61                  <1> 	popa				; And restore from start of system call
  2309 000012A9 F8                  <1> 	clc
  2310 000012AA C3                  <1> 	ret
  2311                              <1> 
  2312                              <1> .write_failure:
  2313 000012AB 61                  <1> 	popa
  2314 000012AC F9                  <1> 	stc				; Set carry flag (for failure)
  2315 000012AD C3                  <1> 	ret
  2316                              <1> 
  2317                              <1> 
  2318                              <1> ; --------------------------------------------------------------------------
  2319                              <1> ; disk_read_root_dir -- Get the root directory contents
  2320                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  2321                              <1> 
  2322                              <1> disk_read_root_dir:
  2323 000012AE 60                  <1> 	pusha
  2324                              <1> 
  2325 000012AF B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2326 000012B2 E85200              <1> 	call disk_convert_l2hts
  2327                              <1> 
  2328 000012B5 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2329 000012B8 8CDB                <1> 	mov bx, ds
  2330 000012BA 8EC3                <1> 	mov es, bx
  2331 000012BC 89F3                <1> 	mov bx, si
  2332                              <1> 
  2333 000012BE B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2334 000012C0 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  2335                              <1> 
  2336 000012C2 60                  <1> 	pusha				; Prepare to enter loop
  2337                              <1> 
  2338                              <1> 
  2339                              <1> .read_root_dir_loop:
  2340 000012C3 61                  <1> 	popa
  2341 000012C4 60                  <1> 	pusha
  2342                              <1> 
  2343 000012C5 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2344 000012C6 CD13                <1> 	int 13h				; Read sectors
  2345                              <1> 
  2346 000012C8 7308                <1> 	jnc .root_dir_finished
  2347 000012CA E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  2348 000012CD 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  2349                              <1> 
  2350 000012CF 61                  <1> 	popa
  2351 000012D0 EB04                <1> 	jmp .read_failure		; Fatal double error
  2352                              <1> 
  2353                              <1> 
  2354                              <1> .root_dir_finished:
  2355 000012D2 61                  <1> 	popa				; Restore registers from main loop
  2356                              <1> 
  2357 000012D3 61                  <1> 	popa				; And restore from start of this system call
  2358 000012D4 F8                  <1> 	clc				; Clear carry (for success)
  2359 000012D5 C3                  <1> 	ret
  2360                              <1> 
  2361                              <1> .read_failure:
  2362 000012D6 61                  <1> 	popa
  2363 000012D7 F9                  <1> 	stc				; Set carry flag (for failure)
  2364 000012D8 C3                  <1> 	ret
  2365                              <1> 
  2366                              <1> ; --------------------------------------------------------------------------
  2367                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  2368                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  2369                              <1> 
  2370                              <1> disk_write_root_dir:
  2371 000012D9 60                  <1> 	pusha
  2372                              <1> 
  2373 000012DA B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2374 000012DD E82700              <1> 	call disk_convert_l2hts
  2375                              <1> 
  2376 000012E0 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2377 000012E3 8CDB                <1> 	mov bx, ds
  2378 000012E5 8EC3                <1> 	mov es, bx
  2379 000012E7 89F3                <1> 	mov bx, si
  2380                              <1> 
  2381 000012E9 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2382 000012EB B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  2383                              <1> 
  2384 000012ED F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2385 000012EE CD13                <1> 	int 13h				; Write sectors
  2386 000012F0 7203                <1> 	jc .write_failure
  2387                              <1> 
  2388 000012F2 61                  <1> 	popa				; And restore from start of this system call
  2389 000012F3 F8                  <1> 	clc
  2390 000012F4 C3                  <1> 	ret
  2391                              <1> 
  2392                              <1> .write_failure:
  2393 000012F5 61                  <1> 	popa
  2394 000012F6 F9                  <1> 	stc				; Set carry flag (for failure)
  2395 000012F7 C3                  <1> 	ret
  2396                              <1> 
  2397                              <1> 
  2398                              <1> ; --------------------------------------------------------------------------
  2399                              <1> ; Reset floppy disk
  2400                              <1> 
  2401                              <1> disk_reset_floppy:
  2402 000012F8 50                  <1> 	push ax
  2403 000012F9 52                  <1> 	push dx
  2404 000012FA B80000              <1> 	mov ax, 0
  2405                              <1> ; ******************************************************************
  2406 000012FD 8A16[3613]          <1> 	mov dl, [bootdev]
  2407                              <1> ; ******************************************************************
  2408 00001301 F9                  <1> 	stc
  2409 00001302 CD13                <1> 	int 13h
  2410 00001304 5A                  <1> 	pop dx
  2411 00001305 58                  <1> 	pop ax
  2412 00001306 C3                  <1> 	ret
  2413                              <1> 
  2414                              <1> 
  2415                              <1> ; --------------------------------------------------------------------------
  2416                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  2417                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  2418                              <1> 
  2419                              <1> disk_convert_l2hts:
  2420 00001307 53                  <1> 	push bx
  2421 00001308 50                  <1> 	push ax
  2422                              <1> 
  2423 00001309 89C3                <1> 	mov bx, ax			; Save logical sector
  2424                              <1> 
  2425 0000130B BA0000              <1> 	mov dx, 0			; First the sector
  2426 0000130E F736[3413]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2427 00001312 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  2428 00001315 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  2429 00001317 89D8                <1> 	mov ax, bx
  2430                              <1> 
  2431 00001319 BA0000              <1> 	mov dx, 0			; Now calculate the head
  2432 0000131C F736[3413]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2433 00001320 BA0000              <1> 	mov dx, 0
  2434 00001323 F736[3213]          <1> 	div word [Sides]		; Floppy sides
  2435 00001327 88D6                <1> 	mov dh, dl			; Head/side
  2436 00001329 88C5                <1> 	mov ch, al			; Track
  2437                              <1> 	
  2438 0000132B 58                  <1> 	pop ax
  2439 0000132C 5B                  <1> 	pop bx
  2440                              <1> 
  2441 0000132D 8A16[3613]          <1> 	mov dl, [bootdev]		; Set correct device
  2442                              <1> 
  2443 00001331 C3                  <1> 	ret
  2444                              <1> 
  2445                              <1> 
  2446                              <1> 
  2447 00001332 0200                <1> 	Sides dw 2
  2448 00001334 1200                <1> 	SecsPerTrack dw 18
  2449                              <1> 	
  2450 00001336 00                  <1> 	bootdev db 0			; Boot device number
  2451                              <1> 
  2452                              <1> 
  2453                              <1> ; ==================================================================
  2454                              <1> 
  2455                              <1> 
   815                                  	%INCLUDE "features/keyboard.asm"
   816                              <1> ; ==================================================================
   817                              <1> ; KEYBOARD HANDLING ROUTINES
   818                              <1> ; ==================================================================
   819                              <1> 
   820                              <1> ; ------------------------------------------------------------------
   821                              <1> ; os_wait_for_key -- Waits for keypress and returns key
   822                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   823                              <1> ; IN: Nothing; OUT: AX = key pressed, other regs preserved
   824                              <1> 
   825                              <1> os_wait_for_key:
   826 00001337 60                  <1> 	pusha
   827                              <1> 	
   828                              <1> .try_again:
   829 00001338 B700                <1> 	mov bh, 0
   830 0000133A E88200              <1> 	call .screen_power
   831                              <1> 
   832                              <1> 	; Reset the screensaver tick
   833 0000133D 0FB606F2DE          <1> 	movzx ax, byte [57074]
   834 00001342 BB4404              <1> 	mov bx, 1092		; 18.2 Hz * 60 seconds
   835 00001345 F7E3                <1> 	mul bx
   836 00001347 A3[9E49]            <1> 	mov [screensaver_timer], ax		; See "int.asm"
   837                              <1> 	
   838 0000134A C606[D813]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
   839                              <1> 
   840 0000134F A08200              <1> 	mov al, [0082h]				; Save the current screen state, for later
   841 00001352 A2[D513]            <1> 	mov [.gfx_state], al
   842 00001355 B403                <1> 	mov ah, 03h
   843 00001357 B700                <1> 	mov bh, 0
   844 00001359 CD10                <1> 	int 10h
   845 0000135B 890E[D613]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
   846                              <1> 	
   847                              <1> .loop:
   848 0000135F F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
   849 00001360 E82C00              <1> 	call .screensaver
   850 00001363 E87400              <1> 	call os_check_for_key
   851                              <1> 	
   852 00001366 83F800              <1> 	cmp ax, 0
   853 00001369 74F4                <1> 	je .loop
   854                              <1> 
   855 0000136B 60                  <1> 	pusha
   856 0000136C B80005              <1> 	mov ax, 0500h
   857 0000136F CD10                <1> 	int 10h
   858                              <1> 	
   859 00001371 A0[D513]            <1> 	mov al, [.gfx_state]
   860 00001374 A28200              <1> 	mov [0082h], al
   861 00001377 8B0E[D613]          <1> 	mov cx, [.orig_crsr]
   862 0000137B B401                <1> 	mov ah, 01h
   863 0000137D CD10                <1> 	int 10h
   864 0000137F 61                  <1> 	popa
   865                              <1> 	
   866 00001380 803E[D813]01        <1> 	cmp byte [.scrn_active], 1
   867 00001385 74B1                <1> 	je .try_again
   868                              <1> 	
   869 00001387 A3[D313]            <1> 	mov [.tmp_buf], ax
   870                              <1> 
   871 0000138A 61                  <1> 	popa
   872 0000138B A1[D313]            <1> 	mov ax, [.tmp_buf]
   873 0000138E C3                  <1> 	ret
   874                              <1> 	
   875                              <1> .screensaver:
   876 0000138F 833E[9E49]00        <1> 	cmp word [screensaver_timer], 0
   877 00001394 7528                <1> 	jne .good
   878                              <1> 	
   879 00001396 803EF2DE00          <1> 	cmp byte [57074], 0
   880 0000139B 7421                <1> 	je .good
   881                              <1> 	
   882 0000139D B40F                <1> 	mov ah, 0Fh
   883 0000139F CD10                <1> 	int 10h
   884                              <1> 	
   885 000013A1 3C03                <1> 	cmp al, 3
   886 000013A3 7519                <1> 	jne .good
   887                              <1> 	
   888 000013A5 60                  <1> 	pusha
   889 000013A6 C606820001          <1> 	mov byte [0082h], 1
   890 000013AB B80105              <1> 	mov ax, 0501h
   891 000013AE CD10                <1> 	int 10h
   892 000013B0 E8B405              <1> 	call os_hide_cursor
   893 000013B3 C606[D813]01        <1> 	mov byte [.scrn_active], 1
   894                              <1> 
   895 000013B8 B704                <1> 	mov bh, 4
   896 000013BA E80200              <1> 	call .screen_power
   897 000013BD 61                  <1> 	popa
   898                              <1> 
   899                              <1> .good:
   900 000013BE C3                  <1> 	ret
   901                              <1> 	
   902                              <1> .screen_power:
   903 000013BF 3A3E[D913]          <1> 	cmp bh, [.scrn_power]
   904 000013C3 74F9                <1> 	je .good
   905                              <1> 
   906 000013C5 60                  <1> 	pusha
   907 000013C6 B8104F              <1> 	mov ax, 4F10h
   908 000013C9 B301                <1> 	mov bl, 1
   909 000013CB 883E[D913]          <1> 	mov [.scrn_power], bh
   910 000013CF CD10                <1> 	int 10h
   911 000013D1 61                  <1> 	popa
   912 000013D2 C3                  <1> 	ret
   913                              <1> 	
   914 000013D3 0000                <1> 	.tmp_buf		dw 0
   915 000013D5 00                  <1> 	.gfx_state		db 0
   916 000013D6 0000                <1> 	.orig_crsr		dw 0
   917 000013D8 00                  <1> 	.scrn_active	db 0
   918 000013D9 00                  <1> 	.scrn_power		db 0
   919                              <1> 	
   920                              <1> ; ------------------------------------------------------------------
   921                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   922                              <1> ; Also handles special keyboard shortcuts.
   923                              <1> ; IN: Nothing; OUT: AX = 0 if no key pressed, otherwise scan code
   924                              <1> 
   925                              <1> os_check_for_key:
   926 000013DA 60                  <1> 	pusha
   927                              <1> 
   928 000013DB B411                <1> 	mov ah, 11h			; BIOS call to check for key
   929                              <1> 	
   930 000013DD CD16                <1> 	int 16h
   931                              <1> 		
   932 000013DF 740F                <1> 	jz .nokey			; If no key, skip to end
   933                              <1> 
   934 000013E1 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   935 000013E3 CD16                <1> 	int 16h
   936                              <1> 
   937 000013E5 E80E00              <1> 	call special_keys
   938                              <1> 
   939 000013E8 A3[F413]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   940                              <1> 
   941 000013EB 61                  <1> 	popa				; But restore all other regs
   942 000013EC A1[F413]            <1> 	mov ax, [.tmp_buf]
   943 000013EF C3                  <1> 	ret
   944                              <1> 
   945                              <1> .nokey:
   946 000013F0 61                  <1> 	popa
   947                              <1> 	clr ax			; Zero result if no key pressed
    14 000013F1 31C0                <2>  xor %1, %1
   948 000013F3 C3                  <1> 	ret
   949                              <1> 
   950                              <1> 
   951 000013F4 0000                <1> 	.tmp_buf	dw 0
   952                              <1> 
   953                              <1> 
   954                              <1> ; ==================================================================
   955                              <1> 
   956                              <1> ; Checks for special keys and performs their action.
   957                              <1> ; IN: AX = key
   958                              <1> ; OUT: nothing
   959                              <1> special_keys:
   960 000013F6 60                  <1> 	pusha
   961 000013F7 80FC69              <1> 	cmp ah, 105
   962 000013FA 0F844E00            <1> 	je near .disable_sound
   963 000013FE 80FC6A              <1> 	cmp ah, 106
   964 00001401 0F844000            <1> 	je near .enable_sound
   965 00001405 80FC6B              <1> 	cmp ah, 107
   966 00001408 0F842500            <1> 	je near .exit_app
   967 0000140C 80FC8B              <1> 	cmp ah, 139
   968 0000140F 0F840200            <1> 	je near .intended_system_crash
   969 00001413 61                  <1> 	popa
   970 00001414 C3                  <1> 	ret
   971                              <1> 	
   972                              <1> .intended_system_crash:
   973 00001415 B8[1B14]            <1> 	mov ax, .crash_msg
   974 00001418 E84202              <1> 	call os_fatal_error
   975                              <1> 	
   976 0000141B 496E74656E64656420- <1> 	.crash_msg		db 'Intended system crash', 0
   976 00001424 73797374656D206372- <1>
   976 0000142D 61736800            <1>
   977                              <1> 	
   978                              <1> .exit_app:
   979 00001431 803E[7109]00        <1> 	cmp byte [app_running], 0
   980 00001436 0F840900            <1> 	je near .no_exit
   981                              <1> 	
   982 0000143A 61                  <1> 	popa
   983                              <1> 	
   984 0000143B 8B26[6F09]          <1> 	mov sp, [origstack]
   985 0000143F 83EC02              <1> 	sub sp, 2
   986                              <1> 	
   987 00001442 C3                  <1> 	ret
   988                              <1> 	
   989                              <1> .no_exit:
   990 00001443 61                  <1> 	popa
   991 00001444 C3                  <1> 	ret
   992                              <1> 		
   993                              <1> .enable_sound:
   994 00001445 C606830001          <1> 	mov byte [0083h], 1
   995 0000144A EB08                <1> 	jmp .display_speaker
   996                              <1> 	
   997                              <1> .disable_sound:
   998 0000144C C606830000          <1> 	mov byte [0083h], 0
   999 00001451 E8FF12              <1> 	call os_speaker_off
  1000                              <1> 
  1001                              <1> .display_speaker:
  1002 00001454 803E820001          <1> 	cmp byte [0082h], 1
  1003 00001459 741E                <1> 	je .no_display_spkr
  1004                              <1> 
  1005 0000145B E8D204              <1> 	call os_get_cursor_pos
  1006 0000145E 52                  <1> 	push dx
  1007 0000145F BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
  1008 00001462 E8C204              <1> 	call os_move_cursor
  1009                              <1> 	
  1010 00001465 B8170E              <1> 	mov ax, 0E17h
  1011 00001468 B700                <1> 	mov bh, 0
  1012 0000146A 803E830000          <1> 	cmp byte [0083h], 0
  1013 0000146F 7402                <1> 	je .no_crossed_spkr
  1014                              <1> 	
  1015 00001471 FEC8                <1> 	dec al
  1016                              <1> 	
  1017                              <1> .no_crossed_spkr:
  1018 00001473 CD10                <1> 	int 10h
  1019 00001475 5A                  <1> 	pop dx
  1020 00001476 E8AE04              <1> 	call os_move_cursor
  1021                              <1> 	
  1022                              <1> .no_display_spkr:
  1023 00001479 61                  <1> 	popa
  1024 0000147A C3                  <1> 	ret
  1025                              <1> 	
  1026                              <1> ; ==================================================================
  1027                              <1> 
   816                                  	%INCLUDE "features/math.asm"
   817                              <1> ; ==================================================================
   818                              <1> ; MATH ROUTINES
   819                              <1> ; ==================================================================
   820                              <1> 
   821                              <1> ; ------------------------------------------------------------------
   822                              <1> ; os_seed_random -- Seed the random number generator based on the current state of registers and time
   823                              <1> ; IN: every register; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_seed_random:
   826 0000147B 60                  <1> 	pusha
   827                              <1> 
   828 0000147C B402                <1> 	mov ah, 02h
   829 0000147E CD1A                <1> 	int 1Ah
   830                              <1> 	
   831 00001480 31D8                <1> 	xor ax, bx
   832 00001482 01C8                <1> 	add ax, cx
   833 00001484 31D0                <1> 	xor ax, dx
   834 00001486 01F0                <1> 	add ax, si
   835 00001488 31F8                <1> 	xor ax, di
   836 0000148A 01E0                <1> 	add ax, sp
   837 0000148C 31E8                <1> 	xor ax, bp
   838 0000148E 05ADDE              <1> 	add ax, 0xDEAD
   839 00001491 35EFBE              <1> 	xor ax, 0xBEEF
   840                              <1> 	
   841 00001494 A3[9914]            <1> 	mov [os_random_seed], ax	; Store the data
   842 00001497 61                  <1> 	popa
   843 00001498 C3                  <1> 	ret
   844                              <1> 
   845                              <1> 
   846 00001499 0000                <1> 	os_random_seed	dw 0
   847                              <1> 
   848                              <1> 
   849                              <1> ; ------------------------------------------------------------------
   850                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
   851                              <1> ; IN: AX = low integer, BX = high integer
   852                              <1> ; OUT: CX = random integer
   853                              <1> 
   854                              <1> os_get_random:
   855 0000149B 52                  <1> 	push dx
   856 0000149C 53                  <1> 	push bx
   857 0000149D 50                  <1> 	push ax
   858                              <1> 
   859 0000149E 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
   860 000014A0 E80D00              <1> 	call .generate_random
   861 000014A3 89DA                <1> 	mov dx, bx
   862 000014A5 42                  <1> 	inc dx
   863 000014A6 F7E2                <1> 	mul dx
   864 000014A8 89D1                <1> 	mov cx, dx
   865                              <1> 
   866 000014AA 58                  <1> 	pop ax
   867 000014AB 5B                  <1> 	pop bx
   868 000014AC 5A                  <1> 	pop dx
   869 000014AD 01C1                <1> 	add cx, ax			; Add the low offset back
   870 000014AF C3                  <1> 	ret
   871                              <1> 
   872                              <1> 
   873                              <1> .generate_random:
   874 000014B0 52                  <1> 	push dx
   875 000014B1 53                  <1> 	push bx
   876                              <1> 
   877 000014B2 A1[9914]            <1> 	mov ax, [os_random_seed]
   878 000014B5 BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
   879 000014B8 F7E2                <1> 	mul dx				; DX:AX = AX * DX
   880 000014BA A3[9914]            <1> 	mov [os_random_seed], ax
   881                              <1> 
   882 000014BD 5B                  <1> 	pop bx
   883 000014BE 5A                  <1>  	pop dx
   884 000014BF C3                  <1> 	ret
   885                              <1> 
   886                              <1> 
   887                              <1> ; ------------------------------------------------------------------
   888                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   889                              <1> ; IN: AL = BCD number; OUT: AX = integer value
   890                              <1> 
   891                              <1> os_bcd_to_int:
   892 000014C0 60                  <1> 	pusha
   893                              <1> 
   894 000014C1 88C3                <1> 	mov bl, al			; Store entire number for now
   895                              <1> 
   896 000014C3 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
   897 000014C6 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
   898                              <1> 
   899 000014C8 C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
   900 000014CB B00A                <1> 	mov al, 10
   901 000014CD F6E3                <1> 	mul bl				; AX = 10 * BL
   902                              <1> 
   903 000014CF 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
   904 000014D1 A3[D914]            <1> 	mov [.tmp], ax
   905                              <1> 
   906 000014D4 61                  <1> 	popa
   907 000014D5 A1[D914]            <1> 	mov ax, [.tmp]			; And return it in AX!
   908 000014D8 C3                  <1> 	ret
   909                              <1> 
   910                              <1> 
   911 000014D9 0000                <1> 	.tmp	dw 0
   912                              <1> 
   913                              <1> 	
   914                              <1> ; ------------------------------------------------------------------
   915                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   916                              <1> ; IN: AL = integer value; OUT: AL = BCD number
   917                              <1> 
   918                              <1> os_int_to_bcd:
   919 000014DB 60                  <1> 	pusha
   920 000014DC 0FB6C0              <1> 	movzx ax, al
   921 000014DF 31D2                <1> 	xor dx, dx
   922                              <1> 	
   923 000014E1 BB0A00              <1> 	mov bx, 10
   924 000014E4 F7F3                <1> 	div bx
   925                              <1> 	
   926 000014E6 C0E004              <1> 	shl al, 4
   927 000014E9 00C2                <1> 	add dl, al
   928                              <1> 	
   929 000014EB 8816[F414]          <1> 	mov [.tmp], dl
   930 000014EF 61                  <1> 	popa
   931 000014F0 A0[F414]            <1> 	mov al, [.tmp]
   932 000014F3 C3                  <1> 	ret
   933                              <1> 
   934 000014F4 00                  <1> 	.tmp	db 0
   935                              <1> 
   936                              <1> 
   937                              <1> ; Calculates EAX^EBX.
   938                              <1> ; IN: EAX^EBX = input
   939                              <1> ; OUT: EAX = result
   940                              <1> 
   941                              <1> os_math_power:
   942 000014F5 6660                <1> 	pushad
   943 000014F7 6683FB01            <1> 	cmp ebx, 1
   944 000014FB 0F841900            <1> 	je near .power_end
   945 000014FF 6683FB00            <1> 	cmp ebx, 0
   946 00001503 0F841F00            <1> 	je near .zero
   947 00001507 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   948 0000150A 6689C3              <1> 	mov ebx, eax
   949                              <1> .power_loop:
   950 0000150D 66F7E3              <1> 	mul ebx
   951 00001510 6649                <1> 	dec ecx
   952 00001512 6683F901            <1> 	cmp ecx, 1
   953 00001516 7FF5                <1> 	jnle .power_loop
   954                              <1> .power_end:
   955 00001518 66A3[3215]          <1> 	mov [.tmp_dword], eax
   956 0000151C 6661                <1> 	popad
   957 0000151E 66A1[3215]          <1> 	mov eax, [.tmp_dword]
   958 00001522 6631D2              <1> 	xor edx, edx
   959 00001525 C3                  <1> 	ret
   960                              <1> .zero:
   961 00001526 6661                <1> 	popad
   962 00001528 66B801000000        <1> 	mov eax, 1
   963 0000152E 6631D2              <1> 	xor edx, edx
   964 00001531 C3                  <1> 	ret
   965                              <1> 	
   966 00001532 00000000            <1> 	.tmp_dword		dd 0
   967 00001536 00000000            <1> 	.tmp_dword2		dd 0
   968                              <1> 	
   969                              <1> ; Calculates the EBX root of EAX.
   970                              <1> ; IN: EAX = input, EBX = root
   971                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   972                              <1> 
   973                              <1> os_math_root:
   974 0000153A 6660                <1> 	pushad
   975 0000153C 6689C1              <1> 	mov ecx, eax				; Prepare the data
   976 0000153F 66BE02000000        <1> 	mov esi, 2
   977                              <1> .root_loop:
   978 00001545 6689F0              <1> 	mov eax, esi
   979 00001548 E8AAFF              <1> 	call os_math_power
   980 0000154B 6639C8              <1> 	cmp eax, ecx
   981 0000154E 0F840800            <1> 	je near .root_exact
   982 00001552 0F8F1300            <1> 	jg near .root_range
   983 00001556 6646                <1> 	inc esi
   984 00001558 EBEB                <1> 	jmp .root_loop
   985                              <1> .root_exact:
   986 0000155A 668936[8115]        <1> 	mov [.tmp_dword], esi
   987 0000155F 6661                <1> 	popad
   988 00001561 66A1[8115]          <1> 	mov eax, [.tmp_dword]
   989 00001565 6631D2              <1> 	xor edx, edx
   990 00001568 C3                  <1> 	ret
   991                              <1> .root_range:
   992 00001569 668936[8515]        <1> 	mov [.tmp_dword2], esi
   993 0000156E 664E                <1> 	dec esi
   994 00001570 668936[8115]        <1> 	mov [.tmp_dword], esi
   995 00001575 6661                <1> 	popad
   996 00001577 66A1[8115]          <1> 	mov eax, [.tmp_dword]
   997 0000157B 668B16[8515]        <1> 	mov edx, [.tmp_dword2]
   998 00001580 C3                  <1> 	ret
   999                              <1> 	
  1000 00001581 00000000            <1> 	.tmp_dword		dd 0
  1001 00001585 00000000            <1> 	.tmp_dword2		dd 0
  1002                              <1> 
  1003                              <1> ; ==================================================================
   817                                  	%INCLUDE "features/misc.asm"
   818                              <1> ; ==================================================================
   819                              <1> ; MISCELLANEOUS ROUTINES
   820                              <1> ; ==================================================================
   821                              <1> 
   822                              <1> ; ------------------------------------------------------------------
   823                              <1> ; os_pause -- Delay execution for specified 110ms chunks
   824                              <1> ; IN: AX = amount of ticks to wait
   825                              <1> 
   826                              <1> os_pause:
   827 00001589 60                  <1> 	pusha
   828 0000158A 83F800              <1> 	cmp ax, 0
   829 0000158D 741F                <1> 	je .time_up			; If delay = 0 then bail out
   830                              <1> 
   831 0000158F C706[C515]0000      <1> 	mov word [.counter_var], 0		; Zero the counter variable
   832                              <1> 
   833 00001595 A3[C315]            <1> 	mov [.orig_req_delay], ax	; Save it
   834                              <1> 
   835 00001598 B400                <1> 	mov ah, 0
   836 0000159A E8DD01              <1> 	call os_int_1Ah				; Get tick count	
   837                              <1> 
   838 0000159D 8916[C715]          <1> 	mov [.prev_tick_count], dx	; Save it for later comparison
   839                              <1> 
   840                              <1> .checkloop:
   841 000015A1 B400                <1> 	mov ah,0
   842 000015A3 E8D401              <1> 	call os_int_1Ah				; Get tick count again
   843                              <1> 
   844 000015A6 3916[C715]          <1> 	cmp [.prev_tick_count], dx	; Compare with previous tick count
   845                              <1> 
   846 000015AA 7504                <1> 	jne .up_date			; If it's changed check it
   847 000015AC EBF3                <1> 	jmp .checkloop			; Otherwise wait some more
   848                              <1> 
   849                              <1> .time_up:
   850 000015AE 61                  <1> 	popa
   851 000015AF C3                  <1> 	ret
   852                              <1> 
   853                              <1> .up_date:
   854 000015B0 FF06[C515]          <1> 	inc word [.counter_var]		; Inc counter_var
   855 000015B4 A1[C515]            <1> 	mov ax, [.counter_var]
   856                              <1> 	
   857 000015B7 3B06[C315]          <1> 	cmp ax, [.orig_req_delay]	; Is counter_var = required delay?
   858 000015BB 7DF1                <1> 	jge .time_up			; Yes, so bail out
   859                              <1> 
   860 000015BD 8916[C715]          <1> 	mov [.prev_tick_count], dx	; No, so update .prev_tick_count 
   861                              <1> 
   862 000015C1 EBDE                <1> 	jmp .checkloop			; And go wait some more
   863                              <1> 
   864                              <1> 
   865 000015C3 0000                <1> 	.orig_req_delay		dw	0
   866 000015C5 0000                <1> 	.counter_var		dw	0
   867 000015C7 0000                <1> 	.prev_tick_count	dw	0
   868                              <1> 
   869                              <1> ; ------------------------------------------------------------------
   870                              <1> ; os_clear_registers -- Clear all registers
   871                              <1> ; IN: Nothing; OUT: Clear registers
   872                              <1> 
   873                              <1> os_clear_registers:
   874 000015C9 6631C0              <1> 	xor eax, eax
   875 000015CC 6631DB              <1> 	xor ebx, ebx
   876 000015CF 6631C9              <1> 	xor ecx, ecx
   877 000015D2 6631D2              <1> 	xor edx, edx
   878 000015D5 6631F6              <1> 	xor esi, esi
   879 000015D8 6631FF              <1> 	xor edi, edi
   880 000015DB C3                  <1> 	ret
   881                              <1> 
   882                              <1> os_illegal_call:
   883 000015DC B8[E115]            <1> 	mov ax, .msg
   884 000015DF EB7C                <1> 	jmp os_fatal_error
   885                              <1> 	
   886 000015E1 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   886 000015EA 6E6F6E2D6578697374- <1>
   886 000015F3 656E74207379737465- <1>
   886 000015FC 6D2066756E6374696F- <1>
   886 00001605 6E00                <1>
   887                              <1> 	
   888                              <1> os_update_clock:
   889 00001607 60                  <1> 	pusha
   890 00001608 803E820001          <1> 	cmp byte [0082h], 1
   891 0000160D 0F843B00            <1> 	je near .update_time_end
   892                              <1> 	
   893 00001611 B402                <1> 	mov ah, 02h			; Get the time
   894 00001613 E86401              <1> 	call os_int_1Ah
   895 00001616 3B0E[5A16]          <1> 	cmp cx, [.tmp_time]
   896 0000161A 0F842E00            <1> 	je near .update_time_end
   897 0000161E 890E[5A16]          <1> 	mov [.tmp_time], cx
   898                              <1> 	
   899 00001622 E80B03              <1> 	call os_get_cursor_pos
   900 00001625 52                  <1> 	push dx
   901                              <1> 	
   902 00001626 BB[4E16]            <1> 	mov bx, .tmp_buffer
   903 00001629 E8B016              <1> 	call os_get_date_string
   904                              <1> 	
   905 0000162C BA4500              <1> 	mov dx, 69			; Display date
   906 0000162F E8F502              <1> 	call os_move_cursor
   907                              <1> 
   908 00001632 89DE                <1> 	mov si, bx
   909 00001634 E87F02              <1> 	call os_print_string
   910                              <1> 	
   911 00001637 BB[4E16]            <1> 	mov bx, .tmp_buffer
   912 0000163A E85816              <1> 	call os_get_time_string
   913                              <1> 
   914 0000163D BA3F00              <1> 	mov dx, 63			; Display time
   915 00001640 E8E402              <1> 	call os_move_cursor
   916 00001643 89DE                <1> 	mov si, bx
   917 00001645 E86E02              <1> 	call os_print_string
   918                              <1> 	
   919 00001648 5A                  <1> 	pop dx
   920 00001649 E8DB02              <1> 	call os_move_cursor
   921                              <1> 	
   922                              <1> .update_time_end:
   923 0000164C 61                  <1> 	popa
   924 0000164D C3                  <1> 	ret
   925                              <1> 	
   926 0000164E 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
   927 0000165A 0000                <1> 	.tmp_time		dw 0
   928 0000165C 00                  <1> 	.tmp_hours		db 0
   929                              <1> 
   930                              <1> ; ------------------------------------------------------------------
   931                              <1> ; os_fatal_error -- Display error message and halt execution
   932                              <1> ; IN: AX = error message string location
   933                              <1> 
   934                              <1> os_fatal_error:
   935 0000165D A3[5917]            <1> 	mov [.ax], ax			; Store string location for now, ...
   936 00001660 E8AE02              <1> 	call os_clear_screen
   937                              <1> 	
   938                              <1> .main_screen:
   939 00001663 8CC8                <1> 	mov ax, cs
   940 00001665 8ED8                <1> 	mov ds, ax
   941 00001667 8EC0                <1> 	mov es, ax
   942                              <1> 
   943 00001669 B80300              <1> 	mov ax, 3
   944 0000166C CD10                <1> 	int 10h
   945                              <1> 	
   946 0000166E B80310              <1> 	mov ax, 1003h				; Set text output with certain attributes
   947 00001671 31DB                <1> 	xor bx, bx					; to be bright, and not blinking
   948 00001673 CD10                <1> 	int 10h	
   949                              <1> 
   950 00001675 B8[1117]            <1> 	mov ax, .title_msg
   951 00001678 BB[2517]            <1> 	mov bx, .footer_msg
   952 0000167B B94F00              <1> 	mov cx, 01001111b
   953 0000167E E8C608              <1> 	call os_draw_background
   954 00001681 E8390E              <1> 	call os_reset_font
   955                              <1> 	
   956 00001684 BA0002              <1> 	mov dx, 2 * 256
   957 00001687 E89D02              <1> 	call os_move_cursor
   958 0000168A BE[7209]            <1> 	mov si, bomblogo
   959 0000168D E86B0E              <1> 	call os_draw_icon
   960                              <1> 	
   961 00001690 BA2302              <1> 	mov dx, 2 * 256 + 35
   962 00001693 E89102              <1> 	call os_move_cursor
   963                              <1> 	
   964 00001696 BE[2617]            <1> 	mov si, .msg0
   965 00001699 E81A02              <1> 	call os_print_string
   966                              <1> 	
   967 0000169C BA2303              <1> 	mov dx, 3 * 256 + 35
   968 0000169F E88502              <1> 	call os_move_cursor
   969                              <1> 	
   970 000016A2 B82A0A              <1> 	mov ax, 0A2Ah					; Write a 43-character long asterisk-type line
   971 000016A5 B700                <1> 	mov bh, 0
   972 000016A7 B92B00              <1> 	mov cx, 43
   973 000016AA CD10                <1> 	int 10h
   974                              <1> 	
   975 000016AC BA2305              <1> 	mov dx, 5 * 256 + 35
   976 000016AF E87502              <1> 	call os_move_cursor
   977 000016B2 BE[5117]            <1> 	mov si, .msg3
   978 000016B5 E8FE01              <1> 	call os_print_string
   979                              <1> 
   980 000016B8 8B36[5917]          <1> 	mov si, [.ax]
   981 000016BC E8F701              <1> 	call os_print_string
   982                              <1> 
   983 000016BF E8A502              <1> 	call os_hide_cursor
   984                              <1> 	
   985 000016C2 5B                  <1> 	pop bx
   986 000016C3 58                  <1> 	pop ax
   987                              <1> 	
   988                              <1> 	mov16 dx, 35, 7
    18 000016C4 BA2307              <2>  mov %1, (%2 + %3 * 256)
   989 000016C7 E85D02              <1> 	call os_move_cursor
   990                              <1> 	
   991 000016CA BE[F016]            <1> 	mov si, .msg
   992 000016CD E8E601              <1> 	call os_print_string
   993                              <1> 	
   994 000016D0 E8A30B              <1> 	call os_print_4hex
   995                              <1> 	
   996 000016D3 B03A                <1> 	mov al, ':'
   997 000016D5 E8CA01              <1> 	call os_putchar
   998                              <1> 	
   999 000016D8 89D8                <1> 	mov ax, bx
  1000 000016DA E8990B              <1> 	call os_print_4hex
  1001                              <1> 	
  1002                              <1> 	mov16 dx, 35, 8
    18 000016DD BA2308              <2>  mov %1, (%2 + %3 * 256)
  1003 000016E0 E84402              <1> 	call os_move_cursor
  1004                              <1> 	
  1005 000016E3 BE[0117]            <1> 	mov si, .msg1
  1006 000016E6 E8CD01              <1> 	call os_print_string
  1007                              <1> 	
  1008 000016E9 89E0                <1> 	mov ax, sp
  1009 000016EB E8880B              <1> 	call os_print_4hex
  1010                              <1> 	
  1011 000016EE FA                  <1> 	cli
  1012 000016EF F4                  <1> 	hlt
  1013                              <1> 	
  1014 000016F0 4372617368206C6F63- <1> 	.msg 			db 'Crash location: ', 0
  1014 000016F9 6174696F6E3A2000    <1>
  1015 00001701 537461636B20706F69- <1> 	.msg1			db 'Stack pointer: ', 0
  1015 0000170A 6E7465723A2000      <1>
  1016                              <1> 	
  1017 00001711 4D696368616C4F5320- <1> 	.title_msg		db 'MichalOS Fatal Error'
  1017 0000171A 466174616C20457272- <1>
  1017 00001723 6F72                <1>
  1018 00001725 00                  <1> 	.footer_msg		db 0
  1019                              <1> 	
  1020 00001726 4D696368616C4F5320- <1> 	.msg0			db 'MichalOS has encountered a critical error.', 0
  1020 0000172F 68617320656E636F75- <1>
  1020 00001738 6E7465726564206120- <1>
  1020 00001741 637269746963616C20- <1>
  1020 0000174A 6572726F722E00      <1>
  1021 00001751 4572726F723A2000    <1> 	.msg3			db 'Error: ', 0
  1022                              <1> 
  1023 00001759 0000                <1> 	.ax				dw 0
  1024                              <1> 
  1025                              <1> ; Gets the amount of system RAM.
  1026                              <1> ; IN: nothing
  1027                              <1> ; OUT: AX = conventional memory(kB), EBX = high memory(kB)
  1028                              <1> os_get_memory:
  1029 0000175B 60                  <1> 	pusha
  1030 0000175C 31C9                <1> 	xor cx, cx
  1031 0000175E CD12                <1> 	int 12h					; Get the conventional memory size...
  1032 00001760 A3[7317]            <1> 	mov [.conv_mem], ax		; ...and store it
  1033                              <1> 	
  1034 00001763 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
  1035 00001765 CD15                <1> 	int 15h
  1036 00001767 A3[7517]            <1> 	mov [.high_mem], ax		; ...and store it too
  1037 0000176A 61                  <1> 	popa
  1038 0000176B A1[7317]            <1> 	mov ax, [.conv_mem]
  1039 0000176E 8B1E[7517]          <1> 	mov bx, [.high_mem]
  1040 00001772 C3                  <1> 	ret
  1041                              <1> 
  1042 00001773 0000                <1> 	.conv_mem	dw 0
  1043 00001775 0000                <1> 	.high_mem	dw 0
  1044                              <1> 
  1045                              <1> ; Calls a system function from a far location.
  1046                              <1> ; IN: BP = System function number (8000h, 8003h...)
  1047                              <1> ; OUT: nothing
  1048                              <1> os_far_call:
  1049 00001777 FFD5                <1> 	call bp
  1050 00001779 CB                  <1> 	retf
  1051                              <1> 	
  1052                              <1> ; Serves as a middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
  1053                              <1> ; IN/OUT: same as int 1Ah
  1054                              <1> os_int_1Ah:
  1055 0000177A 60                  <1> 	pusha
  1056                              <1> 
  1057 0000177B 80FC02              <1> 	cmp ah, 2		; Read system time
  1058 0000177E 7416                <1> 	je .read_time
  1059                              <1> 	
  1060 00001780 80FC04              <1> 	cmp ah, 4		; Read system date
  1061 00001783 7404                <1> 	je .read_date
  1062                              <1> 	
  1063 00001785 61                  <1> 	popa
  1064 00001786 CD1A                <1> 	int 1Ah
  1065 00001788 C3                  <1> 	ret
  1066                              <1> 	
  1067                              <1> .read_date:
  1068 00001789 E81700              <1> 	call .update_time
  1069 0000178C 61                  <1> 	popa
  1070 0000178D 8B16[6718]          <1> 	mov dx, [.days]
  1071 00001791 8B0E[6918]          <1> 	mov cx, [.years]
  1072 00001795 C3                  <1> 	ret
  1073                              <1> 	
  1074                              <1> .read_time:
  1075 00001796 E80A00              <1> 	call .update_time
  1076                              <1> 	
  1077 00001799 61                  <1> 	popa
  1078 0000179A 8A36[6418]          <1> 	mov dh, [.seconds]
  1079 0000179E 8B0E[6518]          <1> 	mov cx, [.minutes]
  1080                              <1> 	
  1081 000017A2 C3                  <1> 	ret
  1082                              <1> 
  1083                              <1> .update_time:
  1084 000017A3 B404                <1> 	mov ah, 4
  1085 000017A5 CD1A                <1> 	int 1Ah
  1086 000017A7 8916[6718]          <1> 	mov [.days], dx
  1087 000017AB 890E[6918]          <1> 	mov [.years], cx
  1088                              <1> 	
  1089 000017AF B402                <1> 	mov ah, 2
  1090 000017B1 CD1A                <1> 	int 1Ah
  1091                              <1> 
  1092 000017B3 8836[6418]          <1> 	mov [.seconds], dh
  1093 000017B7 890E[6518]          <1> 	mov [.minutes], cx
  1094                              <1> 	
  1095                              <1> 	; Convert all of these values from BCD to integers
  1096                              <1> 	
  1097 000017BB B90700              <1> 	mov cx, 7
  1098 000017BE BE[6418]            <1> 	mov si, .seconds
  1099 000017C1 89F7                <1> 	mov di, si
  1100                              <1> 	
  1101                              <1> .loop:
  1102 000017C3 AC                  <1> 	lodsb
  1103 000017C4 E8F9FC              <1> 	call os_bcd_to_int
  1104 000017C7 AA                  <1> 	stosb
  1105                              <1> 	
  1106 000017C8 E2F9                <1> 	loop .loop
  1107                              <1> 	
  1108                              <1> 	; Calculate the time with the time offset
  1109                              <1> 	
  1110 000017CA A1F9DE              <1> 	mov ax, [57081]
  1111 000017CD A90080              <1> 	test ax, 8000h
  1112 000017D0 7541                <1> 	jnz .subtract
  1113                              <1> 	
  1114 000017D2 31D2                <1> 	xor dx, dx
  1115 000017D4 BB3C00              <1> 	mov bx, 60
  1116 000017D7 F7F3                <1> 	div bx
  1117                              <1> 	
  1118                              <1> 	; DX = value to add to minutes
  1119                              <1> 	; AX = value to add to hours
  1120                              <1> 	
  1121 000017D9 0016[6518]          <1> 	add [.minutes], dl
  1122 000017DD 803E[6518]3C        <1> 	cmp byte [.minutes], 60
  1123 000017E2 7C19                <1> 	jl .add_minutes_ok
  1124                              <1> 	
  1125 000017E4 802E[6518]3C        <1> 	sub byte [.minutes], 60
  1126 000017E9 FE06[6618]          <1> 	inc byte [.hours]
  1127 000017ED 803E[6618]18        <1> 	cmp byte [.hours], 24
  1128 000017F2 7C09                <1> 	jl .add_minutes_ok
  1129                              <1> 	
  1130 000017F4 802E[6618]18        <1> 	sub byte [.hours], 24
  1131 000017F9 FE06[6718]          <1> 	inc byte [.days]
  1132                              <1> 	
  1133                              <1> 	; At this point I don't care
  1134                              <1> 	
  1135                              <1> .add_minutes_ok:
  1136 000017FD 0006[6618]          <1> 	add [.hours], al
  1137 00001801 803E[6618]18        <1> 	cmp byte [.hours], 24
  1138 00001806 7C4C                <1> 	jl .encodeandexit
  1139                              <1> 	
  1140 00001808 802E[6618]18        <1> 	sub byte [.hours], 24
  1141 0000180D FE06[6718]          <1> 	inc byte [.days]
  1142                              <1> 	
  1143 00001811 EB41                <1> 	jmp .encodeandexit
  1144                              <1> 	
  1145                              <1> .subtract:
  1146 00001813 F7D8                <1> 	neg ax
  1147                              <1> 	
  1148 00001815 31D2                <1> 	xor dx, dx
  1149 00001817 BB3C00              <1> 	mov bx, 60
  1150 0000181A F7F3                <1> 	div bx
  1151                              <1> 	
  1152                              <1> 	; DX = value to subtract from minutes
  1153                              <1> 	; AX = value to subtract from hours
  1154                              <1> 
  1155 0000181C 2816[6518]          <1> 	sub [.minutes], dl
  1156 00001820 803E[6518]00        <1> 	cmp byte [.minutes], 0
  1157 00001825 7D19                <1> 	jge .sub_minutes_ok
  1158                              <1> 	
  1159                              <1> 	
  1160 00001827 8006[6518]3C        <1> 	add byte [.minutes], 60
  1161 0000182C FE0E[6618]          <1> 	dec byte [.hours]
  1162 00001830 803E[6618]00        <1> 	cmp byte [.hours], 0
  1163 00001835 7D09                <1> 	jge .sub_minutes_ok
  1164                              <1> 	
  1165 00001837 8006[6618]18        <1> 	add byte [.hours], 24
  1166 0000183C FE0E[6718]          <1> 	dec byte [.days]
  1167                              <1> 	
  1168                              <1> 	; At this point I don't care
  1169                              <1> 	
  1170                              <1> .sub_minutes_ok:
  1171 00001840 2806[6618]          <1> 	sub [.hours], al
  1172 00001844 803E[6618]00        <1> 	cmp byte [.hours], 0
  1173 00001849 7D09                <1> 	jge .encodeandexit
  1174                              <1> 	
  1175 0000184B 8006[6618]18        <1> 	add byte [.hours], 24
  1176 00001850 FE0E[6718]          <1> 	dec byte [.days]
  1177                              <1> 	
  1178                              <1> .encodeandexit:
  1179 00001854 B90700              <1> 	mov cx, 7
  1180 00001857 BE[6418]            <1> 	mov si, .seconds
  1181 0000185A 89F7                <1> 	mov di, si
  1182                              <1> 	
  1183                              <1> .encode_loop:
  1184 0000185C AC                  <1> 	lodsb
  1185 0000185D E87BFC              <1> 	call os_int_to_bcd
  1186 00001860 AA                  <1> 	stosb
  1187 00001861 E2F9                <1> 	loop .encode_loop
  1188                              <1> 
  1189 00001863 C3                  <1> 	ret
  1190                              <1> 	
  1191                              <1> 	
  1192 00001864 00                  <1> 	.seconds	db 0
  1193 00001865 00                  <1> 	.minutes	db 0
  1194 00001866 00                  <1> 	.hours		db 0
  1195 00001867 00                  <1> 	.days		db 0
  1196 00001868 00                  <1> 	.months		db 0
  1197 00001869 00                  <1> 	.years		db 0
  1198 0000186A 00                  <1> 	.centuries	db 0
  1199                              <1> 	
  1200                              <1> ; ==================================================================
  1201                              <1> 
   818                                  	%INCLUDE "features/ports.asm"
   819                              <1> ; ==================================================================
   820                              <1> ; PORT INPUT AND OUTPUT ROUTINES
   821                              <1> ; ==================================================================
   822                              <1> 
   823                              <1> ; ------------------------------------------------------------------
   824                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
   825                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   826                              <1> 
   827                              <1> os_serial_port_enable:
   828 0000186B 60                  <1> 	pusha
   829                              <1> 
   830                              <1> 	clr dx			; Configure serial port 1
    14 0000186C 31D2                <2>  xor %1, %1
   831 0000186E 83F801              <1> 	cmp ax, 1
   832 00001871 7405                <1> 	je .slow_mode
   833                              <1> 
   834 00001873 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
   835 00001876 EB03                <1> 	jmp .finish
   836                              <1> 
   837                              <1> .slow_mode:
   838 00001878 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
   839                              <1> 
   840                              <1> .finish:
   841 0000187B CD14                <1> 	int 14h
   842                              <1> 
   843 0000187D 61                  <1> 	popa
   844 0000187E C3                  <1> 	ret
   845                              <1> 
   846                              <1> 
   847                              <1> ; ------------------------------------------------------------------
   848                              <1> ; os_send_via_serial -- Send a byte via the serial port
   849                              <1> ; IN: AL = byte to send via serial; OUT: AH = Bit 7 clear on success
   850                              <1> 
   851                              <1> os_send_via_serial:
   852 0000187F 60                  <1> 	pusha
   853                              <1> 
   854 00001880 B401                <1> 	mov ah, 01h
   855                              <1> 	clr dx			; COM1
    14 00001882 31D2                <2>  xor %1, %1
   856                              <1> 
   857 00001884 CD14                <1> 	int 14h
   858                              <1> 
   859 00001886 8826[9018]          <1> 	mov [.tmp], ah
   860                              <1> 
   861 0000188A 61                  <1> 	popa
   862                              <1> 
   863 0000188B 8A26[9018]          <1> 	mov ah, [.tmp]
   864                              <1> 
   865 0000188F C3                  <1> 	ret
   866                              <1> 
   867 00001890 00                  <1> 	.tmp db 0
   868                              <1> 
   869                              <1> 
   870                              <1> ; ------------------------------------------------------------------
   871                              <1> ; os_get_via_serial -- Get a byte from the serial port
   872                              <1> ; IN: nothing; OUT: AL = byte that was received, AH = Bit 7 clear on success
   873                              <1> 
   874                              <1> os_get_via_serial:
   875 00001891 60                  <1> 	pusha
   876                              <1> 
   877 00001892 B402                <1> 	mov ah, 02h
   878                              <1> 	clr dx			; COM1
    14 00001894 31D2                <2>  xor %1, %1
   879                              <1> 
   880 00001896 CD14                <1> 	int 14h
   881                              <1> 
   882 00001898 A3[A018]            <1> 	mov [.tmp], ax
   883                              <1> 
   884 0000189B 61                  <1> 	popa
   885                              <1> 
   886 0000189C A1[A018]            <1> 	mov ax, [.tmp]
   887                              <1> 
   888 0000189F C3                  <1> 	ret
   889                              <1> 
   890                              <1> 
   891 000018A0 0000                <1> 	.tmp dw 0
   892                              <1> 
   893                              <1> ; ==================================================================
   894                              <1> 
   819                                  	%INCLUDE "features/screen.asm"
   820                              <1> ; ==================================================================
   821                              <1> ; SCREEN HANDLING SYSTEM CALLS
   822                              <1> ; ==================================================================
   823                              <1> 
   824                              <1> ; ------------------------------------------------------------------
   825                              <1> ; os_putchar -- Puts a character on the screen
   826                              <1> ; IN: AL = character
   827                              <1> ; OUT: Nothing (registers preserved)
   828                              <1> 
   829                              <1> os_putchar:
   830 000018A2 60                  <1> 	pusha
   831 000018A3 B40E                <1> 	mov ah, 0Eh
   832 000018A5 CD10                <1> 	int 10h
   833 000018A7 61                  <1> 	popa
   834 000018A8 C3                  <1> 	ret
   835                              <1> 
   836                              <1> ; ------------------------------------------------------------------
   837                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
   838                              <1> ; IN: BL = terminator, SI = location, CX = character count
   839                              <1> ; OUT: Nothing (registers preserved)
   840                              <1> 
   841                              <1> os_put_chars:
   842 000018A9 60                  <1> 	pusha
   843                              <1> 	
   844                              <1> .loop:
   845 000018AA AC                  <1> 	lodsb
   846 000018AB 38D8                <1> 	cmp al, bl
   847 000018AD 7405                <1> 	je .done
   848                              <1> 	
   849 000018AF E8F0FF              <1> 	call os_putchar
   850                              <1> 	
   851 000018B2 E2F6                <1> 	loop .loop
   852                              <1> 	
   853                              <1> .done:
   854 000018B4 61                  <1> 	popa
   855 000018B5 C3                  <1> 	ret
   856                              <1> 
   857                              <1> ; ------------------------------------------------------------------
   858                              <1> ; os_print_string -- Displays text
   859                              <1> ; IN: SI = message location (zero-terminated string)
   860                              <1> ; OUT: Nothing (registers preserved)
   861                              <1> 
   862                              <1> os_print_string:
   863 000018B6 60                  <1> 	pusha
   864                              <1> 
   865                              <1> .repeat:
   866 000018B7 AC                  <1> 	lodsb				; Get char from string
   867 000018B8 3C00                <1> 	cmp al, 0
   868 000018BA 7405                <1> 	je .done			; If char is zero, end of string
   869                              <1> 
   870 000018BC E8E3FF              <1> 	call os_putchar
   871 000018BF EBF6                <1> 	jmp .repeat			; And move on to next char
   872                              <1> 
   873                              <1> .done:
   874 000018C1 61                  <1> 	popa
   875 000018C2 C3                  <1> 	ret
   876                              <1> 
   877                              <1> ; ------------------------------------------------------------------
   878                              <1> ; os_print_string_box -- Displays text inside a text-box.
   879                              <1> ; IN: SI = message location (zero-terminated string), DL = left alignment
   880                              <1> ; OUT: Nothing (registers preserved)
   881                              <1> 
   882                              <1> os_print_string_box:
   883 000018C3 60                  <1> 	pusha
   884 000018C4 88D1                <1> 	mov cl, dl
   885                              <1> 
   886                              <1> .repeat:
   887 000018C6 AC                  <1> 	lodsb				; Get char from string
   888 000018C7 3C00                <1> 	cmp al, 0
   889 000018C9 7409                <1> 	je .done			; If char is zero, end of string
   890                              <1> 
   891 000018CB 3C0D                <1> 	cmp al, 13
   892 000018CD 7407                <1> 	je .cr
   893                              <1> 	
   894 000018CF E8D0FF              <1> 	call os_putchar
   895 000018D2 EBF2                <1> 	jmp .repeat			; And move on to next char
   896                              <1> 
   897                              <1> .done:
   898 000018D4 61                  <1> 	popa
   899 000018D5 C3                  <1> 	ret
   900                              <1> 	
   901                              <1> .cr:
   902 000018D6 E85700              <1> 	call os_get_cursor_pos
   903 000018D9 88CA                <1> 	mov dl, cl
   904 000018DB E84900              <1> 	call os_move_cursor
   905 000018DE EBE6                <1> 	jmp .repeat
   906                              <1> 
   907                              <1> ; ------------------------------------------------------------------
   908                              <1> ; os_format_string -- Displays colored text
   909                              <1> ; IN: BL/SI = text color/message location (zero-terminated string)
   910                              <1> ; OUT: Nothing (registers preserved)
   911                              <1> 
   912                              <1> os_format_string:
   913 000018E0 60                  <1> 	pusha
   914                              <1> 
   915 000018E1 B409                <1> 	mov ah, 09h			; int 09h
   916 000018E3 B700                <1> 	mov bh, 0
   917 000018E5 B90100              <1> 	mov cx, 1
   918 000018E8 E84500              <1> 	call os_get_cursor_pos
   919                              <1> 	
   920                              <1> .repeat:
   921 000018EB AC                  <1> 	lodsb				; Get char from string
   922 000018EC 3C0D                <1> 	cmp al, 13
   923 000018EE 7411                <1> 	je .cr
   924 000018F0 3C0A                <1> 	cmp al, 10
   925 000018F2 7414                <1> 	je .lf
   926 000018F4 3C00                <1> 	cmp al, 0
   927 000018F6 7417                <1> 	je .done			; If char is zero, end of string
   928                              <1> 
   929 000018F8 CD10                <1> 	int 10h				; Otherwise, print it
   930                              <1> 
   931 000018FA FEC2                <1> 	inc dl
   932 000018FC E82800              <1> 	call os_move_cursor
   933                              <1> 	
   934 000018FF EBEA                <1> 	jmp .repeat			; And move on to next char
   935                              <1> 	
   936                              <1> .cr:
   937 00001901 B200                <1> 	mov dl, 0
   938 00001903 E82100              <1> 	call os_move_cursor
   939 00001906 EBE3                <1> 	jmp .repeat
   940                              <1> 
   941                              <1> .lf:
   942 00001908 FEC6                <1> 	inc dh
   943 0000190A E81A00              <1> 	call os_move_cursor
   944 0000190D EBDC                <1> 	jmp .repeat
   945                              <1> 	
   946                              <1> .done:
   947 0000190F 61                  <1> 	popa
   948 00001910 C3                  <1> 	ret
   949                              <1> 
   950                              <1> 
   951                              <1> ; ------------------------------------------------------------------
   952                              <1> ; os_clear_screen -- Clears the screen to background
   953                              <1> ; IN/OUT: Nothing (registers preserved)
   954                              <1> 
   955                              <1> os_clear_screen:
   956 00001911 60                  <1> 	pusha
   957                              <1> 
   958 00001912 BA0000              <1> 	mov dx, 0			; Position cursor at top-left
   959 00001915 E80F00              <1> 	call os_move_cursor
   960                              <1> 
   961                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    18 00001918 B80006              <2>  mov %1, (%2 + %3 * 256)
   962 0000191B B707                <1> 	mov bh, 7
   963                              <1> 	mov16 cx, 0, 0		; Top-left
    18 0000191D B90000              <2>  mov %1, (%2 + %3 * 256)
   964                              <1> 	mov16 dx, 79, 24	; Bottom-right
    18 00001920 BA4F18              <2>  mov %1, (%2 + %3 * 256)
   965 00001923 CD10                <1> 	int 10h
   966                              <1> 
   967 00001925 61                  <1> 	popa
   968 00001926 C3                  <1> 	ret
   969                              <1> 
   970                              <1> 
   971                              <1> ; ------------------------------------------------------------------
   972                              <1> ; os_move_cursor -- Moves cursor in text mode
   973                              <1> ; IN: DH, DL = row, column; OUT: Nothing (registers preserved)
   974                              <1> 
   975                              <1> os_move_cursor:
   976 00001927 60                  <1> 	pusha
   977                              <1> 
   978 00001928 B700                <1> 	mov bh, 0
   979 0000192A B402                <1> 	mov ah, 2
   980 0000192C CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   981                              <1> 
   982 0000192E 61                  <1> 	popa
   983 0000192F C3                  <1> 	ret
   984                              <1> 
   985                              <1> 
   986                              <1> ; ------------------------------------------------------------------
   987                              <1> ; os_get_cursor_pos -- Return position of text cursor
   988                              <1> ; OUT: DH, DL = row, column
   989                              <1> 
   990                              <1> os_get_cursor_pos:
   991 00001930 60                  <1> 	pusha
   992                              <1> 
   993 00001931 B700                <1> 	mov bh, 0
   994 00001933 B403                <1> 	mov ah, 3
   995 00001935 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   996                              <1> 
   997 00001937 8916[4119]          <1> 	mov [.tmp], dx
   998 0000193B 61                  <1> 	popa
   999 0000193C 8B16[4119]          <1> 	mov dx, [.tmp]
  1000 00001940 C3                  <1> 	ret
  1001                              <1> 
  1002                              <1> 
  1003 00001941 0000                <1> 	.tmp dw 0
  1004                              <1> 
  1005                              <1> 
  1006                              <1> ; ------------------------------------------------------------------
  1007                              <1> ; os_print_horiz_line -- Draw a horizontal line on the screen
  1008                              <1> ; IN: AX = line type (1 for double (-), otherwise single (=))
  1009                              <1> ; OUT: Nothing (registers preserved)
  1010                              <1> 
  1011                              <1> os_print_horiz_line:
  1012 00001943 60                  <1> 	pusha
  1013                              <1> 
  1014 00001944 89C1                <1> 	mov cx, ax			; Store line type param
  1015 00001946 B0C4                <1> 	mov al, 196			; Default is single-line code
  1016                              <1> 
  1017 00001948 83F901              <1> 	cmp cx, 1			; Was double-line specified in AX?
  1018 0000194B 7502                <1> 	jne .ready
  1019 0000194D B0CD                <1> 	mov al, 205			; If so, here's the code
  1020                              <1> 
  1021                              <1> .ready:
  1022 0000194F B95000              <1> 	mov cx, 80			; Counter
  1023 00001952 B40E                <1> 	mov ah, 0Eh			; BIOS output char routine
  1024 00001954 B700                <1> 	mov bh, 0
  1025                              <1> 	
  1026                              <1> .loop:
  1027 00001956 CD10                <1> 	int 10h
  1028 00001958 E2FC                <1> 	loop .loop
  1029                              <1> 	
  1030 0000195A 61                  <1> 	popa
  1031 0000195B C3                  <1> 	ret
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; os_show_cursor -- Turns on cursor in text mode
  1036                              <1> ; IN/OUT: Nothing
  1037                              <1> 
  1038                              <1> os_show_cursor:
  1039 0000195C 60                  <1> 	pusha
  1040                              <1> 
  1041                              <1> 	mov16 cx, 7, 6
    18 0000195D B90706              <2>  mov %1, (%2 + %3 * 256)
  1042                              <1> 	mov16 ax, 3, 1
    18 00001960 B80301              <2>  mov %1, (%2 + %3 * 256)
  1043 00001963 CD10                <1> 	int 10h
  1044                              <1> 
  1045 00001965 61                  <1> 	popa
  1046 00001966 C3                  <1> 	ret
  1047                              <1> 
  1048                              <1> 
  1049                              <1> ; ------------------------------------------------------------------
  1050                              <1> ; os_hide_cursor -- Turns off cursor in text mode
  1051                              <1> ; IN/OUT: Nothing
  1052                              <1> 
  1053                              <1> os_hide_cursor:
  1054 00001967 60                  <1> 	pusha
  1055                              <1> 
  1056 00001968 B520                <1> 	mov ch, 32
  1057                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    18 0000196A B80301              <2>  mov %1, (%2 + %3 * 256)
  1058 0000196D CD10                <1> 	int 10h
  1059                              <1> 
  1060 0000196F 61                  <1> 	popa
  1061 00001970 C3                  <1> 	ret
  1062                              <1> 
  1063                              <1> 
  1064                              <1> ; ------------------------------------------------------------------
  1065                              <1> ; os_draw_block -- Render block of specified colour
  1066                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
  1067                              <1> 
  1068                              <1> os_draw_block:
  1069 00001971 60                  <1> 	pusha
  1070                              <1> 
  1071                              <1> .more:
  1072 00001972 E8B2FF              <1> 	call os_move_cursor		; Move to block starting position
  1073                              <1> 
  1074                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    18 00001975 B82009              <2>  mov %1, (%2 + %3 * 256)
  1075 00001978 B700                <1> 	mov bh, 0
  1076 0000197A 89F1                <1> 	mov cx, si
  1077 0000197C CD10                <1> 	int 10h
  1078                              <1> 
  1079 0000197E FEC6                <1> 	inc dh				; Get ready for next line
  1080                              <1> 
  1081 00001980 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
  1082 00001983 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
  1083 00001985 75EB                <1> 	jne .more			; If not, keep drawing
  1084                              <1> 
  1085 00001987 61                  <1> 	popa
  1086 00001988 C3                  <1> 	ret
  1087                              <1> 
  1088                              <1> 
  1089                              <1> ; ------------------------------------------------------------------
  1090                              <1> ; os_file_selector -- Show a file selection dialog
  1091                              <1> ; IN: If [0087h] = 1, then BX = location of file extension list
  1092                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
  1093                              <1> 
  1094                              <1> os_file_selector:
  1095                              <1> 	; Get volume name
  1096                              <1> 	
  1097 00001989 60                  <1> 	pusha
  1098 0000198A B90100              <1> 	mov cx, 1					; Load first disk sector into RAM
  1099 0000198D 0FB6168400          <1> 	movzx dx, byte [0084h]
  1100 00001992 BB00E0              <1> 	mov bx, disk_buffer
  1101                              <1> 
  1102                              <1> 	mov16 ax, 1, 2
    18 00001995 B80102              <2>  mov %1, (%2 + %3 * 256)
  1103 00001998 F9                  <1> 	stc
  1104 00001999 CD13                <1> 	int 13h						; BIOS load sector call
  1105                              <1> 
  1106 0000199B BE2BE0              <1> 	mov si, disk_buffer + 2Bh	; Disk label starts here
  1107                              <1> 
  1108 0000199E BF[241C]            <1> 	mov di, .volname
  1109 000019A1 B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
  1110 000019A4 F3A4                <1> 	rep movsb
  1111 000019A6 61                  <1> 	popa
  1112                              <1> 	
  1113 000019A7 60                  <1> 	pusha
  1114 000019A8 C706[091C]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
  1115                              <1> 
  1116 000019AE E8F5F0              <1> 	call os_report_free_space
  1117 000019B1 D1E8                <1> 	shr ax, 1					; Sectors -> kB
  1118 000019B3 A3[301C]            <1> 	mov [.freespace], ax
  1119                              <1> 	
  1120                              <1> 	; Add the filters, if desired
  1121                              <1> 
  1122 000019B6 BF5100              <1> 	mov di, 0051h
  1123 000019B9 C60500              <1> 	mov byte [di], 0
  1124                              <1> 	
  1125 000019BC 803E870001          <1> 	cmp byte [0087h], 1
  1126 000019C1 752F                <1> 	jne .no_filter
  1127                              <1> 	
  1128 000019C3 891E[321C]          <1> 	mov [.extension_list], bx
  1129                              <1> 
  1130 000019C7 BE[D31B]            <1> 	mov si, .filter_msg
  1131 000019CA BF5100              <1> 	mov di, 0051h
  1132 000019CD E85F11              <1> 	call os_string_copy
  1133                              <1> 
  1134 000019D0 60                  <1> 	pusha
  1135 000019D1 BF5A00              <1> 	mov di, 0051h + 9
  1136 000019D4 89DE                <1> 	mov si, bx
  1137 000019D6 8A1C                <1> 	mov bl, [si]
  1138 000019D8 46                  <1> 	inc si
  1139 000019D9 B100                <1> 	mov cl, 0
  1140                              <1> 	
  1141                              <1> .filter_loop:
  1142 000019DB E85111              <1> 	call os_string_copy
  1143 000019DE C6450320            <1> 	mov byte [di + 3], ' '
  1144 000019E2 83C704              <1> 	add di, 4
  1145 000019E5 83C604              <1> 	add si, 4
  1146 000019E8 FEC1                <1> 	inc cl
  1147 000019EA 38D9                <1> 	cmp cl, bl
  1148 000019EC 75ED                <1> 	jne .filter_loop
  1149                              <1> 	
  1150 000019EE C60500              <1> 	mov byte [di], 0
  1151 000019F1 61                  <1> 	popa
  1152                              <1> 	
  1153                              <1> .no_filter:
  1154                              <1> 	; Create the filename index list
  1155                              <1> 
  1156 000019F2 E8B9F8              <1> 	call disk_read_root_dir		; Get the files into the buffer
  1157                              <1> 
  1158 000019F5 BE00E0              <1> 	mov si, disk_buffer			; Raw directory buffer
  1159 000019F8 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
  1160 000019FB B90000              <1> 	mov cx, 0					; Number of found files
  1161                              <1> 
  1162                              <1> .index_loop:
  1163 000019FE 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
  1164 00001A02 744E                <1> 	je .done
  1165                              <1> 
  1166 00001A04 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
  1167 00001A07 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
  1168 00001A09 7442                <1> 	je .skip
  1169                              <1> 
  1170 00001A0B A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
  1171 00001A0D 753E                <1> 	jnz .skip			; Yes, ignore it
  1172                              <1> 
  1173 00001A0F 8A04                <1> 	mov al, [si]
  1174 00001A11 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
  1175 00001A13 7438                <1> 	je .skip
  1176                              <1> 
  1177 00001A15 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
  1178 00001A17 7439                <1> 	je .done
  1179                              <1> 
  1180 00001A19 60                  <1> 	pusha
  1181                              <1> 
  1182 00001A1A 803E870001          <1> 	cmp byte [0087h], 1	; Check if we are supposed to filter the filenames
  1183 00001A1F 7523                <1> 	jne .no_extension_check
  1184                              <1> 	
  1185 00001A21 8B1E[321C]          <1> 	mov bx, [.extension_list]
  1186 00001A25 0FB60F              <1> 	movzx cx, byte [bx]
  1187                              <1> 
  1188                              <1> .extension_loop:
  1189 00001A28 60                  <1> 	pusha
  1190 00001A29 83C608              <1> 	add si, 8
  1191                              <1> 	
  1192 00001A2C 49                  <1> 	dec cx
  1193 00001A2D 89CF                <1> 	mov di, cx
  1194 00001A2F C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1195 00001A32 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1196 00001A33 033E[321C]          <1> 	add di, [.extension_list]
  1197                              <1> 	
  1198 00001A37 B90300              <1> 	mov cx, 3
  1199 00001A3A F3A6                <1> 	rep cmpsb
  1200 00001A3C 61                  <1> 	popa
  1201 00001A3D 7405                <1> 	je .no_extension_check
  1202                              <1> 	
  1203 00001A3F E2E7                <1> 	loop .extension_loop
  1204                              <1> 	
  1205 00001A41 61                  <1> 	popa
  1206 00001A42 EB09                <1> 	jmp .skip
  1207                              <1> 
  1208                              <1> .no_extension_check:
  1209 00001A44 61                  <1> 	popa
  1210                              <1> 
  1211 00001A45 41                  <1> 	inc cx				; Increment the number of discovered files
  1212 00001A46 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
  1213 00001A48 AB                  <1> 	stosw
  1214                              <1> 
  1215 00001A49 C6440B00            <1> 	mov byte [si+11], 0	; Zero-terminate the string
  1216                              <1> 
  1217                              <1> .skip:
  1218 00001A4D 83C620              <1> 	add si, byte 32		; Skip to the next file
  1219 00001A50 EBAC                <1> 	jmp .index_loop
  1220                              <1> 
  1221                              <1> .done:
  1222                              <1> 	; Let the user select a file
  1223                              <1> 
  1224 00001A52 89C8                <1> 	mov ax, cx			; Pass the number of files
  1225 00001A54 BB[F51B]            <1> 	mov bx, .root
  1226 00001A57 B95100              <1> 	mov cx, 0051h
  1227 00001A5A BE[A61A]            <1> 	mov si, .callback
  1228                              <1> 
  1229 00001A5D C606[341C]01        <1> 	mov byte [.file_selector_calling], 1
  1230 00001A62 E8D301              <1> 	call os_list_dialog_tooltip
  1231 00001A65 C606[341C]00        <1> 	mov byte [.file_selector_calling], 0
  1232                              <1> 
  1233 00001A6A 7209                <1> 	jc .esc_pressed
  1234                              <1> 
  1235 00001A6C E80900              <1> 	call .get_filename
  1236                              <1> 	
  1237 00001A6F 61                  <1> 	popa
  1238 00001A70 B8[091C]            <1> 	mov ax, .filename
  1239 00001A73 F8                  <1> 	clc
  1240 00001A74 C3                  <1> 	ret
  1241                              <1> 
  1242                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
  1243 00001A75 61                  <1> 	popa
  1244 00001A76 F9                  <1> 	stc
  1245 00001A77 C3                  <1> 	ret
  1246                              <1> 
  1247                              <1> .get_filename:
  1248 00001A78 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
  1249                              <1> 						; for our file list offset we want to start from 0
  1250                              <1> 	
  1251 00001A79 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
  1252 00001A7B D1E6                <1> 	shl si, 1
  1253 00001A7D 81C600FC            <1> 	add si, 64512
  1254                              <1> 
  1255 00001A81 AD                  <1> 	lodsw
  1256 00001A82 89C6                <1> 	mov si, ax			; Our resulting pointer
  1257                              <1> 	clr cx
    14 00001A84 31C9                <2>  xor %1, %1
  1258 00001A86 BF[091C]            <1> 	mov di, .filename
  1259                              <1> 	
  1260                              <1> .loopy:
  1261 00001A89 AC                  <1> 	lodsb
  1262 00001A8A 3C20                <1> 	cmp al, ' '
  1263 00001A8C 7401                <1> 	je .ignore_space
  1264 00001A8E AA                  <1> 	stosb
  1265                              <1> 	
  1266                              <1> .ignore_space:
  1267 00001A8F 41                  <1> 	inc cx
  1268 00001A90 83F908              <1> 	cmp cx, 8
  1269 00001A93 7407                <1> 	je .add_dot
  1270 00001A95 83F90B              <1> 	cmp cx, 11
  1271 00001A98 7408                <1> 	je .done_copy
  1272 00001A9A EBED                <1> 	jmp .loopy
  1273                              <1> 
  1274                              <1> .add_dot:
  1275 00001A9C C6052E              <1> 	mov byte [di], '.'
  1276 00001A9F 47                  <1> 	inc di
  1277 00001AA0 EBE7                <1> 	jmp .loopy
  1278                              <1> 
  1279                              <1> .done_copy:
  1280 00001AA2 C60500              <1> 	mov byte [di], 0
  1281                              <1> 
  1282 00001AA5 C3                  <1> 	ret
  1283                              <1> 	
  1284                              <1> .callback:
  1285                              <1> 	; Draw the box on the right
  1286 00001AA6 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1287                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    18 00001AAA BA2902              <2>  mov %1, (%2 + %3 * 256)
  1288 00001AAD BE2500              <1> 	mov si, 37			; Width
  1289 00001AB0 BF1700              <1> 	mov di, 23			; Finish Y position
  1290 00001AB3 E8BBFE              <1> 	call os_draw_block	; Draw option selector window
  1291                              <1> 
  1292                              <1> 	; Draw the icon's background
  1293 00001AB6 B3F0                <1> 	mov bl, 0F0h
  1294                              <1> 	mov16 dx, 50, 3
    18 00001AB8 BA3203              <2>  mov %1, (%2 + %3 * 256)
  1295 00001ABB BE1300              <1> 	mov si, 19			; Width
  1296 00001ABE BF0D00              <1> 	mov di, 13			; Finish Y position
  1297 00001AC1 E8ADFE              <1> 	call os_draw_block	; Draw option selector window	
  1298                              <1> 
  1299                              <1> 	; Draw the icon
  1300                              <1> 	
  1301                              <1> 	mov16 dx, 52, 4
    18 00001AC4 BA3404              <2>  mov %1, (%2 + %3 * 256)
  1302 00001AC7 E85DFE              <1> 	call os_move_cursor
  1303                              <1> 	
  1304 00001ACA BE[040A]            <1> 	mov si, filelogo
  1305 00001ACD E82B0A              <1> 	call os_draw_icon
  1306                              <1> 
  1307                              <1> 	; Display the filename
  1308                              <1> 
  1309                              <1> 	mov16 dx, 42, 14
    18 00001AD0 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1310 00001AD3 E851FE              <1> 	call os_move_cursor
  1311                              <1> 
  1312 00001AD6 50                  <1> 	push ax
  1313 00001AD7 E89EFF              <1> 	call .get_filename
  1314                              <1> 	
  1315 00001ADA BE[091C]            <1> 	mov si, .filename
  1316 00001ADD E8D6FD              <1> 	call os_print_string
  1317                              <1> 	
  1318                              <1> 	; Find the correct directory entry for this file
  1319                              <1> 
  1320 00001AE0 58                  <1> 	pop ax
  1321                              <1> 
  1322 00001AE1 48                  <1> 	dec ax
  1323 00001AE2 89C6                <1> 	mov si, ax
  1324 00001AE4 D1E6                <1> 	shl si, 1
  1325 00001AE6 81C600FC            <1> 	add si, 64512
  1326 00001AEA 8B34                <1> 	mov si, [si]			; Get the pointer to the entry in the index list
  1327                              <1> 
  1328 00001AEC 56                  <1> 	push si
  1329                              <1> 	
  1330                              <1> 	; Display the file size
  1331                              <1> 	
  1332 00001AED 668B441C            <1> 	mov eax, [si + 28]
  1333 00001AF1 E84512              <1> 	call os_32int_to_string
  1334                              <1> 	
  1335 00001AF4 89C6                <1> 	mov si, ax
  1336 00001AF6 BF[091C]            <1> 	mov di, .filename
  1337 00001AF9 E83310              <1> 	call os_string_copy
  1338                              <1> 	
  1339 00001AFC B8[091C]            <1> 	mov ax, .filename
  1340 00001AFF BB[DD1B]            <1> 	mov bx, .byte_msg
  1341 00001B02 E8880F              <1> 	call os_string_add
  1342                              <1> 	
  1343 00001B05 E8940F              <1> 	call os_string_length
  1344                              <1> 
  1345 00001B08 B24D                <1> 	mov dl, 77
  1346 00001B0A 28C2                <1> 	sub dl, al
  1347 00001B0C E818FE              <1> 	call os_move_cursor
  1348                              <1> 	
  1349 00001B0F BE[091C]            <1> 	mov si, .filename
  1350 00001B12 E8A1FD              <1> 	call os_print_string
  1351                              <1> 	
  1352                              <1> 	; Display the file write date/time
  1353                              <1> 	
  1354 00001B15 C606[091C]00        <1> 	mov byte [.filename], 0
  1355                              <1> 	
  1356 00001B1A 5E                  <1> 	pop si
  1357 00001B1B 8B5C0E              <1> 	mov bx, [si + 14]
  1358 00001B1E 8B4C10              <1> 	mov cx, [si + 16]
  1359                              <1> 	
  1360 00001B21 53                  <1> 	push bx
  1361 00001B22 89C8                <1> 	mov ax, cx		; Days
  1362 00001B24 83E01F              <1> 	and ax, 11111b
  1363                              <1> 	
  1364 00001B27 BA[EF1B]            <1> 	mov dx, .dateseparator
  1365 00001B2A E88400              <1> 	call .cb_add_num
  1366                              <1> 	
  1367 00001B2D 89C8                <1> 	mov ax, cx		; Months
  1368 00001B2F C1E805              <1> 	shr ax, 5
  1369 00001B32 83E00F              <1> 	and ax, 1111b
  1370                              <1> 	
  1371 00001B35 E87900              <1> 	call .cb_add_num
  1372                              <1> 	
  1373 00001B38 89C8                <1> 	mov ax, cx		; Years
  1374 00001B3A C1E809              <1> 	shr ax, 9
  1375 00001B3D 05BC07              <1> 	add ax, 1980
  1376                              <1> 	
  1377 00001B40 BA[F11B]            <1> 	mov dx, .whiteseparator
  1378 00001B43 E86B00              <1> 	call .cb_add_num
  1379                              <1> 	
  1380 00001B46 59                  <1> 	pop cx
  1381                              <1> 	
  1382 00001B47 89C8                <1> 	mov ax, cx		; Hours
  1383 00001B49 C1E80B              <1> 	shr ax, 11
  1384                              <1> 
  1385 00001B4C BA[ED1B]            <1> 	mov dx, .timeseparator
  1386 00001B4F E85F00              <1> 	call .cb_add_num
  1387                              <1> 	
  1388 00001B52 89C8                <1> 	mov ax, cx		; Minutes
  1389 00001B54 C1E805              <1> 	shr ax, 5
  1390 00001B57 83E03F              <1> 	and ax, 111111b
  1391                              <1> 	
  1392 00001B5A E85400              <1> 	call .cb_add_num
  1393                              <1> 
  1394 00001B5D 89C8                <1> 	mov ax, cx		; Seconds
  1395 00001B5F 83E01F              <1> 	and ax, 11111b
  1396 00001B62 D1E0                <1> 	shl ax, 1
  1397                              <1> 
  1398 00001B64 BA[D21B]            <1> 	mov dx, .help_msg2
  1399 00001B67 E84700              <1> 	call .cb_add_num
  1400                              <1> 	
  1401                              <1> 	mov16 dx, 42, 16
    18 00001B6A BA2A10              <2>  mov %1, (%2 + %3 * 256)
  1402 00001B6D E8B7FD              <1> 	call os_move_cursor
  1403                              <1> 
  1404 00001B70 BE[F91B]            <1> 	mov si, .time_msg
  1405 00001B73 E840FD              <1> 	call os_print_string
  1406                              <1> 	
  1407                              <1> 	; Display volume information
  1408                              <1> 	
  1409                              <1> 	mov16 dx, 42, 20
    18 00001B76 BA2A14              <2>  mov %1, (%2 + %3 * 256)
  1410 00001B79 E8ABFD              <1> 	call os_move_cursor
  1411                              <1> 
  1412 00001B7C B8C409              <1> 	mov ax, 09C4h
  1413 00001B7F 0FB61EA9DE          <1> 	movzx bx, byte [57001]
  1414 00001B84 B92300              <1> 	mov cx, 35
  1415 00001B87 CD10                <1> 	int 10h
  1416                              <1> 	
  1417 00001B89 FEC6                <1> 	inc dh
  1418 00001B8B E899FD              <1> 	call os_move_cursor
  1419                              <1> 
  1420 00001B8E BE[1D1C]            <1> 	mov si, .vol_msg
  1421 00001B91 E822FD              <1> 	call os_print_string
  1422                              <1> 	
  1423 00001B94 A1[301C]            <1> 	mov ax, [.freespace]
  1424 00001B97 E89310              <1> 	call os_int_to_string
  1425 00001B9A 89C6                <1> 	mov si, ax
  1426 00001B9C E8FD0E              <1> 	call os_string_length
  1427                              <1> 	
  1428 00001B9F 80C21B              <1> 	add dl, 27
  1429 00001BA2 28C2                <1> 	sub dl, al
  1430 00001BA4 E880FD              <1> 	call os_move_cursor
  1431                              <1> 		
  1432 00001BA7 E80CFD              <1> 	call os_print_string
  1433                              <1> 		
  1434 00001BAA BE[E41B]            <1> 	mov si, .free_msg
  1435 00001BAD E806FD              <1> 	call os_print_string
  1436 00001BB0 C3                  <1> 	ret
  1437                              <1> 	
  1438                              <1> .cb_add_num:
  1439 00001BB1 83F80A              <1> 	cmp ax, 10
  1440 00001BB4 7D0B                <1> 	jge .no_zero
  1441                              <1> 	
  1442 00001BB6 50                  <1> 	push ax
  1443 00001BB7 BB[F31B]            <1> 	mov bx, .zerofill
  1444 00001BBA B8[091C]            <1> 	mov ax, .filename
  1445 00001BBD E8CD0E              <1> 	call os_string_add
  1446 00001BC0 58                  <1> 	pop ax
  1447                              <1> 	
  1448                              <1> .no_zero:
  1449 00001BC1 E86910              <1> 	call os_int_to_string
  1450 00001BC4 89C3                <1> 	mov bx, ax
  1451 00001BC6 B8[091C]            <1> 	mov ax, .filename
  1452 00001BC9 E8C10E              <1> 	call os_string_add
  1453                              <1> 	
  1454 00001BCC 89D3                <1> 	mov bx, dx
  1455 00001BCE E8BC0E              <1> 	call os_string_add
  1456                              <1> 
  1457 00001BD1 C3                  <1> 	ret
  1458                              <1> 	
  1459 00001BD2 00                  <1> 	.help_msg2		db 0
  1460 00001BD3 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
  1460 00001BDC 00                  <1>
  1461 00001BDD 20627974657300      <1> 	.byte_msg		db ' bytes', 0
  1462 00001BE4 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
  1463 00001BED 3A00                <1> 	.timeseparator	db ':', 0
  1464 00001BEF 2F00                <1> 	.dateseparator	db '/', 0
  1465 00001BF1 2000                <1> 	.whiteseparator	db ' ', 0
  1466 00001BF3 3000                <1> 	.zerofill		db '0', 0
  1467 00001BF5 413A2F00            <1> 	.root			db 'A:/', 0
  1468                              <1> 
  1469 00001BF9 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  '
  1469 00001C02 6F206F6E3A2020      <1>
  1470 00001C09 00<rep 14h>         <1> 	.filename		times 20 db 0
  1471                              <1> 	
  1472 00001C1D 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
  1473 00001C24 00<rep Ch>          <1> 	.volname		times 12 db 0
  1474 00001C30 0000                <1> 	.freespace		dw 0
  1475 00001C32 0000                <1> 	.extension_list	dw 0
  1476                              <1> 
  1477 00001C34 00                  <1> 	.file_selector_calling			db 0
  1478 00001C35 00                  <1> 	.file_selector_cursorpos		db 0
  1479 00001C36 00                  <1> 	.file_selector_skipnum			db 0
  1480 00001C37 00                  <1> 	.file_selector_numofentries		db 0
  1481                              <1> 
  1482                              <1> 
  1483                              <1> ; ------------------------------------------------------------------
  1484                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
  1485                              <1> ; That means, when the user changes the selection, the application will be called back
  1486                              <1> ; to change the tooltip's contents.
  1487                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1488                              <1> ;     BX = first help string, CX = second help string
  1489                              <1> ;     SI = callback pointer
  1490                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1491                              <1> 
  1492                              <1> os_list_dialog_tooltip:
  1493 00001C38 C70689002500        <1> 	mov word [0089h], 37
  1494                              <1> 	
  1495 00001C3E 8936[731C]          <1> 	mov [.callbackaddr], si
  1496                              <1> 	
  1497 00001C42 C706[451F][581C]    <1> 	mov word [os_list_dialog.callback], .callback
  1498 00001C48 E82A00              <1> 	call os_list_dialog
  1499 00001C4B C706[451F]0000      <1> 	mov word [os_list_dialog.callback], 0
  1500 00001C51 C70689004C00        <1> 	mov word [0089h], 76
  1501 00001C57 C3                  <1> 	ret
  1502                              <1> 	
  1503                              <1> .callback:
  1504                              <1> 	; Draw the box on the right
  1505 00001C58 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1506                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    18 00001C5C BA2902              <2>  mov %1, (%2 + %3 * 256)
  1507 00001C5F BE2500              <1> 	mov si, 37			; Width
  1508 00001C62 BF1700              <1> 	mov di, 23			; Finish Y position
  1509 00001C65 E809FD              <1> 	call os_draw_block	; Draw option selector window	
  1510                              <1> 
  1511                              <1> 	mov16 dx, 42, 3
    18 00001C68 BA2A03              <2>  mov %1, (%2 + %3 * 256)
  1512 00001C6B E8B9FC              <1> 	call os_move_cursor
  1513                              <1> 
  1514 00001C6E FF16[731C]          <1> 	call [.callbackaddr]
  1515 00001C72 C3                  <1> 	ret
  1516                              <1> 	
  1517 00001C73 0000                <1> 	.callbackaddr	dw 0
  1518                              <1> 	
  1519                              <1> ; ------------------------------------------------------------------
  1520                              <1> ; os_list_dialog -- Show a dialog with a list of options
  1521                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1522                              <1> ;     BX = first help string, CX = second help string
  1523                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1524                              <1> 
  1525                              <1> os_list_dialog:
  1526 00001C75 60                  <1> 	pusha
  1527                              <1> 
  1528 00001C76 50                  <1> 	push ax				; Store string list for now
  1529                              <1> 
  1530 00001C77 51                  <1> 	push cx				; And help strings
  1531 00001C78 53                  <1> 	push bx
  1532                              <1> 
  1533 00001C79 E8EBFC              <1> 	call os_hide_cursor
  1534                              <1> 
  1535                              <1> 	; Are we calling from the file selector?
  1536                              <1> 
  1537 00001C7C 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1538 00001C81 7509                <1> 	jne .normal_count
  1539                              <1> 
  1540 00001C83 83F800              <1> 	cmp ax, 0
  1541 00001C86 740B                <1> 	je .empty_list
  1542                              <1> 
  1543 00001C88 89C1                <1> 	mov cx, ax
  1544                              <1> 
  1545 00001C8A EB4B                <1> 	jmp .done_count_f
  1546                              <1> 
  1547                              <1> .normal_count:
  1548 00001C8C 89C6                <1> 	mov si, ax
  1549 00001C8E 803C00              <1> 	cmp byte [si], 0
  1550 00001C91 7530                <1> 	jne .count_entries
  1551                              <1> 
  1552                              <1> .empty_list:
  1553 00001C93 83C406              <1> 	add sp, 6
  1554 00001C96 61                  <1> 	popa
  1555                              <1> 
  1556 00001C97 B8[A51C]            <1> 	mov ax, .nofilesmsg
  1557                              <1> 	clr bx
    14 00001C9A 31DB                <2>  xor %1, %1
  1558                              <1> 	clr cx
    14 00001C9C 31C9                <2>  xor %1, %1
  1559                              <1> 	clr dx
    14 00001C9E 31D2                <2>  xor %1, %1
  1560 00001CA0 E86B04              <1> 	call os_dialog_box
  1561                              <1> 
  1562 00001CA3 F9                  <1> 	stc
  1563 00001CA4 C3                  <1> 	ret
  1564                              <1> 
  1565 00001CA5 546865726520617265- <1> 	.nofilesmsg	db "There are no items to select.", 0
  1565 00001CAE 206E6F206974656D73- <1>
  1565 00001CB7 20746F2073656C6563- <1>
  1565 00001CC0 742E00              <1>
  1566                              <1> 	
  1567                              <1> .count_entries:	
  1568 00001CC3 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1569                              <1> 	
  1570                              <1> .count_loop:
  1571 00001CC5 268A04              <1> 	mov al, [es:si]
  1572 00001CC8 46                  <1> 	inc si
  1573 00001CC9 3C00                <1> 	cmp al, 0
  1574 00001CCB 7408                <1> 	je .done_count
  1575 00001CCD 3C2C                <1> 	cmp al, ','
  1576 00001CCF 75F4                <1> 	jne .count_loop
  1577 00001CD1 FEC1                <1> 	inc cl
  1578 00001CD3 EBF0                <1> 	jmp .count_loop
  1579                              <1> 
  1580                              <1> .done_count:
  1581 00001CD5 FEC1                <1> 	inc cl
  1582                              <1> 
  1583                              <1> .done_count_f:
  1584 00001CD7 880E[391F]          <1> 	mov byte [.num_of_entries], cl
  1585                              <1> 
  1586                              <1> 
  1587 00001CDB 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1588                              <1> 	mov16 dx, 2, 2		; Start X/Y position
    18 00001CDF BA0202              <2>  mov %1, (%2 + %3 * 256)
  1589 00001CE2 8B368900            <1> 	mov si, [0089h]		; Width
  1590 00001CE6 BF1700              <1> 	mov di, 23			; Finish Y position
  1591 00001CE9 E885FC              <1> 	call os_draw_block	; Draw option selector window
  1592                              <1> 
  1593                              <1> 	mov16 dx, 3, 3		; Show first line of help text...
    18 00001CEC BA0303              <2>  mov %1, (%2 + %3 * 256)
  1594 00001CEF E835FC              <1> 	call os_move_cursor
  1595                              <1> 
  1596 00001CF2 5E                  <1> 	pop si				; Get back first string
  1597 00001CF3 E8C0FB              <1> 	call os_print_string
  1598                              <1> 
  1599 00001CF6 FEC6                <1> 	inc dh
  1600 00001CF8 E82CFC              <1> 	call os_move_cursor
  1601                              <1> 
  1602 00001CFB 5E                  <1> 	pop si				; ...and the second
  1603 00001CFC E8B7FB              <1> 	call os_print_string
  1604                              <1> 
  1605                              <1> 
  1606 00001CFF 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1607 00001D00 8936[3B1F]          <1> 	mov word [.list_string], si
  1608                              <1> 
  1609                              <1> 
  1610                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1611                              <1> 	; entry and let the user move up and down using the cursor keys
  1612                              <1> 
  1613 00001D04 C606[3A1F]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1614                              <1> 
  1615                              <1> 	mov16 dx, 25, 6			; Set up starting position for selector
    18 00001D09 BA1906              <2>  mov %1, (%2 + %3 * 256)
  1616                              <1> 
  1617 00001D0C 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1618 00001D11 7510                <1> 	jne .no_load_position
  1619                              <1> 	
  1620 00001D13 3A0E[371C]          <1> 	cmp cl, [os_file_selector.file_selector_numofentries]
  1621 00001D17 750A                <1> 	jne .no_load_position
  1622                              <1> 	
  1623 00001D19 8A36[351C]          <1> 	mov dh, [os_file_selector.file_selector_cursorpos]
  1624 00001D1D A0[361C]            <1> 	mov al, [os_file_selector.file_selector_skipnum]
  1625 00001D20 A2[3A1F]            <1> 	mov [.skip_num], al
  1626                              <1> 	
  1627                              <1> .no_load_position:
  1628 00001D23 E801FC              <1> 	call os_move_cursor
  1629                              <1> 
  1630                              <1> .more_select:
  1631 00001D26 60                  <1> 	pusha
  1632 00001D27 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1633                              <1> 	mov16 dx, 3, 5
    18 00001D29 BA0305              <2>  mov %1, (%2 + %3 * 256)
  1634 00001D2C 8B368900            <1> 	mov si, [0089h]
  1635 00001D30 83EE02              <1> 	sub si, byte 2
  1636 00001D33 BF1600              <1> 	mov di, 22
  1637 00001D36 E838FC              <1> 	call os_draw_block
  1638 00001D39 61                  <1> 	popa
  1639                              <1> 
  1640 00001D3A E8CC01              <1> 	call .draw_black_bar
  1641                              <1> 
  1642 00001D3D 8B36[3B1F]          <1> 	mov word si, [.list_string]
  1643 00001D41 E80F01              <1>  	call .draw_list
  1644                              <1> 
  1645                              <1> .another_key:
  1646 00001D44 E8F0F5              <1> 	call os_wait_for_key		; Move / select option
  1647 00001D47 3C6A                <1> 	cmp al, 'j'
  1648 00001D49 7446                <1> 	je .go_down
  1649 00001D4B 3C6B                <1> 	cmp al, 'k'
  1650 00001D4D 7431                <1> 	je .go_up
  1651 00001D4F 3C6C                <1> 	cmp al, 'l'
  1652 00001D51 0F84B200            <1> 	je .option_selected
  1653 00001D55 3C68                <1> 	cmp al, 'h'
  1654 00001D57 0F84DB00            <1> 	je .esc_pressed
  1655                              <1> 
  1656 00001D5B 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1657 00001D5E 7420                <1> 	je .go_up
  1658 00001D60 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1659 00001D63 742C                <1> 	je .go_down
  1660 00001D65 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1661 00001D67 0F849C00            <1> 	je .option_selected
  1662 00001D6B 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1663 00001D6D 0F84C500            <1> 	je .esc_pressed
  1664 00001D71 3C09                <1> 	cmp al, 9			; Tab pressed?
  1665 00001D73 7402                <1> 	je .tab_pressed
  1666 00001D75 EBAF                <1> 	jmp .more_select	; If not, wait for another key
  1667                              <1> 
  1668                              <1> .tab_pressed:
  1669 00001D77 B606                <1> 	mov dh, 6
  1670 00001D79 C606[3A1F]00        <1> 	mov byte [.skip_num], 0
  1671 00001D7E EBA6                <1> 	jmp .more_select
  1672                              <1> 	
  1673                              <1> .go_up:
  1674 00001D80 80FE06              <1> 	cmp dh, 6			; Already at top?
  1675 00001D83 7E30                <1> 	jle .hit_top
  1676                              <1> 
  1677 00001D85 E89801              <1> 	call .draw_white_bar
  1678                              <1> 
  1679 00001D88 B219                <1> 	mov dl, 25
  1680 00001D8A E89AFB              <1> 	call os_move_cursor
  1681                              <1> 
  1682 00001D8D FECE                <1> 	dec dh				; Row to select (increasing down)
  1683 00001D8F EB95                <1> 	jmp .more_select
  1684                              <1> 
  1685                              <1> 
  1686                              <1> .go_down:				; Already at bottom of list?
  1687 00001D91 80FE14              <1> 	cmp dh, 20
  1688 00001D94 742F                <1> 	je .hit_bottom
  1689                              <1> 
  1690                              <1> 	clr cx
    14 00001D96 31C9                <2>  xor %1, %1
  1691 00001D98 88F1                <1> 	mov byte cl, dh
  1692                              <1> 
  1693 00001D9A 80E905              <1> 	sub cl, 5
  1694 00001D9D 020E[3A1F]          <1> 	add byte cl, [.skip_num]
  1695                              <1> 
  1696 00001DA1 A0[391F]            <1> 	mov byte al, [.num_of_entries]
  1697 00001DA4 38C1                <1> 	cmp cl, al
  1698 00001DA6 741D                <1> 	je .hit_bottom
  1699                              <1> 
  1700 00001DA8 E87501              <1> 	call .draw_white_bar
  1701                              <1> 
  1702 00001DAB B219                <1> 	mov dl, 25
  1703 00001DAD E877FB              <1> 	call os_move_cursor
  1704                              <1> 
  1705 00001DB0 FEC6                <1> 	inc dh
  1706 00001DB2 E971FF              <1> 	jmp .more_select
  1707                              <1> 
  1708                              <1> 
  1709                              <1> .hit_top:
  1710 00001DB5 8A0E[3A1F]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1711 00001DB9 80F900              <1> 	cmp cl, 0
  1712 00001DBC 742C                <1> 	je .skip_to_bottom			; If not, wait for another key
  1713                              <1> 
  1714 00001DBE FE0E[3A1F]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1715 00001DC2 E961FF              <1> 	jmp .more_select
  1716                              <1> 
  1717                              <1> 
  1718                              <1> .hit_bottom:				; See if there's more to scroll
  1719                              <1> 	clr cx
    14 00001DC5 31C9                <2>  xor %1, %1
  1720 00001DC7 88F1                <1> 	mov byte cl, dh
  1721                              <1> 
  1722 00001DC9 80E906              <1> 	sub cl, 6
  1723 00001DCC FEC1                <1> 	inc cl
  1724 00001DCE 020E[3A1F]          <1> 	add byte cl, [.skip_num]
  1725                              <1> 
  1726 00001DD2 A0[391F]            <1> 	mov byte al, [.num_of_entries]
  1727 00001DD5 38C1                <1> 	cmp cl, al
  1728 00001DD7 7407                <1> 	je .skip_to_top
  1729                              <1> 
  1730 00001DD9 FE06[3A1F]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1731 00001DDD E946FF              <1> 	jmp .more_select
  1732                              <1> 
  1733                              <1> .skip_to_top:
  1734 00001DE0 C606[3A1F]00        <1> 	mov byte [.skip_num], 0
  1735 00001DE5 B606                <1> 	mov dh, 6
  1736 00001DE7 E93CFF              <1> 	jmp .more_select
  1737                              <1> 
  1738                              <1> .skip_to_bottom:
  1739 00001DEA A0[391F]            <1> 	mov al, [.num_of_entries]
  1740 00001DED 3C0F                <1> 	cmp al, 15
  1741 00001DEF 7E0A                <1> 	jle .basic_skip
  1742                              <1> 	
  1743                              <1> .no_basic_skip:
  1744 00001DF1 B614                <1> 	mov dh, 20
  1745 00001DF3 2C0F                <1> 	sub al, 15
  1746 00001DF5 A2[3A1F]            <1> 	mov [.skip_num], al
  1747                              <1> 
  1748 00001DF8 E92BFF              <1> 	jmp .more_select
  1749                              <1> 	
  1750                              <1> .basic_skip:
  1751 00001DFB 3C00                <1> 	cmp al, 0
  1752 00001DFD 7CF2                <1> 	jl .no_basic_skip
  1753 00001DFF 88C6                <1> 	mov dh, al
  1754 00001E01 80C605              <1> 	add dh, 5
  1755 00001E04 E91FFF              <1> 	jmp .more_select
  1756                              <1> 	
  1757                              <1> .option_selected:
  1758 00001E07 E852FB              <1> 	call os_show_cursor
  1759                              <1> 
  1760 00001E0A 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1761 00001E0F 7510                <1> 	jne .no_store_position
  1762                              <1> 	
  1763 00001E11 8836[351C]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1764 00001E15 A0[3A1F]            <1> 	mov al, [.skip_num]
  1765 00001E18 A2[361C]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1766 00001E1B A0[391F]            <1> 	mov al, [.num_of_entries]
  1767 00001E1E A2[371C]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1768                              <1> 	
  1769                              <1> .no_store_position:
  1770 00001E21 80EE06              <1> 	sub dh, 6
  1771                              <1> 
  1772 00001E24 0FB6C6              <1> 	movzx ax, dh
  1773                              <1> 
  1774 00001E27 FEC0                <1> 	inc al				; Options start from 1
  1775 00001E29 0206[3A1F]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1776                              <1> 
  1777 00001E2D A3[371F]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1778                              <1> 
  1779 00001E30 61                  <1> 	popa
  1780                              <1> 
  1781 00001E31 A1[371F]            <1> 	mov word ax, [.tmp]
  1782 00001E34 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1783 00001E35 C3                  <1> 	ret
  1784                              <1> 
  1785                              <1> 
  1786                              <1> 
  1787                              <1> .esc_pressed:
  1788 00001E36 E823FB              <1> 	call os_show_cursor
  1789                              <1> 
  1790 00001E39 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1791 00001E3E 7510                <1> 	jne .no_store_position_on_exit
  1792                              <1> 	
  1793 00001E40 8836[351C]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1794 00001E44 A0[3A1F]            <1> 	mov al, [.skip_num]
  1795 00001E47 A2[361C]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1796 00001E4A A0[391F]            <1> 	mov al, [.num_of_entries]
  1797 00001E4D A2[371C]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1798                              <1> 	
  1799                              <1> .no_store_position_on_exit:
  1800 00001E50 61                  <1> 	popa
  1801 00001E51 F9                  <1> 	stc				; Set carry for Esc
  1802 00001E52 C3                  <1> 	ret
  1803                              <1> 
  1804                              <1> 
  1805                              <1> 
  1806                              <1> .draw_list:
  1807 00001E53 60                  <1> 	pusha
  1808                              <1> 
  1809                              <1> 	mov16 dx, 5, 6		; Get into position for option list text
    18 00001E54 BA0506              <2>  mov %1, (%2 + %3 * 256)
  1810 00001E57 E8CDFA              <1> 	call os_move_cursor
  1811                              <1> 
  1812                              <1> 	clr cx				; Skip lines scrolled off the top of the dialog
    14 00001E5A 31C9                <2>  xor %1, %1
  1813 00001E5C 8A0E[3A1F]          <1> 	mov byte cl, [.skip_num]
  1814                              <1> 
  1815 00001E60 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1816 00001E65 747C                <1> 	je .file_draw_list
  1817                              <1> 
  1818                              <1> .skip_loop:
  1819 00001E67 83F900              <1> 	cmp cx, 0
  1820 00001E6A 740B                <1> 	je .skip_loop_finished
  1821                              <1> .more_lodsb:
  1822 00001E6C 268A04              <1> 	mov al, [es:si]
  1823 00001E6F 46                  <1> 	inc si
  1824 00001E70 3C2C                <1> 	cmp al, ','
  1825 00001E72 75F8                <1> 	jne .more_lodsb
  1826 00001E74 49                  <1> 	dec cx
  1827 00001E75 EBF0                <1> 	jmp .skip_loop
  1828                              <1> 
  1829                              <1> 
  1830                              <1> .skip_loop_finished:
  1831                              <1> 	clr bx				; Counter for total number of options
    14 00001E77 31DB                <2>  xor %1, %1
  1832                              <1> 
  1833                              <1> 
  1834                              <1> .more:
  1835 00001E79 268A04              <1> 	mov al, [es:si]		; Get next character in file name, increment pointer
  1836 00001E7C 46                  <1> 	inc si
  1837                              <1> 	
  1838 00001E7D 3C00                <1> 	cmp al, 0			; End of string?
  1839 00001E7F 7417                <1> 	je .done_list
  1840                              <1> 
  1841 00001E81 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1842 00001E83 7406                <1> 	je .newline
  1843                              <1> 
  1844 00001E85 B40E                <1> 	mov ah, 0Eh
  1845 00001E87 CD10                <1> 	int 10h
  1846 00001E89 EBEE                <1> 	jmp .more
  1847                              <1> 
  1848                              <1> .newline:
  1849 00001E8B B205                <1> 	mov dl, 5			; Go back to starting X position
  1850 00001E8D FEC6                <1> 	inc dh				; But jump down a line
  1851 00001E8F E895FA              <1> 	call os_move_cursor
  1852                              <1> 
  1853 00001E92 43                  <1> 	inc bx				; Update the number-of-options counter
  1854 00001E93 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1855 00001E96 7CE1                <1> 	jl .more
  1856                              <1> 
  1857                              <1> .done_list:
  1858 00001E98 61                  <1> 	popa
  1859                              <1> 
  1860 00001E99 60                  <1> 	pusha
  1861 00001E9A 52                  <1> 	push dx
  1862                              <1> 	mov16 dx, 5, 22
    18 00001E9B BA0516              <2>  mov %1, (%2 + %3 * 256)
  1863 00001E9E E886FA              <1> 	call os_move_cursor
  1864                              <1> 	
  1865 00001EA1 BE[3D1F]            <1> 	mov si, .string1
  1866 00001EA4 E80FFA              <1> 	call os_print_string
  1867                              <1> 	
  1868 00001EA7 5A                  <1> 	pop dx
  1869 00001EA8 A0[3A1F]            <1> 	mov al, [.skip_num]
  1870 00001EAB 00F0                <1> 	add al, dh
  1871 00001EAD 2C05                <1> 	sub al, 5
  1872 00001EAF 0FB6C0              <1> 	movzx ax, al
  1873 00001EB2 E8780D              <1> 	call os_int_to_string
  1874 00001EB5 89C6                <1> 	mov si, ax
  1875 00001EB7 E8FCF9              <1> 	call os_print_string
  1876                              <1> 	
  1877 00001EBA BE[3F1F]            <1> 	mov si, .string2
  1878 00001EBD E8F6F9              <1> 	call os_print_string
  1879                              <1> 	
  1880 00001EC0 0FB606[391F]        <1> 	movzx ax, byte [.num_of_entries]
  1881 00001EC5 E8650D              <1> 	call os_int_to_string
  1882 00001EC8 89C6                <1> 	mov si, ax
  1883 00001ECA E8E9F9              <1> 	call os_print_string
  1884                              <1> 	
  1885 00001ECD BE[411F]            <1> 	mov si, .string3
  1886 00001ED0 E8E3F9              <1> 	call os_print_string
  1887                              <1> 	
  1888                              <1> 	
  1889 00001ED3 A0[3A1F]            <1> 	mov al, [.skip_num]
  1890 00001ED6 00F0                <1> 	add al, dh
  1891 00001ED8 2C05                <1> 	sub al, 5
  1892 00001EDA 0FB6C0              <1> 	movzx ax, al
  1893 00001EDD FF16[451F]          <1> 	call [.callback]
  1894                              <1> 	
  1895 00001EE1 61                  <1> 	popa
  1896 00001EE2 C3                  <1> 	ret
  1897                              <1> 
  1898                              <1> .file_draw_list:
  1899                              <1> 	clr bx
    14 00001EE3 31DB                <2>  xor %1, %1
  1900                              <1> 
  1901                              <1> .f_more:
  1902 00001EE5 51                  <1> 	push cx
  1903 00001EE6 89C8                <1> 	mov ax, cx
  1904 00001EE8 40                  <1> 	inc ax
  1905 00001EE9 E88CFB              <1> 	call os_file_selector.get_filename
  1906 00001EEC BE[091C]            <1> 	mov si, os_file_selector.filename
  1907 00001EEF E8C4F9              <1> 	call os_print_string
  1908 00001EF2 59                  <1> 	pop cx
  1909                              <1> 
  1910 00001EF3 B205                <1> 	mov dl, 5			; Go back to starting X position
  1911 00001EF5 FEC6                <1> 	inc dh				; But jump down a line
  1912 00001EF7 E82DFA              <1> 	call os_move_cursor
  1913                              <1> 
  1914 00001EFA 41                  <1> 	inc cx
  1915 00001EFB 3A0E[391F]          <1> 	cmp cl, [.num_of_entries]
  1916 00001EFF 7497                <1> 	je .done_list
  1917                              <1> 
  1918 00001F01 43                  <1> 	inc bx				; Update the number-of-options counter
  1919 00001F02 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1920 00001F05 7CDE                <1> 	jl .f_more
  1921 00001F07 EB8F                <1> 	jmp .done_list
  1922                              <1> 
  1923                              <1> .draw_black_bar:
  1924 00001F09 60                  <1> 	pusha
  1925                              <1> 
  1926 00001F0A B204                <1> 	mov dl, 4
  1927 00001F0C E818FA              <1> 	call os_move_cursor
  1928                              <1> 
  1929                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    18 00001F0F B82009              <2>  mov %1, (%2 + %3 * 256)
  1930                              <1> 	mov16 bx, 00001111b, 0	; White text on black background
    18 00001F12 BB0F00              <2>  mov %1, (%2 + %3 * 256)
  1931 00001F15 8B0E8900            <1> 	mov cx, [0089h]
  1932 00001F19 83E904              <1> 	sub cx, byte 4
  1933 00001F1C CD10                <1> 	int 10h
  1934                              <1> 
  1935 00001F1E 61                  <1> 	popa
  1936 00001F1F C3                  <1> 	ret
  1937                              <1> 
  1938                              <1> 
  1939                              <1> 
  1940                              <1> .draw_white_bar:
  1941 00001F20 60                  <1> 	pusha
  1942                              <1> 
  1943 00001F21 B204                <1> 	mov dl, 4
  1944 00001F23 E801FA              <1> 	call os_move_cursor
  1945                              <1> 
  1946                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    18 00001F26 B82009              <2>  mov %1, (%2 + %3 * 256)
  1947                              <1> 	mov16 bx, 11110000b, 0	; White text on black background
    18 00001F29 BBF000              <2>  mov %1, (%2 + %3 * 256)
  1948 00001F2C 8B0E8900            <1> 	mov cx, [0089h]
  1949 00001F30 83E904              <1> 	sub cx, byte 4
  1950 00001F33 CD10                <1> 	int 10h
  1951                              <1> 
  1952 00001F35 61                  <1> 	popa
  1953 00001F36 C3                  <1> 	ret
  1954                              <1> 
  1955                              <1> 
  1956 00001F37 0000                <1> 	.tmp			dw 0
  1957 00001F39 00                  <1> 	.num_of_entries	db 0
  1958 00001F3A 00                  <1> 	.skip_num		db 0
  1959 00001F3B 0000                <1> 	.list_string	dw 0
  1960 00001F3D 2800                <1> 	.string1		db '(', 0
  1961 00001F3F 2F00                <1> 	.string2		db '/', 0
  1962 00001F41 29202000            <1> 	.string3		db ')  ', 0
  1963 00001F45 0000                <1> 	.callback		dw 0
  1964                              <1> 	
  1965                              <1> ; ------------------------------------------------------------------
  1966                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1967                              <1> ; containing text, and a coloured middle section.
  1968                              <1> ; IN: AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1969                              <1> 
  1970                              <1> os_draw_background:
  1971 00001F47 60                  <1> 	pusha
  1972                              <1> 	
  1973 00001F48 50                  <1> 	push ax				; Store params to pop out later
  1974 00001F49 53                  <1> 	push bx
  1975 00001F4A 51                  <1> 	push cx
  1976                              <1> 
  1977 00001F4B BA0000              <1> 	mov dx, 0
  1978 00001F4E E8D6F9              <1> 	call os_move_cursor
  1979                              <1> 
  1980 00001F51 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1981 00001F54 B95000              <1> 	mov cx, 80
  1982 00001F57 BB7000              <1> 	mov bx, 01110000b
  1983 00001F5A CD10                <1> 	int 10h
  1984                              <1> 
  1985 00001F5C BA0001              <1> 	mov dx, 256
  1986 00001F5F E8C5F9              <1> 	call os_move_cursor
  1987                              <1> 	
  1988 00001F62 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1989 00001F63 81FB0001            <1> 	cmp bx, 256
  1990 00001F67 7469                <1> 	je .draw_default_background
  1991                              <1> 	
  1992 00001F69 B82009              <1> 	mov ax, 0920h			; Draw colour section
  1993 00001F6C B93007              <1> 	mov cx, 1840
  1994 00001F6F B700                <1> 	mov bh, 0
  1995 00001F71 CD10                <1> 	int 10h
  1996                              <1> 
  1997                              <1> .bg_drawn:
  1998                              <1> 	mov16 dx, 0, 24
    18 00001F73 BA0018              <2>  mov %1, (%2 + %3 * 256)
  1999 00001F76 E8AEF9              <1> 	call os_move_cursor
  2000                              <1> 
  2001 00001F79 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  2002 00001F7C B95000              <1> 	mov cx, 80
  2003 00001F7F BB7000              <1> 	mov bx, 01110000b
  2004 00001F82 CD10                <1> 	int 10h
  2005                              <1> 
  2006                              <1> 	mov16 dx, 1, 24
    18 00001F84 BA0118              <2>  mov %1, (%2 + %3 * 256)
  2007 00001F87 E89DF9              <1> 	call os_move_cursor
  2008 00001F8A 5E                  <1> 	pop si				; Get bottom string param
  2009 00001F8B E828F9              <1> 	call os_print_string
  2010                              <1> 
  2011 00001F8E BA0100              <1> 	mov dx, 1
  2012 00001F91 E893F9              <1> 	call os_move_cursor
  2013 00001F94 5E                  <1> 	pop si				; Get top string param
  2014 00001F95 E81EF9              <1> 	call os_print_string
  2015                              <1> 
  2016 00001F98 BB[0520]            <1> 	mov bx, tmp_string
  2017 00001F9B E83E0D              <1> 	call os_get_date_string
  2018                              <1> 	
  2019 00001F9E BA4500              <1> 	mov dx, 69			; Display date
  2020 00001FA1 E883F9              <1> 	call os_move_cursor
  2021 00001FA4 89DE                <1> 	mov si, bx
  2022 00001FA6 E80DF9              <1> 	call os_print_string
  2023                              <1> 	
  2024 00001FA9 BB[0520]            <1> 	mov bx, tmp_string
  2025 00001FAC E8E60C              <1> 	call os_get_time_string
  2026                              <1> 
  2027 00001FAF BA3F00              <1> 	mov dx, 63			; Display time
  2028 00001FB2 E872F9              <1> 	call os_move_cursor
  2029 00001FB5 89DE                <1> 	mov si, bx
  2030 00001FB7 E8FCF8              <1> 	call os_print_string
  2031                              <1> 	
  2032 00001FBA B24F                <1> 	mov dl, 79			; Print the little speaker icon
  2033 00001FBC E868F9              <1> 	call os_move_cursor
  2034                              <1> 	
  2035 00001FBF B8170E              <1> 	mov ax, 0E17h
  2036 00001FC2 2A068300            <1> 	sub al, [0083h]
  2037 00001FC6 B700                <1> 	mov bh, 0
  2038 00001FC8 CD10                <1> 	int 10h
  2039                              <1> 	
  2040                              <1> 	mov16 dx, 0, 1		; Ready for app text
    18 00001FCA BA0001              <2>  mov %1, (%2 + %3 * 256)
  2041 00001FCD E857F9              <1> 	call os_move_cursor
  2042                              <1> 
  2043 00001FD0 61                  <1> 	popa
  2044 00001FD1 C3                  <1> 	ret
  2045                              <1> 
  2046                              <1> .draw_default_background:
  2047 00001FD2 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  2048 00001FD8 741B                <1> 	je .fill_color
  2049                              <1> 	
  2050 00001FDA 1E                  <1> 	push ds
  2051 00001FDB 06                  <1> 	push es
  2052                              <1> 	
  2053 00001FDC 8E1E[9405]          <1> 	mov ds, [driversgmt]
  2054 00001FE0 BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  2055                              <1> 
  2056 00001FE3 B800B8              <1> 	mov ax, 0B800h
  2057 00001FE6 8EC0                <1> 	mov es, ax
  2058 00001FE8 BFA000              <1> 	mov di, 160
  2059                              <1> 	
  2060 00001FEB B9600E              <1> 	mov cx, 80 * 23 * 2
  2061                              <1> 	
  2062 00001FEE F3A4                <1> 	rep movsb
  2063                              <1> 	
  2064 00001FF0 07                  <1> 	pop es
  2065 00001FF1 1F                  <1> 	pop ds
  2066 00001FF2 E97EFF              <1> 	jmp .bg_drawn
  2067                              <1> 	
  2068                              <1> .fill_color:
  2069 00001FF5 0FB61EA8DE          <1> 	movzx bx, byte [57000]
  2070 00001FFA B82009              <1> 	mov ax, 0920h
  2071 00001FFD B93007              <1> 	mov cx, 1840
  2072                              <1> 
  2073 00002000 CD10                <1> 	int 10h
  2074 00002002 E96EFF              <1> 	jmp .bg_drawn
  2075                              <1> 
  2076 00002005 00<rep Fh>          <1> 	tmp_string			times 15 db 0
  2077                              <1> 
  2078                              <1> 
  2079                              <1> ; ------------------------------------------------------------------
  2080                              <1> ; os_print_newline -- Reset cursor to start of next line
  2081                              <1> ; IN/OUT: Nothing (registers preserved)
  2082                              <1> 
  2083                              <1> os_print_newline:
  2084 00002014 60                  <1> 	pusha
  2085                              <1> 
  2086 00002015 B40E                <1> 	mov ah, 0Eh			; BIOS output char code
  2087                              <1> 
  2088 00002017 B00D                <1> 	mov al, 13
  2089 00002019 CD10                <1> 	int 10h
  2090 0000201B B00A                <1> 	mov al, 10
  2091 0000201D CD10                <1> 	int 10h
  2092                              <1> 
  2093 0000201F 61                  <1> 	popa
  2094 00002020 C3                  <1> 	ret
  2095                              <1> 
  2096                              <1> 
  2097                              <1> ; ------------------------------------------------------------------
  2098                              <1> ; os_dump_registers -- Displays register contents in hex on the screen
  2099                              <1> ; IN/OUT: EAX/EBX/ECX/EDX/ESI/EDI = registers to show
  2100                              <1> 
  2101                              <1> os_dump_registers:
  2102 00002021 6660                <1> 	pushad
  2103                              <1> 
  2104 00002023 6657                <1> 	push edi
  2105 00002025 68[7220]            <1> 	push .di_string
  2106 00002028 6656                <1> 	push esi
  2107 0000202A 68[6C20]            <1> 	push .si_string
  2108 0000202D 6652                <1> 	push edx
  2109 0000202F 68[6620]            <1> 	push .dx_string
  2110 00002032 6651                <1> 	push ecx
  2111 00002034 68[6020]            <1> 	push .cx_string
  2112 00002037 6653                <1> 	push ebx
  2113 00002039 68[5A20]            <1> 	push .bx_string
  2114 0000203C 6650                <1> 	push eax
  2115 0000203E 68[5520]            <1> 	push .ax_string
  2116                              <1> 	
  2117 00002041 B90600              <1> 	mov cx, 6
  2118                              <1> 	
  2119                              <1> .loop:
  2120 00002044 5E                  <1> 	pop si
  2121 00002045 E86EF8              <1> 	call os_print_string
  2122 00002048 6658                <1> 	pop eax
  2123 0000204A E8B903              <1> 	call os_print_8hex
  2124 0000204D E2F5                <1> 	loop .loop
  2125                              <1> 	
  2126 0000204F E8C2FF              <1> 	call os_print_newline
  2127                              <1> 
  2128 00002052 6661                <1> 	popad
  2129 00002054 C3                  <1> 	ret
  2130                              <1> 
  2131                              <1> 
  2132 00002055 4541583A00          <1> 	.ax_string		db 'EAX:', 0
  2133 0000205A 204542583A00        <1> 	.bx_string		db ' EBX:', 0
  2134 00002060 204543583A00        <1> 	.cx_string		db ' ECX:', 0
  2135 00002066 204544583A00        <1> 	.dx_string		db ' EDX:', 0
  2136 0000206C 204553493A00        <1> 	.si_string		db ' ESI:', 0
  2137 00002072 204544493A00        <1> 	.di_string		db ' EDI:', 0
  2138                              <1> 
  2139                              <1> 
  2140                              <1> ; ------------------------------------------------------------------
  2141                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  2142                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2143                              <1> 
  2144                              <1> os_input_dialog:
  2145 00002078 60                  <1> 	pusha
  2146                              <1> 
  2147 00002079 50                  <1> 	push ax				; Save string location
  2148 0000207A 53                  <1> 	push bx				; Save message to show
  2149                              <1> 
  2150                              <1> 
  2151                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    18 0000207B BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2152                              <1> 
  2153                              <1> .redbox:				; Loop to draw all lines of box
  2154 0000207E E8A6F8              <1> 	call os_move_cursor
  2155                              <1> 
  2156 00002081 60                  <1> 	pusha
  2157                              <1> 	mov16 ax, ' ', 09h
    18 00002082 B82009              <2>  mov %1, (%2 + %3 * 256)
  2158 00002085 B93700              <1> 	mov cx, 55
  2159 00002088 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2160 0000208D CD10                <1> 	int 10h
  2161 0000208F 61                  <1> 	popa
  2162                              <1> 
  2163 00002090 FEC6                <1> 	inc dh
  2164 00002092 80FE10              <1> 	cmp dh, 16
  2165 00002095 7402                <1> 	je .boxdone
  2166 00002097 EBE5                <1> 	jmp .redbox
  2167                              <1> 
  2168                              <1> 
  2169                              <1> .boxdone:
  2170                              <1> 	mov16 dx, 14, 14
    18 00002099 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2171 0000209C E888F8              <1> 	call os_move_cursor
  2172                              <1> 
  2173                              <1> 	mov16 ax, ' ', 09h
    18 0000209F B82009              <2>  mov %1, (%2 + %3 * 256)
  2174 000020A2 BBF000              <1> 	mov bx, 240
  2175 000020A5 B93300              <1> 	mov cx, 51
  2176 000020A8 CD10                <1> 	int 10h
  2177                              <1> 	
  2178                              <1> 	mov16 dx, 14, 11
    18 000020AA BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2179 000020AD E877F8              <1> 	call os_move_cursor
  2180                              <1> 	
  2181                              <1> 
  2182 000020B0 5B                  <1> 	pop bx				; Get message back and display it
  2183 000020B1 89DE                <1> 	mov si, bx
  2184 000020B3 E800F8              <1> 	call os_print_string
  2185                              <1> 
  2186                              <1> 	mov16 dx, 14, 14
    18 000020B6 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2187 000020B9 E86BF8              <1> 	call os_move_cursor
  2188                              <1> 
  2189                              <1> 
  2190 000020BC 58                  <1> 	pop ax				; Get input string back
  2191 000020BD E8C301              <1> 	call os_input_string
  2192                              <1> 
  2193 000020C0 61                  <1> 	popa
  2194 000020C1 C3                  <1> 	ret
  2195                              <1> 
  2196                              <1> ; ------------------------------------------------------------------
  2197                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  2198                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2199                              <1> 
  2200                              <1> os_password_dialog:
  2201 000020C2 60                  <1> 	pusha
  2202                              <1> 
  2203 000020C3 50                  <1> 	push ax				; Save string location
  2204 000020C4 53                  <1> 	push bx				; Save message to show
  2205                              <1> 
  2206                              <1> 
  2207                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    18 000020C5 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2208                              <1> 
  2209                              <1> .redbox:				; Loop to draw all lines of box
  2210 000020C8 E85CF8              <1> 	call os_move_cursor
  2211                              <1> 
  2212 000020CB 60                  <1> 	pusha
  2213                              <1> 	mov16 ax, ' ', 09h
    18 000020CC B82009              <2>  mov %1, (%2 + %3 * 256)
  2214 000020CF B93700              <1> 	mov cx, 55
  2215 000020D2 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2216 000020D7 CD10                <1> 	int 10h
  2217 000020D9 61                  <1> 	popa
  2218                              <1> 
  2219 000020DA FEC6                <1> 	inc dh
  2220 000020DC 80FE10              <1> 	cmp dh, 16
  2221 000020DF 7402                <1> 	je .boxdone
  2222 000020E1 EBE5                <1> 	jmp .redbox
  2223                              <1> 
  2224                              <1> 
  2225                              <1> .boxdone:
  2226                              <1> 	mov16 dx, 14, 14
    18 000020E3 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2227 000020E6 E83EF8              <1> 	call os_move_cursor
  2228                              <1> 
  2229                              <1> 	mov16 ax, ' ', 09h
    18 000020E9 B82009              <2>  mov %1, (%2 + %3 * 256)
  2230 000020EC BBF000              <1> 	mov bx, 240
  2231 000020EF B93300              <1> 	mov cx, 51
  2232 000020F2 CD10                <1> 	int 10h
  2233                              <1> 	
  2234                              <1> 	mov16 dx, 14, 11
    18 000020F4 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2235 000020F7 E82DF8              <1> 	call os_move_cursor
  2236                              <1> 	
  2237                              <1> 
  2238 000020FA 5B                  <1> 	pop bx				; Get message back and display it
  2239 000020FB 89DE                <1> 	mov si, bx
  2240 000020FD E8B6F7              <1> 	call os_print_string
  2241                              <1> 
  2242                              <1> 	mov16 dx, 14, 14
    18 00002100 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2243 00002103 E821F8              <1> 	call os_move_cursor
  2244                              <1> 
  2245                              <1> 
  2246 00002106 58                  <1> 	pop ax				; Get input string back
  2247 00002107 B3F0                <1> 	mov bl, 240
  2248 00002109 E8E101              <1> 	call os_input_password
  2249                              <1> 
  2250 0000210C 61                  <1> 	popa
  2251 0000210D C3                  <1> 	ret
  2252                              <1> 
  2253                              <1> 
  2254                              <1> ; ------------------------------------------------------------------
  2255                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  2256                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display),
  2257                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
  2258                              <1> ; IN: [0085h] = Default button for 2-button dialog (0 or 1)
  2259                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  2260                              <1> ; NOTE: Each string is limited to 40 characters
  2261                              <1> 
  2262                              <1> os_dialog_box:
  2263 0000210E 60                  <1> 	pusha
  2264                              <1> 
  2265 0000210F 52                  <1> 	push dx
  2266                              <1> 
  2267 00002110 51                  <1> 	push cx
  2268 00002111 53                  <1> 	push bx
  2269 00002112 50                  <1> 	push ax
  2270                              <1> 	
  2271 00002113 E851F8              <1> 	call os_hide_cursor
  2272                              <1> 
  2273 00002116 60                  <1> 	pusha
  2274 00002117 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  2275                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    18 0000211B BA1309              <2>  mov %1, (%2 + %3 * 256)
  2276 0000211E BE2A00              <1> 	mov si, 42
  2277 00002121 BF1000              <1> 	mov di, 16
  2278 00002124 E84AF8              <1> 	call os_draw_block
  2279 00002127 61                  <1> 	popa
  2280                              <1> 	
  2281                              <1> 	mov16 dx, 20, 9
    18 00002128 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2282 0000212B B90300              <1> 	mov cx, 3
  2283                              <1> 	
  2284                              <1> .loop:
  2285 0000212E FEC6                <1> 	inc dh
  2286 00002130 E8F4F7              <1> 	call os_move_cursor
  2287                              <1> 	
  2288 00002133 5E                  <1> 	pop si
  2289 00002134 83FE00              <1> 	cmp si, 0
  2290 00002137 7403                <1> 	je .no_string
  2291                              <1> 	
  2292 00002139 E87AF7              <1> 	call os_print_string
  2293                              <1> 	
  2294                              <1> .no_string:
  2295 0000213C E2F0                <1> 	loop .loop
  2296                              <1> 	
  2297 0000213E 5A                  <1> 	pop dx
  2298 0000213F 83FA01              <1> 	cmp dx, 1
  2299 00002142 7426                <1> 	je .two_button
  2300                              <1> 
  2301                              <1> 	
  2302                              <1> .one_button:
  2303 00002144 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2304                              <1> 	mov16 dx, 35, 14
    18 00002146 BA230E              <2>  mov %1, (%2 + %3 * 256)
  2305 00002149 BE0800              <1> 	mov si, 8
  2306 0000214C BF0F00              <1> 	mov di, 15
  2307 0000214F E81FF8              <1> 	call os_draw_block
  2308                              <1> 
  2309                              <1> 	mov16 dx, 38, 14		; OK button, centred at bottom of box
    18 00002152 BA260E              <2>  mov %1, (%2 + %3 * 256)
  2310 00002155 E8CFF7              <1> 	call os_move_cursor
  2311 00002158 BE[3922]            <1> 	mov si, .ok_button_string
  2312 0000215B E858F7              <1> 	call os_print_string
  2313                              <1> 
  2314                              <1> .one_button_wait:
  2315 0000215E E8D6F1              <1> 	call os_wait_for_key
  2316 00002161 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2317 00002163 75F9                <1> 	jne .one_button_wait
  2318                              <1> 
  2319 00002165 E8F4F7              <1> 	call os_show_cursor
  2320                              <1> 
  2321 00002168 61                  <1> 	popa
  2322 00002169 C3                  <1> 	ret
  2323                              <1> 
  2324                              <1> .two_button:
  2325 0000216A B3F0                <1> 	mov bl, 11110000b		; Black on white
  2326                              <1> 	mov16 dx, 27, 14
    18 0000216C BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2327 0000216F BE0800              <1> 	mov si, 8
  2328 00002172 BF0F00              <1> 	mov di, 15
  2329 00002175 E8F9F7              <1> 	call os_draw_block
  2330                              <1> 
  2331                              <1> 	mov16 dx, 30, 14			; OK button
    18 00002178 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2332 0000217B E8A9F7              <1> 	call os_move_cursor
  2333 0000217E BE[3922]            <1> 	mov si, .ok_button_string
  2334 00002181 E832F7              <1> 	call os_print_string
  2335                              <1> 
  2336                              <1> 	mov16 dx, 44, 14			; Cancel button
    18 00002184 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2337 00002187 E89DF7              <1> 	call os_move_cursor
  2338 0000218A BE[3C22]            <1> 	mov si, .cancel_button_string
  2339 0000218D E826F7              <1> 	call os_print_string
  2340                              <1> 
  2341 00002190 803E850001          <1> 	cmp byte [0085h], 1
  2342 00002195 7466                <1> 	je .draw_right
  2343 00002197 7529                <1> 	jne .draw_left
  2344                              <1> 	
  2345                              <1> .two_button_wait:
  2346 00002199 E89BF1              <1> 	call os_wait_for_key
  2347                              <1> 
  2348 0000219C 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  2349 0000219F 7421                <1> 	je .draw_left
  2350 000021A1 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  2351 000021A4 7457                <1> 	je .draw_right
  2352                              <1> 	
  2353 000021A6 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  2354 000021A8 7410                <1> 	je .cancel
  2355 000021AA 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2356 000021AC 75EB                <1> 	jne .two_button_wait
  2357                              <1> 	
  2358 000021AE E8ABF7              <1> 	call os_show_cursor
  2359                              <1> 
  2360 000021B1 890E[4322]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
  2361 000021B5 61                  <1> 	popa
  2362 000021B6 A1[4322]            <1> 	mov ax, [.tmp]
  2363                              <1> 
  2364 000021B9 C3                  <1> 	ret
  2365                              <1> 
  2366                              <1> .cancel:
  2367 000021BA E89FF7              <1> 	call os_show_cursor
  2368 000021BD 61                  <1> 	popa
  2369 000021BE B80100              <1> 	mov ax, 1
  2370 000021C1 C3                  <1> 	ret
  2371                              <1> 
  2372                              <1> .draw_left:
  2373 000021C2 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2374                              <1> 	mov16 dx, 27, 14
    18 000021C4 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2375 000021C7 BE0800              <1> 	mov si, 8
  2376 000021CA BF0F00              <1> 	mov di, 15
  2377 000021CD E8A1F7              <1> 	call os_draw_block
  2378                              <1> 
  2379                              <1> 	mov16 dx, 30, 14		; OK button
    18 000021D0 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2380 000021D3 E851F7              <1> 	call os_move_cursor
  2381 000021D6 BE[3922]            <1> 	mov si, .ok_button_string
  2382 000021D9 E8DAF6              <1> 	call os_print_string
  2383                              <1> 
  2384 000021DC 8A1EA9DE            <1> 	mov bl, [57001]
  2385                              <1> 	mov16 dx, 42, 14
    18 000021E0 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  2386 000021E3 BE0900              <1> 	mov si, 9
  2387 000021E6 BF0F00              <1> 	mov di, 15
  2388 000021E9 E885F7              <1> 	call os_draw_block
  2389                              <1> 
  2390                              <1> 	mov16 dx, 44, 14		; Cancel button
    18 000021EC BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2391 000021EF E835F7              <1> 	call os_move_cursor
  2392 000021F2 BE[3C22]            <1> 	mov si, .cancel_button_string
  2393 000021F5 E8BEF6              <1> 	call os_print_string
  2394                              <1> 
  2395 000021F8 B90000              <1> 	mov cx, 0			; And update result we'll return
  2396 000021FB EB9C                <1> 	jmp .two_button_wait
  2397                              <1> 
  2398                              <1> .draw_right:
  2399 000021FD 8A1EA9DE            <1> 	mov bl, [57001]
  2400                              <1> 	mov16 dx, 27, 14
    18 00002201 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2401 00002204 BE0800              <1> 	mov si, 8
  2402 00002207 BF0F00              <1> 	mov di, 15
  2403 0000220A E864F7              <1> 	call os_draw_block
  2404                              <1> 
  2405                              <1> 	mov16 dx, 30, 14			; OK button
    18 0000220D BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2406 00002210 E814F7              <1> 	call os_move_cursor
  2407 00002213 BE[3922]            <1> 	mov si, .ok_button_string
  2408 00002216 E89DF6              <1> 	call os_print_string
  2409                              <1> 
  2410 00002219 B3F0                <1> 	mov bl, 11110000b
  2411                              <1> 	mov16 dx, 43, 14
    18 0000221B BA2B0E              <2>  mov %1, (%2 + %3 * 256)
  2412 0000221E BE0800              <1> 	mov si, 8
  2413 00002221 BF0F00              <1> 	mov di, 15
  2414 00002224 E84AF7              <1> 	call os_draw_block
  2415                              <1> 
  2416                              <1> 	mov16 dx, 44, 14			; Cancel button
    18 00002227 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2417 0000222A E8FAF6              <1> 	call os_move_cursor
  2418 0000222D BE[3C22]            <1> 	mov si, .cancel_button_string
  2419 00002230 E883F6              <1> 	call os_print_string
  2420                              <1> 
  2421 00002233 B90100              <1> 	mov cx, 1			; And update result we'll return
  2422 00002236 E960FF              <1> 	jmp .two_button_wait
  2423                              <1> 
  2424                              <1> 
  2425                              <1> 
  2426 00002239 4F4B00              <1> 	.ok_button_string	db 'OK', 0
  2427 0000223C 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
  2428                              <1> 
  2429 00002243 0000                <1> 	.tmp dw 0
  2430                              <1> 
  2431                              <1> ; ------------------------------------------------------------------
  2432                              <1> ; os_print_space -- Print a space to the screen
  2433                              <1> ; IN/OUT: Nothing
  2434                              <1> 
  2435                              <1> os_print_space:
  2436 00002245 60                  <1> 	pusha
  2437                              <1> 
  2438 00002246 B8200E              <1> 	mov ax, 0E20h			; BIOS teletype function
  2439 00002249 CD10                <1> 	int 10h
  2440                              <1> 
  2441 0000224B 61                  <1> 	popa
  2442 0000224C C3                  <1> 	ret
  2443                              <1> 
  2444                              <1> 
  2445                              <1> ; ------------------------------------------------------------------
  2446                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  2447                              <1> ; Works up to base 37, ie digits 0-Z
  2448                              <1> ; IN: AX = "digit" to format and print
  2449                              <1> 
  2450                              <1> os_print_digit:
  2451 0000224D 60                  <1> 	pusha
  2452                              <1> 
  2453 0000224E 83F809              <1> 	cmp ax, 9			; There is a break in ASCII table between 9 and A
  2454 00002251 7E03                <1> 	jle .digit_format
  2455                              <1> 
  2456 00002253 83C007              <1> 	add ax, 'A'-'9'-1		; Correct for the skipped punctuation
  2457                              <1> 
  2458                              <1> .digit_format:
  2459 00002256 83C030              <1> 	add ax, '0'			; 0 will display as '0', etc.	
  2460                              <1> 
  2461 00002259 B40E                <1> 	mov ah, 0Eh			; May modify other registers
  2462 0000225B CD10                <1> 	int 10h
  2463                              <1> 
  2464 0000225D 61                  <1> 	popa
  2465 0000225E C3                  <1> 	ret
  2466                              <1> 
  2467                              <1> 
  2468                              <1> ; ------------------------------------------------------------------
  2469                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  2470                              <1> ; IN: AL = number to format and print
  2471                              <1> 
  2472                              <1> os_print_1hex:
  2473 0000225F 60                  <1> 	pusha
  2474                              <1> 
  2475 00002260 83E00F              <1> 	and ax, 0Fh			; Mask off data to display
  2476 00002263 E8E7FF              <1> 	call os_print_digit
  2477                              <1> 
  2478 00002266 61                  <1> 	popa
  2479 00002267 C3                  <1> 	ret
  2480                              <1> 
  2481                              <1> 
  2482                              <1> ; ------------------------------------------------------------------
  2483                              <1> ; os_print_2hex -- Displays AL in hex format
  2484                              <1> ; IN: AL = number to format and print
  2485                              <1> 
  2486                              <1> os_print_2hex:
  2487 00002268 60                  <1> 	pusha
  2488                              <1> 
  2489 00002269 50                  <1> 	push ax				; Output high nibble
  2490 0000226A C1E804              <1> 	shr ax, 4
  2491 0000226D E8EFFF              <1> 	call os_print_1hex
  2492                              <1> 
  2493 00002270 58                  <1> 	pop ax				; Output low nibble
  2494 00002271 E8EBFF              <1> 	call os_print_1hex
  2495                              <1> 
  2496 00002274 61                  <1> 	popa
  2497 00002275 C3                  <1> 	ret
  2498                              <1> 
  2499                              <1> 
  2500                              <1> ; ------------------------------------------------------------------
  2501                              <1> ; os_print_4hex -- Displays AX in hex format
  2502                              <1> ; IN: AX = number to format and print
  2503                              <1> 
  2504                              <1> os_print_4hex:
  2505 00002276 60                  <1> 	pusha
  2506                              <1> 
  2507 00002277 50                  <1> 	push ax				; Output high byte
  2508 00002278 88E0                <1> 	mov al, ah
  2509 0000227A E8EBFF              <1> 	call os_print_2hex
  2510                              <1> 
  2511 0000227D 58                  <1> 	pop ax				; Output low byte
  2512 0000227E E8E7FF              <1> 	call os_print_2hex
  2513                              <1> 
  2514 00002281 61                  <1> 	popa
  2515 00002282 C3                  <1> 	ret
  2516                              <1> 
  2517                              <1> 
  2518                              <1> ; ------------------------------------------------------------------
  2519                              <1> ; os_input_string -- Take string from keyboard entry
  2520                              <1> ; IN/OUT: AX = location of string, other regs preserved
  2521                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2522                              <1> 
  2523                              <1> os_input_string:
  2524 00002283 60                  <1> 	pusha
  2525                              <1> 
  2526 00002284 E8D5F6              <1> 	call os_show_cursor
  2527                              <1> 	
  2528 00002287 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2529 00002289 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2530                              <1> 
  2531                              <1> 
  2532                              <1> .more:					; Now onto string getting
  2533 0000228C E8A8F0              <1> 	call os_wait_for_key
  2534                              <1> 
  2535 0000228F 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2536 00002291 7455                <1> 	je .done
  2537                              <1> 
  2538 00002293 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2539 00002295 7406                <1> 	je .backspace			; If not, skip following checks
  2540                              <1> 
  2541 00002297 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 127)?
  2542 00002299 7CF1                <1> 	jl .more			; Ignore most non-printing characters
  2543                              <1> 
  2544 0000229B EB35                <1> 	jmp .nobackspace
  2545                              <1> 
  2546                              <1> 
  2547                              <1> .backspace:
  2548 0000229D 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2549 000022A0 74EA                <1> 	je .more			; Ignore it if so
  2550                              <1> 
  2551 000022A2 E88BF6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  2552 000022A5 80FA00              <1> 	cmp dl, 0
  2553 000022A8 7413                <1> 	je .backspace_linestart
  2554                              <1> 
  2555 000022AA 60                  <1> 	pusha
  2556 000022AB B8080E              <1> 	mov ax, 0E08h		; If not, write space and move cursor back
  2557 000022AE CD10                <1> 	int 10h				; Backspace twice, to clear space
  2558 000022B0 B020                <1> 	mov al, 32
  2559 000022B2 CD10                <1> 	int 10h
  2560 000022B4 B008                <1> 	mov al, 8
  2561 000022B6 CD10                <1> 	int 10h
  2562 000022B8 61                  <1> 	popa
  2563                              <1> 
  2564 000022B9 4F                  <1> 	dec di				; Character position will be overwritten by new
  2565                              <1> 						; character or terminator at end
  2566                              <1> 
  2567 000022BA 49                  <1> 	dec cx				; Step back counter
  2568                              <1> 
  2569 000022BB EBCF                <1> 	jmp .more
  2570                              <1> 
  2571                              <1> 
  2572                              <1> .backspace_linestart:
  2573 000022BD FECE                <1> 	dec dh				; Jump back to end of previous line
  2574 000022BF B24F                <1> 	mov dl, 79
  2575 000022C1 E863F6              <1> 	call os_move_cursor
  2576                              <1> 
  2577 000022C4 B8200E              <1> 	mov ax, 0E20h		; Print space there
  2578 000022C7 CD10                <1> 	int 10h
  2579                              <1> 
  2580 000022C9 B24F                <1> 	mov dl, 79			; And jump back before the space
  2581 000022CB E859F6              <1> 	call os_move_cursor
  2582                              <1> 
  2583 000022CE 4F                  <1> 	dec di				; Step back position in string
  2584 000022CF 49                  <1> 	dec cx				; Step back counter
  2585                              <1> 
  2586 000022D0 EBBA                <1> 	jmp .more
  2587                              <1> 
  2588                              <1> 
  2589                              <1> .nobackspace:
  2590 000022D2 0FB61E8800          <1> 	movzx bx, byte [0088h]
  2591 000022D7 39D9                <1> 	cmp cx, bx			; Make sure we don't exhaust buffer
  2592 000022D9 0F8DAFFF            <1> 	jge near .more
  2593                              <1> 
  2594 000022DD 60                  <1> 	pusha
  2595 000022DE B40E                <1> 	mov ah, 0Eh			; Output entered, printable character
  2596 000022E0 CD10                <1> 	int 10h
  2597 000022E2 61                  <1> 	popa
  2598                              <1> 
  2599 000022E3 AA                  <1> 	stosb				; Store character in designated buffer
  2600 000022E4 41                  <1> 	inc cx				; Characters processed += 1
  2601                              <1> 	
  2602 000022E5 E9A4FF              <1> 	jmp near .more			; Still room for more
  2603                              <1> 
  2604                              <1> .done:
  2605 000022E8 B000                <1> 	mov al, 0
  2606 000022EA AA                  <1> 	stosb
  2607                              <1> 
  2608 000022EB 61                  <1> 	popa
  2609 000022EC C3                  <1> 	ret
  2610                              <1> 
  2611                              <1> ; Input password(displays it as *s)
  2612                              <1> ; IN: AX = location of string, other regs preserved, BL = color
  2613                              <1> ; OUT: nothing
  2614                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2615                              <1> 
  2616                              <1> os_input_password:
  2617 000022ED 60                  <1> 	pusha
  2618                              <1> 
  2619 000022EE E83FF6              <1> 	call os_get_cursor_pos	; Store the cursor position
  2620 000022F1 8916[5E23]          <1> 	mov [.cursor], dx
  2621                              <1> 	
  2622 000022F5 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2623 000022F7 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2624                              <1> 
  2625                              <1> .more:					; Now onto string getting
  2626 000022FA E83AF0              <1> 	call os_wait_for_key
  2627                              <1> 
  2628 000022FD 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2629 000022FF 742E                <1> 	je .done
  2630                              <1> 
  2631 00002301 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2632 00002303 740A                <1> 	je .backspace			; If not, skip following checks
  2633                              <1> 
  2634 00002305 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 126)?
  2635 00002307 7D13                <1> 	jge .nobackspace	; Ignore most non-printing characters
  2636                              <1> 	
  2637 00002309 3C00                <1> 	cmp al, 0
  2638 0000230B 7C0F                <1> 	jl .nobackspace
  2639                              <1> 	
  2640 0000230D EBEB                <1> 	jmp .more
  2641                              <1> 
  2642                              <1> 
  2643                              <1> .backspace:
  2644 0000230F 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2645 00002312 74E6                <1> 	je .more			; Ignore it if so
  2646                              <1> 
  2647 00002314 4F                  <1> 	dec di				; Character position will be overwritten by new
  2648                              <1> 						; character or terminator at end
  2649                              <1> 
  2650 00002315 49                  <1> 	dec cx				; Step back counter
  2651                              <1> 
  2652 00002316 E81C00              <1> 	call .update
  2653                              <1> 	
  2654 00002319 E9DEFF              <1> 	jmp near .more
  2655                              <1> 
  2656                              <1> 
  2657                              <1> .nobackspace:
  2658 0000231C 0FB6168800          <1> 	movzx dx, byte [0088h]
  2659 00002321 39D1                <1> 	cmp cx, dx			; Make sure we don't exhaust buffer
  2660 00002323 0F8DD3FF            <1> 	jge near .more
  2661                              <1> 
  2662 00002327 AA                  <1> 	stosb				; Store character in designated buffer
  2663 00002328 41                  <1> 	inc cx				; Characters processed += 1
  2664                              <1> 
  2665 00002329 E80900              <1> 	call .update
  2666                              <1> 	
  2667 0000232C E9CBFF              <1> 	jmp near .more		; Still room for more
  2668                              <1> 
  2669                              <1> .done:
  2670 0000232F B000                <1> 	mov al, 0
  2671 00002331 AA                  <1> 	stosb
  2672                              <1> 
  2673 00002332 61                  <1> 	popa
  2674 00002333 F8                  <1> 	clc
  2675 00002334 C3                  <1> 	ret
  2676                              <1> 
  2677                              <1> .update:
  2678 00002335 60                  <1> 	pusha
  2679 00002336 8B16[5E23]          <1> 	mov dx, [.cursor]
  2680 0000233A E8EAF5              <1> 	call os_move_cursor
  2681 0000233D B82009              <1> 	mov ax, 0920h		; Clear the line
  2682 00002340 B700                <1> 	mov bh, 0
  2683 00002342 B92000              <1> 	mov cx, 32
  2684 00002345 CD10                <1> 	int 10h
  2685 00002347 61                  <1> 	popa
  2686                              <1> 
  2687 00002348 60                  <1> 	pusha
  2688 00002349 8B16[5E23]          <1> 	mov dx, [.cursor]
  2689 0000234D E8D7F5              <1> 	call os_move_cursor
  2690 00002350 B82A09              <1> 	mov ax, 092Ah		; Print *s(amount in CX)
  2691 00002353 B700                <1> 	mov bh, 0
  2692 00002355 CD10                <1> 	int 10h
  2693 00002357 00CA                <1> 	add dl, cl
  2694 00002359 E8CBF5              <1> 	call os_move_cursor
  2695 0000235C 61                  <1> 	popa
  2696 0000235D C3                  <1> 	ret
  2697                              <1> 	
  2698 0000235E 0000                <1> 	.cursor			dw 0
  2699                              <1> 	
  2700                              <1> ; Opens up os_list_dialog with color.
  2701                              <1> ; IN: nothing
  2702                              <1> ; OUT: color number(0-15)
  2703                              <1> 
  2704                              <1> os_color_selector:
  2705 00002360 60                  <1> 	pusha
  2706 00002361 B8[7623]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  2707 00002364 BB[F123]            <1> 	mov bx, .colormsg0
  2708 00002367 B9[0324]            <1> 	mov cx, .colormsg1
  2709 0000236A E808F9              <1> 	call os_list_dialog
  2710                              <1> 	
  2711 0000236D 48                  <1> 	dec ax						; Output from os_list_dialog starts with 1, so decrement it
  2712 0000236E A3[0424]            <1> 	mov [.tmp_word], ax
  2713 00002371 61                  <1> 	popa
  2714 00002372 A0[0424]            <1> 	mov al, [.tmp_word]
  2715 00002375 C3                  <1> 	ret
  2716                              <1> 	
  2717 00002376 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  2717 0000237F 652C477265656E2C43- <1>
  2717 00002388 79616E2C5265642C4D- <1>
  2717 00002391 6167656E74612C4272- <1>
  2717 0000239A 6F776E2C4C69676874- <1>
  2717 000023A3 20477261792C446172- <1>
  2717 000023AC 6B20477261792C4C69- <1>
  2717 000023B5 67687420426C75652C- <1>
  2717 000023BE 4C6967687420477265- <1>
  2717 000023C7 656E2C4C6967687420- <1>
  2717 000023D0 4379616E2C4C696768- <1>
  2717 000023D9 74205265642C50696E- <1>
  2717 000023E2 6B2C59656C6C6F772C- <1>
  2717 000023EB 576869746500        <1>
  2718 000023F1 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...', 0
  2718 000023FA 636F6C6F722E2E2E00  <1>
  2719 00002403 00                  <1> 	.colormsg1	db 0
  2720 00002404 0000                <1> 	.tmp_word	dw 0
  2721                              <1> 	
  2722                              <1> ; Displays EAX in hex format
  2723                              <1> ; IN: EAX = unsigned integer
  2724                              <1> ; OUT: nothing
  2725                              <1> os_print_8hex:
  2726 00002406 6660                <1> 	pushad
  2727 00002408 6660                <1> 	pushad
  2728 0000240A 66C1E810            <1> 	shr eax, 16
  2729 0000240E E865FE              <1> 	call os_print_4hex
  2730 00002411 6661                <1> 	popad
  2731 00002413 E860FE              <1> 	call os_print_4hex
  2732 00002416 6661                <1> 	popad
  2733 00002418 C3                  <1> 	ret
  2734                              <1> 	
  2735                              <1> ; Displays a dialog similar to os_dialog_box, but without the buttons.
  2736                              <1> ; IN: SI/AX/BX/CX/DX = string locations (or 0 for no display)
  2737                              <1> ; OUT: nothing
  2738                              <1> os_temp_box:
  2739 00002419 60                  <1> 	pusha
  2740                              <1> 
  2741 0000241A 52                  <1> 	push dx
  2742 0000241B 51                  <1> 	push cx
  2743 0000241C 53                  <1> 	push bx
  2744 0000241D 50                  <1> 	push ax
  2745 0000241E 56                  <1> 	push si
  2746                              <1> 	
  2747 0000241F E845F5              <1> 	call os_hide_cursor
  2748                              <1> 
  2749                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    18 00002422 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2750                              <1> 
  2751                              <1> .redbox:				; Loop to draw all lines of box
  2752 00002425 E8FFF4              <1> 	call os_move_cursor
  2753                              <1> 
  2754 00002428 60                  <1> 	pusha
  2755 00002429 B82009              <1> 	mov ax, 0920h
  2756 0000242C 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2757 00002431 B92A00              <1> 	mov cx, 42
  2758 00002434 CD10                <1> 	int 10h
  2759 00002436 61                  <1> 	popa
  2760                              <1> 
  2761 00002437 FEC6                <1> 	inc dh
  2762 00002439 80FE10              <1> 	cmp dh, 16
  2763 0000243C 7402                <1> 	je .boxdone
  2764 0000243E EBE5                <1> 	jmp .redbox
  2765                              <1> 
  2766                              <1> 
  2767                              <1> .boxdone:
  2768                              <1> 	mov16 dx, 20, 9
    18 00002440 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2769 00002443 B90500              <1> 	mov cx, 5
  2770                              <1> 
  2771                              <1> .loop:
  2772 00002446 FEC6                <1> 	inc dh
  2773 00002448 E8DCF4              <1> 	call os_move_cursor
  2774                              <1> 
  2775 0000244B 5E                  <1> 	pop si
  2776 0000244C 83FE00              <1> 	cmp si, 0			; Skip string params if zero
  2777 0000244F 7403                <1> 	je .no_string
  2778                              <1> 
  2779 00002451 E862F4              <1> 	call os_print_string
  2780                              <1> 
  2781                              <1> .no_string:
  2782 00002454 E2F0                <1> 	loop .loop
  2783 00002456 61                  <1> 	popa
  2784 00002457 C3                  <1> 	ret
  2785                              <1> 
  2786                              <1> ; Prints a message on the footer.
  2787                              <1> ; IN: SI = Message location(if 0, then it restores the previous message)
  2788                              <1> ; OUT: nothing
  2789                              <1> os_print_footer:
  2790 00002458 60                  <1> 	pusha
  2791 00002459 A08200              <1> 	mov al, [0082h]
  2792 0000245C 3C01                <1> 	cmp al, 1
  2793 0000245E 0F844700            <1> 	je near .exit
  2794                              <1> 	
  2795 00002462 E8CBF4              <1> 	call os_get_cursor_pos
  2796 00002465 52                  <1> 	push dx
  2797                              <1> 	
  2798 00002466 BF0100              <1> 	mov di, 1
  2799 00002469 83FE00              <1> 	cmp si, 0
  2800 0000246C 0F843B00            <1> 	je near .restore
  2801                              <1> 	
  2802                              <1> 	mov16 dx, 0, 24
    18 00002470 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2803                              <1> 	
  2804                              <1> .loop:
  2805 00002473 E8B1F4              <1> 	call os_move_cursor
  2806                              <1> 	
  2807 00002476 B408                <1> 	mov ah, 08h
  2808 00002478 B700                <1> 	mov bh, 0
  2809 0000247A CD10                <1> 	int 10h
  2810                              <1> 	
  2811 0000247C AA                  <1> 	stosb
  2812                              <1> 	
  2813 0000247D FEC2                <1> 	inc dl
  2814 0000247F 83FF51              <1> 	cmp di, 81
  2815 00002482 0F8CEDFF            <1> 	jnge near .loop
  2816                              <1> 	
  2817 00002486 C606500000          <1> 	mov byte [80], 0
  2818                              <1> 	
  2819                              <1> 	mov16 dx, 0, 24
    18 0000248B BA0018              <2>  mov %1, (%2 + %3 * 256)
  2820 0000248E E896F4              <1> 	call os_move_cursor
  2821                              <1> 	
  2822 00002491 B82009              <1> 	mov ax, 0920h
  2823 00002494 BB7000              <1> 	mov bx, 70h
  2824 00002497 B95000              <1> 	mov cx, 80
  2825 0000249A CD10                <1> 	int 10h
  2826                              <1> 	
  2827                              <1> 	mov16 dx, 0, 24
    18 0000249C BA0018              <2>  mov %1, (%2 + %3 * 256)
  2828 0000249F E885F4              <1> 	call os_move_cursor
  2829                              <1> 	
  2830 000024A2 E811F4              <1> 	call os_print_string
  2831                              <1> 	
  2832 000024A5 5A                  <1> 	pop dx
  2833 000024A6 E87EF4              <1> 	call os_move_cursor
  2834                              <1> 
  2835                              <1> .exit:	
  2836 000024A9 61                  <1> 	popa
  2837 000024AA C3                  <1> 	ret
  2838                              <1> 	
  2839                              <1> .restore:
  2840                              <1> 	mov16 dx, 0, 24
    18 000024AB BA0018              <2>  mov %1, (%2 + %3 * 256)
  2841 000024AE E876F4              <1> 	call os_move_cursor
  2842 000024B1 BE0100              <1> 	mov si, 1
  2843 000024B4 E8FFF3              <1> 	call os_print_string
  2844                              <1> 	
  2845 000024B7 5A                  <1> 	pop dx
  2846 000024B8 E86CF4              <1> 	call os_move_cursor
  2847                              <1> 	
  2848 000024BB 61                  <1> 	popa
  2849 000024BC C3                  <1> 	ret
  2850                              <1> 	
  2851                              <1> ; Resets the font to the selected default.
  2852                              <1> ; IN = nothing
  2853                              <1> ; OUT = nothing
  2854                              <1> os_reset_font:
  2855 000024BD 60                  <1> 	pusha
  2856                              <1> 	
  2857 000024BE 803EF1DE01          <1> 	cmp byte [57073], 1
  2858 000024C3 0F841800            <1> 	je near .bios
  2859                              <1> 	
  2860 000024C7 06                  <1> 	push es
  2861 000024C8 B80011              <1> 	mov ax, 1100h
  2862 000024CB BB0010              <1> 	mov bx, 1000h
  2863 000024CE B90001              <1> 	mov cx, 0100h
  2864                              <1> 	clr dx
    14 000024D1 31D2                <2>  xor %1, %1
  2865 000024D3 8E06[9405]          <1> 	mov es, [driversgmt]
  2866 000024D7 BD0016              <1> 	mov bp, SYSTEM_FONT
  2867 000024DA CD10                <1> 	int 10h
  2868 000024DC 07                  <1> 	pop es
  2869 000024DD 61                  <1> 	popa
  2870 000024DE C3                  <1> 	ret
  2871                              <1> 	
  2872                              <1> .bios:
  2873 000024DF 61                  <1> 	popa
  2874 000024E0 C3                  <1> 	ret
  2875                              <1> 
  2876                              <1> ; Draws the MichalOS logo.
  2877                              <1> ; IN: nothing
  2878                              <1> ; OUT: a very beautiful logo :-)
  2879                              <1> os_draw_logo:
  2880 000024E1 60                  <1> 	pusha
  2881                              <1> 	
  2882                              <1> 	mov16 dx, 0, 2
    18 000024E2 BA0002              <2>  mov %1, (%2 + %3 * 256)
  2883 000024E5 E83FF4              <1> 	call os_move_cursor
  2884                              <1> 
  2885 000024E8 B82009              <1> 	mov ax, 0920h
  2886 000024EB BB0400              <1> 	mov bx, 00000100b
  2887 000024EE B93002              <1> 	mov cx, 560
  2888 000024F1 CD10                <1> 	int 10h
  2889                              <1> 
  2890 000024F3 BE[260A]            <1> 	mov si, logo
  2891 000024F6 E80200              <1> 	call os_draw_icon
  2892 000024F9 61                  <1> 	popa
  2893 000024FA C3                  <1> 	ret
  2894                              <1> 
  2895                              <1> ; Draws an icon (in the MichalOS format).
  2896                              <1> ; IN: SI = address of the icon
  2897                              <1> ; OUT: nothing
  2898                              <1> os_draw_icon:
  2899 000024FB 60                  <1> 	pusha
  2900                              <1> 	
  2901 000024FC E831F4              <1> 	call os_get_cursor_pos
  2902 000024FF 8916[6825]          <1> 	mov [.cursor], dx
  2903                              <1> 	
  2904 00002503 AD                  <1> 	lodsw
  2905 00002504 A3[6E25]            <1> 	mov [.size], ax
  2906                              <1> 	
  2907                              <1> 	clr cx
    14 00002507 31C9                <2>  xor %1, %1
  2908                              <1> 	
  2909                              <1> .loop:
  2910 00002509 AC                  <1> 	lodsb
  2911                              <1> 	
  2912 0000250A B40E                <1> 	mov ah, 0Eh
  2913                              <1> 	
  2914 0000250C 51                  <1> 	push cx
  2915 0000250D 88C1                <1> 	mov cl, al
  2916 0000250F 0FB6D9              <1> 	movzx bx, cl
  2917 00002512 80E3C0              <1> 	and bl, 11000000b
  2918 00002515 C0EB06              <1> 	shr bl, 6
  2919 00002518 8A87[6A25]          <1> 	mov al, [.chars + bx]
  2920 0000251C CD10                <1> 	int 10h
  2921                              <1> 	
  2922 0000251E 0FB6D9              <1> 	movzx bx, cl
  2923 00002521 80E330              <1> 	and bl, 110000b
  2924 00002524 C0EB04              <1> 	shr bl, 4
  2925 00002527 8A87[6A25]          <1> 	mov al, [.chars + bx]
  2926 0000252B CD10                <1> 	int 10h
  2927                              <1> 	
  2928 0000252D 0FB6D9              <1> 	movzx bx, cl
  2929 00002530 80E30C              <1> 	and bl, 1100b
  2930 00002533 C0EB02              <1> 	shr bl, 2
  2931 00002536 8A87[6A25]          <1> 	mov al, [.chars + bx]
  2932 0000253A CD10                <1> 	int 10h
  2933                              <1> 	
  2934 0000253C 0FB6D9              <1> 	movzx bx, cl
  2935 0000253F 80E303              <1> 	and bl, 11b
  2936 00002542 8A87[6A25]          <1> 	mov al, [.chars + bx]
  2937 00002546 CD10                <1> 	int 10h
  2938 00002548 59                  <1> 	pop cx
  2939                              <1> 	
  2940 00002549 FEC1                <1> 	inc cl
  2941 0000254B 3A0E[6E25]          <1> 	cmp cl, [.size]
  2942 0000254F 75B8                <1> 	jne .loop
  2943                              <1> 
  2944 00002551 FE06[6925]          <1> 	inc byte [.cursor + 1]
  2945 00002555 8B16[6825]          <1> 	mov dx, [.cursor]
  2946 00002559 E8CBF3              <1> 	call os_move_cursor
  2947                              <1> 	
  2948 0000255C B100                <1> 	mov cl, 0
  2949 0000255E FEC5                <1> 	inc ch
  2950 00002560 3A2E[6F25]          <1> 	cmp ch, [.size + 1]
  2951 00002564 75A3                <1> 	jne .loop
  2952                              <1> 	
  2953 00002566 61                  <1> 	popa
  2954 00002567 C3                  <1> 	ret
  2955                              <1> 
  2956 00002568 0000                <1> 	.cursor		dw 0
  2957 0000256A 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2958 0000256E 0000                <1> 	.size		dw 0
  2959                              <1> 	
  2960                              <1> ; ------------------------------------------------------------------
  2961                              <1> ; os_option_menu -- Show a menu with a list of options
  2962                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated), BX = menu width
  2963                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2964                              <1> 
  2965                              <1> os_option_menu:
  2966 00002570 60                  <1> 	pusha
  2967                              <1> 
  2968 00002571 803EEFDE00          <1> 	cmp byte [57071], 0
  2969 00002576 741C                <1> 	je .skip
  2970                              <1> 	
  2971                              <1> 	mov16 dx, 0, 1
    18 00002578 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2972                              <1> 
  2973 0000257B E8A9F3              <1> 	call os_move_cursor
  2974                              <1> 	
  2975 0000257E B408                <1> 	mov ah, 08h
  2976 00002580 B700                <1> 	mov bh, 0
  2977 00002582 CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2978                              <1> 	
  2979 00002584 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2980                              <1> 	
  2981 00002587 0FB6DC              <1> 	movzx bx, ah
  2982 0000258A B8B109              <1> 	mov ax, 09B1h
  2983 0000258D B93007              <1> 	mov cx, 1840
  2984 00002590 CD10                <1> 	int 10h
  2985                              <1> 	
  2986 00002592 61                  <1> 	popa
  2987 00002593 60                  <1> 	pusha
  2988                              <1> 
  2989                              <1> .skip:
  2990 00002594 891E[1127]          <1> 	mov [.width], bx
  2991                              <1> 
  2992 00002598 50                  <1> 	push ax				; Store string list for now
  2993                              <1> 
  2994 00002599 E8CBF3              <1> 	call os_hide_cursor
  2995                              <1> 
  2996 0000259C B100                <1> 	mov cl, 0			; Count the number of entries in the list
  2997 0000259E 89C6                <1> 	mov si, ax
  2998                              <1> 	
  2999                              <1> .count_loop:
  3000 000025A0 AC                  <1> 	lodsb
  3001 000025A1 3C00                <1> 	cmp al, 0
  3002 000025A3 7408                <1> 	je .done_count
  3003 000025A5 3C2C                <1> 	cmp al, ','
  3004 000025A7 75F7                <1> 	jne .count_loop
  3005 000025A9 FEC1                <1> 	inc cl
  3006 000025AB EBF3                <1> 	jmp .count_loop
  3007                              <1> 
  3008                              <1> .done_count:
  3009 000025AD FEC1                <1> 	inc cl
  3010 000025AF 880E[0D27]          <1> 	mov byte [.num_of_entries], cl
  3011                              <1> 
  3012                              <1> 
  3013 000025B3 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  3014 000025B4 8936[0F27]          <1> 	mov word [.list_string], si
  3015                              <1> 
  3016                              <1> 
  3017                              <1> 	; Now that we've drawn the list, highlight the currently selected
  3018                              <1> 	; entry and let the user move up and down using the cursor keys
  3019                              <1> 
  3020 000025B8 C606[0E27]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  3021                              <1> 
  3022                              <1> 	mov16 dx, 25, 2			; Set up starting position for selector
    18 000025BD BA1902              <2>  mov %1, (%2 + %3 * 256)
  3023                              <1> 
  3024 000025C0 E864F3              <1> 	call os_move_cursor
  3025                              <1> 
  3026                              <1> .more_select:
  3027 000025C3 60                  <1> 	pusha
  3028 000025C4 8A1EF0DE            <1> 	mov bl, [57072]		; Black on white for option list box
  3029                              <1> 	mov16 dx, 1, 1
    18 000025C8 BA0101              <2>  mov %1, (%2 + %3 * 256)
  3030                              <1> 
  3031 000025CB 8B36[1127]          <1> 	mov si, [.width]
  3032 000025CF 0FB63E[0D27]        <1> 	movzx di, [.num_of_entries]
  3033 000025D4 83C703              <1> 	add di, 3
  3034 000025D7 E897F3              <1> 	call os_draw_block
  3035 000025DA 61                  <1> 	popa
  3036                              <1> 
  3037 000025DB E8FD00              <1> 	call .draw_black_bar
  3038                              <1> 
  3039 000025DE 8B36[0F27]          <1> 	mov word si, [.list_string]
  3040 000025E2 E8B300              <1> 	call .draw_list
  3041                              <1> 
  3042                              <1> .another_key:
  3043 000025E5 E84FED              <1> 	call os_wait_for_key		; Move / select option
  3044 000025E8 3C6A                <1> 	cmp al, 'j'
  3045 000025EA 743D                <1> 	je .go_down
  3046 000025EC 3C6B                <1> 	cmp al, 'k'
  3047 000025EE 7428                <1> 	je .go_up
  3048 000025F0 3C6C                <1> 	cmp al, 'l'
  3049 000025F2 746F                <1> 	je .option_selected
  3050 000025F4 3C68                <1> 	cmp al, 'h'
  3051 000025F6 0F848300            <1> 	je .esc_pressed
  3052                              <1> 
  3053 000025FA 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  3054 000025FD 7419                <1> 	je .go_up
  3055 000025FF 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  3056 00002602 7425                <1> 	je .go_down
  3057 00002604 3C0D                <1> 	cmp al, 13			; Enter pressed?
  3058 00002606 745B                <1> 	je .option_selected
  3059 00002608 3C1B                <1> 	cmp al, 27			; Esc pressed?
  3060 0000260A 7471                <1> 	je .esc_pressed
  3061 0000260C 80FC4B              <1> 	cmp ah, 75			; Left pressed?
  3062 0000260F 7475                <1> 	je .left_pressed
  3063 00002611 80FC4D              <1> 	cmp ah, 77			; Right pressed?
  3064 00002614 7479                <1> 	je .right_pressed
  3065 00002616 EBCD                <1> 	jmp .another_key		; If not, wait for another key
  3066                              <1> 
  3067                              <1> 
  3068                              <1> .go_up:
  3069 00002618 80FE02              <1> 	cmp dh, 2			; Already at top?
  3070 0000261B 7E38                <1> 	jle .hit_top
  3071                              <1> 
  3072 0000261D E8D200              <1> 	call .draw_white_bar
  3073                              <1> 
  3074 00002620 B219                <1> 	mov dl, 25
  3075 00002622 E802F3              <1> 	call os_move_cursor
  3076                              <1> 
  3077 00002625 FECE                <1> 	dec dh				; Row to select (increasing down)
  3078 00002627 EB9A                <1> 	jmp .more_select
  3079                              <1> 
  3080                              <1> 
  3081                              <1> .go_down:				; Already at bottom of list?
  3082 00002629 8A1E[0D27]          <1> 	mov bl, [.num_of_entries]
  3083 0000262D FEC3                <1> 	inc bl
  3084 0000262F 38DE                <1> 	cmp dh, bl
  3085 00002631 742B                <1> 	je .hit_bottom
  3086                              <1> 
  3087 00002633 B90000              <1> 	mov cx, 0
  3088 00002636 88F1                <1> 	mov byte cl, dh
  3089                              <1> 
  3090 00002638 80E906              <1> 	sub cl, 6
  3091 0000263B FEC1                <1> 	inc cl
  3092 0000263D 020E[0E27]          <1> 	add byte cl, [.skip_num]
  3093                              <1> 
  3094 00002641 A0[0D27]            <1> 	mov byte al, [.num_of_entries]
  3095 00002644 38C1                <1> 	cmp cl, al
  3096 00002646 749D                <1> 	je .another_key
  3097                              <1> 
  3098 00002648 E8A700              <1> 	call .draw_white_bar
  3099                              <1> 
  3100 0000264B B219                <1> 	mov dl, 25
  3101 0000264D E8D7F2              <1> 	call os_move_cursor
  3102                              <1> 
  3103 00002650 FEC6                <1> 	inc dh
  3104 00002652 E96EFF              <1> 	jmp .more_select
  3105                              <1> 
  3106                              <1> 
  3107                              <1> .hit_top:
  3108 00002655 B601                <1> 	mov dh, 1
  3109 00002657 0236[0D27]          <1> 	add dh, [.num_of_entries]
  3110 0000265B E965FF              <1> 	jmp .more_select
  3111                              <1> 
  3112                              <1> 
  3113                              <1> .hit_bottom:
  3114 0000265E B602                <1> 	mov dh, 2
  3115 00002660 E960FF              <1> 	jmp .more_select
  3116                              <1> 
  3117                              <1> 
  3118                              <1> 
  3119                              <1> .option_selected:
  3120 00002663 E8F6F2              <1> 	call os_show_cursor
  3121                              <1> 
  3122 00002666 80EE02              <1> 	sub dh, 2
  3123                              <1> 
  3124 00002669 B80000              <1> 	mov ax, 0
  3125 0000266C 88F0                <1> 	mov al, dh
  3126                              <1> 
  3127 0000266E FEC0                <1> 	inc al				; Options start from 1
  3128 00002670 0206[0E27]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  3129                              <1> 
  3130 00002674 A3[0B27]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  3131                              <1> 
  3132 00002677 61                  <1> 	popa
  3133                              <1> 
  3134 00002678 A1[0B27]            <1> 	mov word ax, [.tmp]
  3135 0000267B F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  3136 0000267C C3                  <1> 	ret
  3137                              <1> 
  3138                              <1> 
  3139                              <1> 
  3140                              <1> .esc_pressed:
  3141 0000267D E8DCF2              <1> 	call os_show_cursor
  3142 00002680 61                  <1> 	popa
  3143 00002681 B80000              <1> 	mov ax, 0
  3144 00002684 F9                  <1> 	stc
  3145 00002685 C3                  <1> 	ret
  3146                              <1> 
  3147                              <1> .left_pressed:
  3148 00002686 E8D3F2              <1> 	call os_show_cursor
  3149 00002689 61                  <1> 	popa
  3150 0000268A B80100              <1> 	mov ax, 1
  3151 0000268D F9                  <1> 	stc
  3152 0000268E C3                  <1> 	ret
  3153                              <1> 
  3154                              <1> .right_pressed:
  3155 0000268F E8CAF2              <1> 	call os_show_cursor
  3156 00002692 61                  <1> 	popa
  3157 00002693 B80200              <1> 	mov ax, 2
  3158 00002696 F9                  <1> 	stc
  3159 00002697 C3                  <1> 	ret
  3160                              <1> 
  3161                              <1> .draw_list:
  3162 00002698 60                  <1> 	pusha
  3163                              <1> 
  3164                              <1> 	mov16 dx, 3, 2			; Get into position for option list text
    18 00002699 BA0302              <2>  mov %1, (%2 + %3 * 256)
  3165 0000269C E888F2              <1> 	call os_move_cursor
  3166                              <1> 
  3167                              <1> 
  3168 0000269F B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  3169 000026A2 8A0E[0E27]          <1> 	mov byte cl, [.skip_num]
  3170                              <1> 
  3171                              <1> .skip_loop:
  3172 000026A6 83F900              <1> 	cmp cx, 0
  3173 000026A9 7408                <1> 	je .skip_loop_finished
  3174                              <1> 	
  3175                              <1> .more_lodsb:
  3176 000026AB AC                  <1> 	lodsb
  3177 000026AC 3C2C                <1> 	cmp al, ','
  3178 000026AE 75FB                <1> 	jne .more_lodsb
  3179 000026B0 49                  <1> 	dec cx
  3180 000026B1 EBF3                <1> 	jmp .skip_loop
  3181                              <1> 
  3182                              <1> 
  3183                              <1> .skip_loop_finished:
  3184 000026B3 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  3185                              <1> 
  3186                              <1> 
  3187                              <1> .more:
  3188 000026B6 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  3189                              <1> 
  3190 000026B7 3C00                <1> 	cmp al, 0			; End of string?
  3191 000026B9 741B                <1> 	je .done_list
  3192                              <1> 
  3193 000026BB 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  3194 000026BD 7406                <1> 	je .newline
  3195                              <1> 
  3196 000026BF B40E                <1> 	mov ah, 0Eh
  3197 000026C1 CD10                <1> 	int 10h
  3198 000026C3 EBF1                <1> 	jmp .more
  3199                              <1> 
  3200                              <1> .newline:
  3201 000026C5 B203                <1> 	mov dl, 3			; Go back to starting X position
  3202 000026C7 FEC6                <1> 	inc dh				; But jump down a line
  3203 000026C9 E85BF2              <1> 	call os_move_cursor
  3204                              <1> 
  3205 000026CC 43                  <1> 	inc bx				; Update the number-of-options counter
  3206 000026CD 0FB63E[0D27]        <1> 	movzx di, [.num_of_entries]	; Low 8 bits of DI = [.items], high 8 bits = 0
  3207 000026D2 39FB                <1> 	cmp bx, di			; Limit to one screen of options
  3208 000026D4 7CE0                <1> 	jl .more
  3209                              <1> 
  3210                              <1> .done_list:
  3211 000026D6 61                  <1> 	popa
  3212 000026D7 E84DF2              <1> 	call os_move_cursor
  3213                              <1> 
  3214 000026DA C3                  <1> 	ret
  3215                              <1> 
  3216                              <1> 
  3217                              <1> 
  3218                              <1> .draw_black_bar:
  3219 000026DB 60                  <1> 	pusha
  3220                              <1> 
  3221 000026DC B202                <1> 	mov dl, 2
  3222 000026DE E846F2              <1> 	call os_move_cursor
  3223                              <1> 
  3224 000026E1 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3225 000026E4 8B0E[1127]          <1> 	mov cx, [.width]
  3226 000026E8 83E902              <1> 	sub cx, 2
  3227 000026EB BB0F00              <1> 	mov bx, 00001111b		; White text on black background
  3228 000026EE CD10                <1> 	int 10h
  3229                              <1> 
  3230 000026F0 61                  <1> 	popa
  3231 000026F1 C3                  <1> 	ret
  3232                              <1> 
  3233                              <1> .draw_white_bar:
  3234 000026F2 60                  <1> 	pusha
  3235                              <1> 
  3236 000026F3 B202                <1> 	mov dl, 2
  3237 000026F5 E82FF2              <1> 	call os_move_cursor
  3238                              <1> 
  3239 000026F8 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3240 000026FB 8B0E[1127]          <1> 	mov cx, [.width]
  3241 000026FF 83E902              <1> 	sub cx, 2
  3242 00002702 0FB61EF0DE          <1> 	movzx bx, byte [57072]	; Black text on white background
  3243 00002707 CD10                <1> 	int 10h
  3244                              <1> 
  3245 00002709 61                  <1> 	popa
  3246 0000270A C3                  <1> 	ret
  3247                              <1> 
  3248 0000270B 0000                <1> 	.tmp					dw 0
  3249 0000270D 00                  <1> 	.num_of_entries			db 0
  3250 0000270E 00                  <1> 	.skip_num				db 0
  3251 0000270F 0000                <1> 	.list_string			dw 0
  3252 00002711 0000                <1> 	.width					dw 0
  3253                              <1> 	
  3254                              <1> ; ==================================================================
   820                                  	%INCLUDE "features/sound.asm"
   821                              <1> ; ==================================================================
   822                              <1> ; PC SPEAKER/ADLIB SOUND ROUTINES
   823                              <1> ; ==================================================================
   824                              <1> 
   825                              <1> ; ------------------------------------------------------------------
   826                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
   827                              <1> ; IN: AX = note frequency; OUT: Nothing (registers preserved)
   828                              <1> 
   829                              <1> os_speaker_tone:
   830 00002713 60                  <1> 	pusha
   831 00002714 803E830000          <1> 	cmp byte [0083h], 0
   832 00002719 0F842600            <1> 	je near .exit
   833 0000271D 61                  <1> 	popa
   834                              <1> 	
   835 0000271E 60                  <1> 	pusha
   836 0000271F 83F800              <1> 	cmp ax, 0
   837 00002722 0F841D00            <1> 	je near .exit
   838                              <1> 	
   839 00002726 E82A00              <1> 	call os_speaker_off
   840 00002729 89C1                <1> 	mov cx, ax			; Store note value for now
   841                              <1> 
   842 0000272B B0B6                <1> 	mov al, 10110110b
   843 0000272D E643                <1> 	out 43h, al
   844 0000272F BA1200              <1> 	mov dx, 12h			; Set up frequency
   845 00002732 B8DC34              <1> 	mov ax, 34DCh
   846 00002735 F7F1                <1> 	div cx
   847 00002737 E642                <1> 	out 42h, al
   848 00002739 88E0                <1> 	mov al, ah
   849 0000273B E642                <1> 	out 42h, al
   850                              <1> 
   851 0000273D E461                <1> 	in al, 61h			; Switch PC speaker on
   852 0000273F 0C03                <1> 	or al, 03h
   853 00002741 E661                <1> 	out 61h, al
   854                              <1> 
   855                              <1> .exit:
   856 00002743 61                  <1> 	popa
   857 00002744 C3                  <1> 	ret
   858                              <1> 
   859                              <1> ; ------------------------------------------------------------------
   860                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
   861                              <1> ; IN: AX = note frequency, CX = length (in ticks)
   862                              <1> 
   863                              <1> os_speaker_note_length:
   864 00002745 60                  <1> 	pusha
   865 00002746 E8CAFF              <1> 	call os_speaker_tone
   866                              <1> 	
   867 00002749 89C8                <1> 	mov ax, cx
   868 0000274B E83BEE              <1> 	call os_pause
   869                              <1> 	
   870 0000274E E80200              <1> 	call os_speaker_off
   871 00002751 61                  <1> 	popa
   872 00002752 C3                  <1> 	ret
   873                              <1> 
   874                              <1> ; ------------------------------------------------------------------
   875                              <1> ; os_speaker_off -- Turn off PC speaker
   876                              <1> ; IN/OUT: Nothing (registers preserved)
   877                              <1> 
   878                              <1> os_speaker_off:
   879 00002753 60                  <1> 	pusha
   880                              <1> 
   881 00002754 E461                <1> 	in al, 61h
   882 00002756 24FC                <1> 	and al, 0FCh
   883 00002758 E661                <1> 	out 61h, al
   884                              <1> 
   885 0000275A 61                  <1> 	popa
   886 0000275B C3                  <1> 	ret
   887                              <1> 
   888                              <1> ; ------------------------------------------------------------------
   889                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   890                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   891                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   892                              <1> ; Common prescaler values:
   893                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   894                              <1> ;		663 = ~50 Hz (49.991 Hz)
   895                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   896                              <1> 
   897                              <1> os_start_adlib:
   898 0000275C 60                  <1> 	pusha
   899 0000275D C606[3229]01        <1> 	mov byte [adlib_running], 1
   900                              <1> 
   901 00002762 803EEEDE01          <1> 	cmp byte [57070], 1
   902 00002767 7D16                <1> 	jge .pcspk
   903                              <1> 	
   904 00002769 B80000              <1> 	mov ax, 0
   905                              <1> 	
   906                              <1> .loop:
   907 0000276C E8C700              <1> 	call int_adlib_regwrite
   908 0000276F FEC4                <1> 	inc ah
   909 00002771 75F9                <1> 	jnz .loop
   910                              <1> 	
   911 00002773 B82400              <1> 	mov ax, 36
   912 00002776 F7E1                <1> 	mul cx
   913                              <1> 	
   914 00002778 89C1                <1> 	mov cx, ax
   915 0000277A E81421              <1> 	call os_attach_app_timer
   916                              <1> 	
   917 0000277D 61                  <1> 	popa
   918 0000277E C3                  <1> 	ret
   919                              <1> 	
   920                              <1> .pcspk:
   921 0000277F B82400              <1> 	mov ax, 36
   922 00002782 F6F3                <1> 	div bl
   923                              <1> 	
   924 00002784 A2[CD29]            <1> 	mov [pwm_channel_amplitude], al
   925                              <1> 
   926 00002787 8936[C629]          <1> 	mov [pwm_callback], si
   927 0000278B 890E[C829]          <1> 	mov [pwm_callback_ctr], cx
   928 0000278F 890E[CA29]          <1> 	mov [pwm_callback_ctr_def], cx
   929                              <1> 
   930                              <1> 	; Set up the PC speaker
   931 00002793 E461                <1> 	in al, 0x61
   932 00002795 0C03                <1> 	or al, 3
   933 00002797 E661                <1> 	out 0x61, al
   934                              <1> 
   935                              <1> 	; Enable the callback
   936 00002799 BE[3329]            <1> 	mov si, pwm_handler
   937 0000279C 8CCF                <1> 	mov di, cs
   938 0000279E B11C                <1> 	mov cl, 01Ch
   939 000027A0 E8A820              <1> 	call os_modify_int_handler
   940                              <1> 
   941 000027A3 B92400              <1> 	mov cx, 36
   942 000027A6 E80F21              <1> 	call os_set_timer_speed
   943                              <1> 	
   944 000027A9 61                  <1> 	popa
   945 000027AA C3                  <1> 	ret
   946                              <1> 	
   947                              <1> ; ------------------------------------------------------------------
   948                              <1> ; os_stop_adlib -- Stops the Adlib driver
   949                              <1> 
   950                              <1> os_stop_adlib:
   951 000027AB 60                  <1> 	pusha
   952 000027AC 803EEEDE01          <1> 	cmp byte [57070], 1
   953 000027B1 7D1D                <1> 	jge .pcspk
   954                              <1> 	
   955 000027B3 E8EA20              <1> 	call os_return_app_timer
   956                              <1> 
   957 000027B6 B400                <1> 	mov ah, 0
   958                              <1> 	
   959                              <1> .loop:
   960 000027B8 0FB6DC              <1> 	movzx bx, ah
   961 000027BB C1EB05              <1> 	shr bx, 5
   962 000027BE 8A87[F327]          <1> 	mov al, [adlib_clear_regs + bx]
   963                              <1> 
   964 000027C2 E87100              <1> 	call int_adlib_regwrite
   965                              <1> 	
   966 000027C5 FEC4                <1> 	inc ah
   967 000027C7 75EF                <1> 	jnz .loop
   968                              <1> 	
   969 000027C9 C606[3229]00        <1> 	mov byte [adlib_running], 0
   970 000027CE 61                  <1> 	popa
   971 000027CF C3                  <1> 	ret
   972                              <1> 	
   973                              <1> .pcspk:
   974                              <1> 	; Turn off the PC speaker
   975 000027D0 E461                <1> 	in al, 0x61
   976 000027D2 24FC                <1> 	and al, 0xfc
   977 000027D4 E661                <1> 	out 0x61, al
   978                              <1> 
   979 000027D6 B90000              <1> 	mov cx, 0
   980 000027D9 E8DC20              <1> 	call os_set_timer_speed
   981                              <1> 	
   982                              <1> 	; Reset the RTC handler
   983 000027DC B11C                <1> 	mov cl, 1Ch
   984 000027DE BE[6149]            <1> 	mov si, os_compat_int1C
   985 000027E1 8CCF                <1> 	mov di, cs
   986 000027E3 E86520              <1> 	call os_modify_int_handler
   987                              <1> 	
   988                              <1> 	; Turn off all of the channels
   989 000027E6 B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   990 000027E9 BF[A129]            <1> 	mov di, pwm_freq
   991 000027EC B80000              <1> 	mov ax, 0
   992 000027EF F3AB                <1> 	rep stosw
   993                              <1> 	
   994 000027F1 61                  <1> 	popa
   995 000027F2 C3                  <1> 	ret
   996                              <1> 	
   997                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   998 000027F3 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   999                              <1> 	
  1000                              <1> ; ------------------------------------------------------------------
  1001                              <1> ; os_check_adlib -- Checks if YM3812 is present in the system
  1002                              <1> ; OUT: CF clear if YM3812 is present
  1003                              <1> 
  1004                              <1> os_check_adlib:
  1005 000027FB 60                  <1> 	pusha
  1006 000027FC 803EEEDE01          <1> 	cmp byte [57070], 1
  1007 00002801 7D14                <1> 	jge .ok
  1008                              <1> 
  1009 00002803 B86004              <1> 	mov ax, 0460h
  1010 00002806 E82D00              <1> 	call int_adlib_regwrite
  1011                              <1> 	
  1012 00002809 B88004              <1> 	mov ax, 0480h
  1013 0000280C E82700              <1> 	call int_adlib_regwrite
  1014                              <1> 	
  1015 0000280F BA8803              <1> 	mov dx, 388h
  1016 00002812 EC                  <1> 	in al, dx
  1017 00002813 3C00                <1> 	cmp al, 0
  1018 00002815 7503                <1> 	jne .error
  1019                              <1> 	
  1020                              <1> .ok:
  1021 00002817 61                  <1> 	popa
  1022 00002818 F8                  <1> 	clc
  1023 00002819 C3                  <1> 	ret
  1024                              <1> 	
  1025                              <1> .error:
  1026 0000281A 61                  <1> 	popa
  1027 0000281B F9                  <1> 	stc
  1028 0000281C C3                  <1> 	ret
  1029                              <1> 	
  1030                              <1> ; ------------------------------------------------------------------
  1031                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
  1032                              <1> ; IN: AH/AL - register address/value to write
  1033                              <1> 
  1034                              <1> os_adlib_regwrite:
  1035 0000281D 60                  <1> 	pusha
  1036                              <1> 	
  1037 0000281E 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1038 00002821 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
  1039                              <1> 	
  1040 00002826 E80D00              <1> 	call int_adlib_regwrite
  1041                              <1> 	
  1042 00002829 61                  <1> 	popa
  1043 0000282A C3                  <1> 	ret
  1044                              <1> 	
  1045                              <1> ; ------------------------------------------------------------------
  1046                              <1> ; os_adlib_regread -- Read from a YM3812 register
  1047                              <1> ; IN: AH - register address; OUT: AL - value
  1048                              <1> 
  1049                              <1> os_adlib_regread:
  1050 0000282B 53                  <1> 	push bx
  1051                              <1> 	
  1052 0000282C 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1053 0000282F 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
  1054                              <1> 	
  1055 00002834 5B                  <1> 	pop bx
  1056 00002835 C3                  <1> 	ret
  1057                              <1> 	
  1058                              <1> ; ------------------------------------------------------------------
  1059                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
  1060                              <1> ; IN: AH/AL - register address/value to write
  1061                              <1> 	
  1062                              <1> int_adlib_regwrite:
  1063 00002836 60                  <1> 	pusha
  1064                              <1> 
  1065 00002837 803EEEDE01          <1> 	cmp byte [57070], 1
  1066 0000283C 7D21                <1> 	jge .pcspk
  1067                              <1> 
  1068 0000283E 803E[3229]00        <1> 	cmp byte [adlib_running], 0
  1069 00002843 7418                <1> 	je .no_write
  1070                              <1> 
  1071 00002845 BA8803              <1> 	mov dx, 388h
  1072 00002848 50                  <1> 	push ax
  1073 00002849 88E0                <1> 	mov al, ah
  1074 0000284B EE                  <1> 	out dx, al
  1075                              <1> 
  1076 0000284C EC                  <1> 	in al, dx
  1077 0000284D EC                  <1> 	in al, dx
  1078 0000284E EC                  <1> 	in al, dx
  1079 0000284F EC                  <1> 	in al, dx
  1080 00002850 EC                  <1> 	in al, dx
  1081 00002851 EC                  <1> 	in al, dx
  1082                              <1> 	
  1083 00002852 58                  <1> 	pop ax
  1084 00002853 42                  <1> 	inc dx
  1085 00002854 EE                  <1> 	out dx, al
  1086                              <1> 
  1087 00002855 4A                  <1> 	dec	dx
  1088 00002856 B422                <1> 	mov	ah, 22h
  1089                              <1> 
  1090                              <1> .wait:
  1091 00002858 EC                  <1> 	in al,dx
  1092 00002859 FECC                <1> 	dec ah
  1093 0000285B 75FB                <1> 	jnz .wait
  1094                              <1> 	
  1095                              <1> .no_write:
  1096 0000285D 61                  <1> 	popa
  1097 0000285E C3                  <1> 	ret
  1098                              <1> 
  1099                              <1> .pcspk:
  1100 0000285F 80FCA0              <1> 	cmp ah, 0A0h
  1101 00002862 7CF9                <1> 	jl .no_write
  1102                              <1> 
  1103 00002864 80FCB8              <1> 	cmp ah, 0B8h
  1104 00002867 7FF4                <1> 	jg .no_write
  1105                              <1> 
  1106 00002869 80E40F              <1> 	and ah, 0Fh
  1107 0000286C 0FB6DC              <1> 	movzx bx, ah
  1108                              <1> 	
  1109 0000286F 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
  1110 00002874 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
  1111                              <1> 	
  1112 00002879 F6C420              <1> 	test ah, 20h
  1113 0000287C 7439                <1> 	jz .pcspk_clear
  1114                              <1> 	
  1115 0000287E 88E2                <1> 	mov dl, ah		; Get the block number
  1116 00002880 C0EA02              <1> 	shr dl, 2
  1117 00002883 80E207              <1> 	and dl, 7
  1118                              <1> 	
  1119 00002886 25FF03              <1> 	and ax, 3FFh	; Get the FNum
  1120                              <1> 	
  1121                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
  1122                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
  1123                              <1> 
  1124 00002889 8816[8F28]          <1> 	mov [.shift + 2], dl
  1125                              <1> 	
  1126 0000288D C1E000              <1> 	.shift: db 0C1h, 0E0h, 0	; Shift AX left by the block number
  1127                              <1> 
  1128 00002890 53                  <1> 	push bx
  1129                              <1> 	
  1130 00002891 31D2                <1> 	xor dx, dx
  1131 00002893 BB1500              <1> 	mov bx, 21
  1132 00002896 F7F3                <1> 	div bx						; Calculate the frequency
  1133                              <1> 
  1134 00002898 5B                  <1> 	pop bx
  1135                              <1> 
  1136 00002899 53                  <1> 	push bx						; Apply the frequency multiplier
  1137 0000289A B700                <1> 	mov bh, 0
  1138 0000289C 8A9F[D128]          <1> 	mov bl, [adlib_fmul_registers + bx]
  1139 000028A0 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
  1140 000028A5 80E30F              <1> 	and bl, 0Fh
  1141 000028A8 8A9F[C128]          <1> 	mov bl, [adlib_fmul_values + bx]
  1142                              <1> 	
  1143 000028AC F7E3                <1> 	mul bx
  1144 000028AE 5B                  <1> 	pop bx
  1145                              <1> 	
  1146 000028AF D1E3                <1> 	shl bx, 1		; Words
  1147 000028B1 8987[A129]          <1> 	mov word [pwm_freq + bx], ax
  1148                              <1> 
  1149 000028B5 61                  <1> 	popa
  1150 000028B6 C3                  <1> 	ret
  1151                              <1> 	
  1152                              <1> .pcspk_clear:
  1153 000028B7 D1E3                <1> 	shl bx, 1		; Words
  1154 000028B9 C787[A129]0000      <1> 	mov word [pwm_freq + bx], 0
  1155                              <1> 	
  1156 000028BF 61                  <1> 	popa
  1157 000028C0 C3                  <1> 	ret
  1158                              <1> 	
  1159 000028C1 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
  1159 000028CA 12141418181E1E      <1>
  1160 000028D1 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
  1161                              <1> 	
  1162                              <1> ; ------------------------------------------------------------------
  1163                              <1> ; os_adlib_mute -- Mute the YM3812's current state
  1164                              <1> ; IN: nothing
  1165                              <1> 
  1166                              <1> os_adlib_mute:
  1167 000028DA 60                  <1> 	pusha
  1168                              <1> 	
  1169 000028DB 803EEEDE01          <1> 	cmp byte [57070], 1
  1170 000028E0 7D15                <1> 	jge .pcspk
  1171                              <1> 	
  1172 000028E2 BE[2029]            <1> 	mov si, adlib_volume_registers
  1173 000028E5 B91200              <1> 	mov cx, 18
  1174                              <1> 	
  1175                              <1> .loop:
  1176 000028E8 AC                  <1> 	lodsb
  1177 000028E9 88C4                <1> 	mov ah, al
  1178                              <1> 	
  1179 000028EB E83DFF              <1> 	call os_adlib_regread
  1180 000028EE 0C3F                <1> 	or al, 3Fh
  1181 000028F0 E843FF              <1> 	call int_adlib_regwrite
  1182                              <1> 	
  1183 000028F3 E2F3                <1> 	loop .loop
  1184 000028F5 61                  <1> 	popa
  1185 000028F6 C3                  <1> 	ret
  1186                              <1> 
  1187                              <1> .pcspk:
  1188 000028F7 C606[C529]01        <1> 	mov byte [pwm_muted], 1
  1189 000028FC 61                  <1> 	popa
  1190 000028FD C3                  <1> 	ret
  1191                              <1> 	
  1192                              <1> ; ------------------------------------------------------------------
  1193                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
  1194                              <1> ; IN: nothing
  1195                              <1> 
  1196                              <1> os_adlib_unmute:
  1197 000028FE 60                  <1> 	pusha
  1198                              <1> 
  1199 000028FF 803EEEDE01          <1> 	cmp byte [57070], 1
  1200 00002904 7D13                <1> 	jge .pcspk
  1201                              <1> 	
  1202 00002906 BE[2029]            <1> 	mov si, adlib_volume_registers
  1203 00002909 B91200              <1> 	mov cx, 18
  1204                              <1> 	
  1205                              <1> .loop:
  1206 0000290C AC                  <1> 	lodsb
  1207 0000290D 88C4                <1> 	mov ah, al
  1208                              <1> 	
  1209 0000290F E819FF              <1> 	call os_adlib_regread
  1210 00002912 E821FF              <1> 	call int_adlib_regwrite
  1211                              <1> 	
  1212 00002915 E2F5                <1> 	loop .loop
  1213 00002917 61                  <1> 	popa
  1214 00002918 C3                  <1> 	ret
  1215                              <1> 	
  1216                              <1> .pcspk:
  1217 00002919 C606[C529]00        <1> 	mov byte [pwm_muted], 0
  1218 0000291E 61                  <1> 	popa
  1219 0000291F C3                  <1> 	ret
  1220                              <1> 
  1221 00002920 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
  1221 00002929 4B4C4D505152535455  <1>
  1222 00002932 00                  <1> 	adlib_running			db 0
  1223                              <1> 
  1224                              <1> ; ------------------------------------------------------------------
  1225                              <1> ; PWM DRIVER
  1226                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
  1227                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
  1228                              <1> 
  1229                              <1> pwm_handler:
  1230 00002933 FA                  <1> 	cli
  1231 00002934 60                  <1> 	pusha
  1232 00002935 1E                  <1> 	push ds
  1233                              <1> 	
  1234 00002936 8CC8                <1> 	mov ax, cs
  1235 00002938 8ED8                <1> 	mov ds, ax
  1236                              <1> 	
  1237 0000293A 803E[C529]01        <1> 	cmp byte [pwm_muted], 1
  1238 0000293F 744D                <1> 	je .no_spk
  1239                              <1> 
  1240                              <1> 	; Send the PWM value to the PC speaker
  1241 00002941 B0B0                <1> 	mov al, 10110000b
  1242 00002943 E643                <1> 	out 0x43, al
  1243 00002945 A0[CC29]            <1> 	mov al, [pwm_val]
  1244 00002948 E642                <1> 	out 0x42, al
  1245 0000294A B000                <1> 	mov al, 0
  1246 0000294C E642                <1> 	out 0x42, al
  1247                              <1> 
  1248                              <1> 	; Calculate the next value
  1249 0000294E B90900              <1> 	mov cx, 9
  1250 00002951 BE[A129]            <1> 	mov si, pwm_freq
  1251 00002954 BF[B129]            <1> 	mov di, pwm_cntr - 2
  1252 00002957 B300                <1> 	mov bl, 0
  1253                              <1> 	
  1254 00002959 8A16[CD29]          <1> 	mov dl, [pwm_channel_amplitude]
  1255                              <1> 	
  1256 0000295D 803EEEDE02          <1> 	cmp byte [57070], 2
  1257 00002962 7513                <1> 	jne .handler_loop
  1258                              <1> 	
  1259                              <1> 	; Max volume mode, count the number of active channels
  1260 00002964 56                  <1> 	push si
  1261 00002965 51                  <1> 	push cx
  1262                              <1> 	
  1263                              <1> 	clr bx
    14 00002966 31DB                <2>  xor %1, %1
  1264                              <1> 	
  1265                              <1> .channel_count_loop:
  1266 00002968 AD                  <1> 	lodsw
  1267                              <1> 	
  1268 00002969 83F800              <1> 	cmp ax, 0
  1269 0000296C 7401                <1> 	je .channel_count_loop_no_inc
  1270                              <1> 	
  1271 0000296E 43                  <1> 	inc bx
  1272                              <1> 	
  1273                              <1> .channel_count_loop_no_inc:
  1274 0000296F E2F7                <1> 	loop .channel_count_loop
  1275                              <1> 	
  1276 00002971 59                  <1> 	pop cx
  1277 00002972 5E                  <1> 	pop si
  1278                              <1> 	
  1279 00002973 8A97[CE29]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
  1280                              <1> 
  1281                              <1> 	; Add all of the channels together
  1282                              <1> .handler_loop:
  1283 00002977 AD                  <1> 	lodsw
  1284                              <1> 	
  1285 00002978 83F800              <1> 	cmp ax, 0
  1286 0000297B 7409                <1> 	je .handler_loop_no_inc
  1287                              <1> 	
  1288 0000297D 83C702              <1> 	add di, 2
  1289 00002980 0105                <1> 	add [di], ax
  1290                              <1> 	
  1291 00002982 7902                <1> 	jns .handler_loop_no_inc
  1292                              <1> 	
  1293 00002984 00D3                <1> 	add	bl, dl
  1294                              <1> 
  1295                              <1> .handler_loop_no_inc:
  1296 00002986 E2EF                <1> 	loop .handler_loop
  1297                              <1> 	
  1298 00002988 FEC3                <1> 	inc bl
  1299 0000298A 881E[CC29]          <1> 	mov [pwm_val], bl
  1300                              <1> 	
  1301                              <1> .no_spk:
  1302                              <1> 	; Have we reached the callback value?	
  1303 0000298E FF0E[C829]          <1> 	dec word [pwm_callback_ctr]
  1304 00002992 750A                <1> 	jnz .exit
  1305                              <1> 
  1306                              <1> 	; Yes, reset it
  1307 00002994 A1[CA29]            <1> 	mov ax, [pwm_callback_ctr_def]
  1308 00002997 A3[C829]            <1> 	mov [pwm_callback_ctr], ax
  1309                              <1> 	
  1310                              <1> 	; Call the callback
  1311 0000299A FF16[C629]          <1> 	call [pwm_callback]
  1312                              <1> 	
  1313                              <1> .exit:
  1314 0000299E 1F                  <1> 	pop ds
  1315 0000299F 61                  <1> 	popa
  1316 000029A0 CF                  <1> 	iret
  1317                              <1> 
  1318 000029A1 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
  1319 000029B3 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
  1320 000029C5 00                  <1> 	pwm_muted				db 0
  1321 000029C6 0000                <1> 	pwm_callback			dw 0
  1322 000029C8 0000                <1> 	pwm_callback_ctr		dw 0
  1323 000029CA 0000                <1> 	pwm_callback_ctr_def	dw 0
  1324 000029CC 00                  <1> 	pwm_val					db 0
  1325 000029CD 00                  <1> 	pwm_channel_amplitude	db 0
  1326 000029CE 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
  1326 000029D7 04                  <1>
  1327                              <1> 	
  1328                              <1> ; ------------------------------------------------------------------
  1329                              <1> ; os_adlib_calcfreq -- Play a frequency
  1330                              <1> ; IN: AX - frequency, CL = channel; OUT: nothing
  1331                              <1> 
  1332                              <1> os_adlib_calcfreq:
  1333 000029D8 6660                <1> 	pushad
  1334                              <1> 
  1335 000029DA 803EEEDE01          <1> 	cmp byte [57070], 1
  1336 000029DF 7D54                <1> 	jge .pcspk
  1337                              <1> 
  1338 000029E1 880E[432A]          <1> 	mov [.channel], cl
  1339                              <1> 	
  1340 000029E5 660FB7C0            <1> 	movzx eax, ax
  1341 000029E9 B100                <1> 	mov cl, 0		; Block number
  1342                              <1> 	
  1343 000029EB 6650                <1> 	push eax
  1344                              <1> 
  1345                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
  1346 000029ED 6658                <1> 	pop eax
  1347 000029EF 6650                <1> 	push eax
  1348                              <1> 	
  1349 000029F1 B314                <1> 	mov bl, 20
  1350 000029F3 28CB                <1> 	sub bl, cl
  1351                              <1> 	
  1352 000029F5 881E[FC29]          <1> 	mov [.shift + 3], bl
  1353 000029F9 66C1E000            <1> .shift: db 0x66, 0xc1, 0xe0, 0		; shl eax, XX
  1354                              <1> 
  1355                              <1> 	clr edx
    14 000029FD 6631D2              <2>  xor %1, %1
  1356 00002A00 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
  1357 00002A06 66F7F3              <1> 	div ebx
  1358                              <1> 
  1359 00002A09 FEC1                <1> 	inc cl
  1360                              <1> 	
  1361 00002A0B 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
  1362 00002A0E 7DDD                <1> 	jge .block_loop
  1363                              <1> 	
  1364 00002A10 FEC9                <1> 	dec cl
  1365                              <1> 	
  1366 00002A12 C0E102              <1> 	shl cl, 2		; Write the block number
  1367 00002A15 00CC                <1> 	add ah, cl
  1368                              <1> 
  1369 00002A17 80CC20              <1> 	or ah, 20h		; Note on
  1370                              <1> 	
  1371 00002A1A 50                  <1> 	push ax
  1372 00002A1B B4A0                <1> 	mov ah, 0A0h
  1373 00002A1D 0226[432A]          <1> 	add ah, [.channel]
  1374 00002A21 E8F9FD              <1> 	call os_adlib_regwrite
  1375 00002A24 58                  <1> 	pop ax
  1376                              <1> 	
  1377 00002A25 88E0                <1> 	mov al, ah
  1378 00002A27 B4B0                <1> 	mov ah, 0B0h
  1379 00002A29 0226[432A]          <1> 	add ah, [.channel]
  1380 00002A2D E8EDFD              <1> 	call os_adlib_regwrite
  1381                              <1> 	
  1382 00002A30 6658                <1> 	pop eax
  1383 00002A32 6661                <1> 	popad
  1384 00002A34 C3                  <1> 	ret
  1385                              <1> 	
  1386                              <1> .pcspk:
  1387 00002A35 0FB6D9              <1> 	movzx bx, cl
  1388 00002A38 D1E3                <1> 	shl bx, 1
  1389 00002A3A D1E0                <1> 	shl ax, 1
  1390 00002A3C 8987[A129]          <1> 	mov [pwm_freq + bx], ax
  1391 00002A40 6661                <1> 	popad
  1392 00002A42 C3                  <1> 	ret
  1393                              <1> 	
  1394 00002A43 00                  <1> 	.channel	db 0
  1395                              <1> 	
  1396                              <1> ; ------------------------------------------------------------------
  1397                              <1> ; os_adlib_noteoff -- Turns off a note
  1398                              <1> ; IN: CL = channel; OUT: nothing
  1399                              <1> 
  1400                              <1> os_adlib_noteoff:
  1401 00002A44 803EEEDE01          <1> 	cmp byte [57070], 1
  1402 00002A49 7D0F                <1> 	jge .pcspk
  1403                              <1> 	
  1404 00002A4B 60                  <1> 	pusha
  1405                              <1> 
  1406 00002A4C B4B0                <1> 	mov ah, 0B0h
  1407 00002A4E 00CC                <1> 	add ah, cl
  1408 00002A50 E8D8FD              <1> 	call os_adlib_regread
  1409                              <1> 	
  1410 00002A53 24DF                <1> 	and al, 11011111b
  1411 00002A55 E8C5FD              <1> 	call os_adlib_regwrite
  1412                              <1> 	
  1413 00002A58 61                  <1> 	popa
  1414 00002A59 C3                  <1> 	ret
  1415                              <1> 	
  1416                              <1> .pcspk:
  1417 00002A5A 60                  <1> 	pusha
  1418 00002A5B 0FB6D9              <1> 	movzx bx, cl
  1419 00002A5E D1E3                <1> 	shl bx, 1
  1420 00002A60 C787[A129]0000      <1> 	mov word [pwm_freq + bx], 0
  1421 00002A66 61                  <1> 	popa
  1422 00002A67 C3                  <1> 	ret	
  1423                              <1> 	
  1424                              <1> ; ==================================================================
  1425                              <1> 
   821                                  	%INCLUDE "features/string.asm"
   822                              <1> ; ==================================================================
   823                              <1> ; STRING MANIPULATION ROUTINES
   824                              <1> ; ==================================================================
   825                              <1> 
   826                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   827                              <1> ; IN: SI = Input string/Output string
   828                              <1> 
   829                              <1> os_string_encrypt:
   830 00002A68 60                  <1> 	pusha
   831 00002A69 89F7                <1> 	mov di, si
   832                              <1> 
   833 00002A6B 89F0                <1> 	mov ax, si
   834 00002A6D E82C00              <1> 	call os_string_length
   835 00002A70 C0E002              <1> 	shl al, 2
   836 00002A73 347B                <1> 	xor al, 123
   837                              <1> 	
   838 00002A75 B17B                <1> 	mov cl, 123
   839 00002A77 00C1                <1> 	add cl, al
   840 00002A79 80F1DB              <1> 	xor cl, 219
   841                              <1> 	
   842                              <1> .loop:
   843 00002A7C AC                  <1> 	lodsb
   844 00002A7D 3C00                <1> 	cmp al, 0
   845 00002A7F 740A                <1> 	je .exit
   846                              <1> 	
   847 00002A81 00C8                <1> 	add al, cl
   848 00002A83 34AA                <1> 	xor al, 10101010b
   849 00002A85 AA                  <1> 	stosb
   850                              <1> 	
   851 00002A86 80C14D              <1> 	add cl, 77
   852 00002A89 EBF1                <1> 	jmp .loop
   853                              <1> 	
   854                              <1> .exit:
   855 00002A8B 61                  <1> 	popa
   856 00002A8C C3                  <1> 	ret
   857                              <1> 	
   858                              <1> ; os_string_add -- Add a string on top of another string
   859                              <1> ; IN: AX/BX = Main string/Added string
   860                              <1> 
   861                              <1> os_string_add:
   862 00002A8D 60                  <1> 	pusha
   863 00002A8E 50                  <1> 	push ax
   864 00002A8F E80A00              <1> 	call os_string_length		; Get the length of the main string
   865 00002A92 5F                  <1> 	pop di
   866 00002A93 01C7                <1> 	add di, ax					; Add it to the pointer
   867 00002A95 89DE                <1> 	mov si, bx
   868 00002A97 E89500              <1>  	call os_string_copy			; Copy the string
   869 00002A9A 61                  <1>  	popa
   870 00002A9B C3                  <1>  	ret
   871                              <1> 	
   872                              <1> ; ------------------------------------------------------------------
   873                              <1> ; os_string_length -- Return length of a string
   874                              <1> ; IN: AX = string location
   875                              <1> ; OUT AX = length (other regs preserved)
   876                              <1> 
   877                              <1> os_string_length:
   878 00002A9C 60                  <1> 	pusha
   879                              <1> 
   880 00002A9D 89C3                <1> 	mov bx, ax			; Move location of string to BX
   881                              <1> 
   882 00002A9F 31C9                <1> 	xor cx, cx			; Counter
   883                              <1> 
   884                              <1> .more:
   885 00002AA1 803F00              <1> 	cmp byte [bx], 0		; Zero (end of string) yet?
   886 00002AA4 7404                <1> 	je .done
   887 00002AA6 43                  <1> 	inc bx				; If not, keep adding
   888 00002AA7 41                  <1> 	inc cx
   889 00002AA8 EBF7                <1> 	jmp .more
   890                              <1> 
   891                              <1> 
   892                              <1> .done:
   893 00002AAA 890E[B32A]          <1> 	mov word [.tmp_counter], cx	; Store count before restoring other registers
   894 00002AAE 61                  <1> 	popa
   895                              <1> 
   896 00002AAF A1[B32A]            <1> 	mov ax, [.tmp_counter]		; Put count back into AX before returning
   897 00002AB2 C3                  <1> 	ret
   898                              <1> 
   899                              <1> 
   900 00002AB3 0000                <1> 	.tmp_counter	dw 0
   901                              <1> 
   902                              <1> 
   903                              <1> ; ------------------------------------------------------------------
   904                              <1> ; os_string_reverse -- Reverse the characters in a string
   905                              <1> ; IN: SI = string location
   906                              <1> 
   907                              <1> os_string_reverse:
   908 00002AB5 60                  <1> 	pusha
   909                              <1> 
   910 00002AB6 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   911 00002AB9 7418                <1> 	je .end
   912                              <1> 
   913 00002ABB 89F0                <1> 	mov ax, si
   914 00002ABD E8DCFF              <1> 	call os_string_length
   915                              <1> 
   916 00002AC0 89F7                <1> 	mov di, si
   917 00002AC2 01C7                <1> 	add di, ax
   918 00002AC4 4F                  <1> 	dec di				; DI now points to last char in string
   919                              <1> 
   920                              <1> .loop:
   921 00002AC5 8A04                <1> 	mov byte al, [si]		; Swap bytes
   922 00002AC7 8A1D                <1> 	mov byte bl, [di]
   923                              <1> 
   924 00002AC9 881C                <1> 	mov byte [si], bl
   925 00002ACB 8805                <1> 	mov byte [di], al
   926                              <1> 
   927 00002ACD 46                  <1> 	inc si				; Move towards string centre
   928 00002ACE 4F                  <1> 	dec di
   929                              <1> 
   930 00002ACF 39F7                <1> 	cmp di, si			; Both reached the centre?
   931 00002AD1 77F2                <1> 	ja .loop
   932                              <1> 
   933                              <1> .end:
   934 00002AD3 61                  <1> 	popa
   935 00002AD4 C3                  <1> 	ret
   936                              <1> 
   937                              <1> 
   938                              <1> ; ------------------------------------------------------------------
   939                              <1> ; os_find_char_in_string -- Find location of character in a string
   940                              <1> ; IN: SI = string location, AL = character to find
   941                              <1> ; OUT: AX = location in string, or 0 if char not present
   942                              <1> 
   943                              <1> os_find_char_in_string:
   944 00002AD5 60                  <1> 	pusha
   945                              <1> 
   946 00002AD6 B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   947                              <1> 					; from 1 in chars here, so that we can
   948                              <1> 					; return 0 if the source char isn't found)
   949                              <1> 
   950                              <1> .more:
   951 00002AD9 3804                <1> 	cmp byte [si], al
   952 00002ADB 7409                <1> 	je .done
   953 00002ADD 803C00              <1> 	cmp byte [si], 0
   954 00002AE0 740D                <1> 	je .notfound
   955 00002AE2 46                  <1> 	inc si
   956 00002AE3 41                  <1> 	inc cx
   957 00002AE4 EBF3                <1> 	jmp .more
   958                              <1> 
   959                              <1> .done:
   960 00002AE6 890E[F32A]          <1> 	mov [.tmp], cx
   961 00002AEA 61                  <1> 	popa
   962 00002AEB A1[F32A]            <1> 	mov ax, [.tmp]
   963 00002AEE C3                  <1> 	ret
   964                              <1> 
   965                              <1> .notfound:
   966 00002AEF 61                  <1> 	popa
   967 00002AF0 31C0                <1> 	xor ax, ax
   968 00002AF2 C3                  <1> 	ret
   969                              <1> 
   970                              <1> 
   971 00002AF3 0000                <1> 	.tmp	dw 0
   972                              <1> 
   973                              <1> 
   974                              <1> ; ------------------------------------------------------------------
   975                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   976                              <1> ; IN/OUT: AX = string location
   977                              <1> 
   978                              <1> os_string_uppercase:
   979 00002AF5 60                  <1> 	pusha
   980                              <1> 
   981 00002AF6 89C6                <1> 	mov si, ax			; Use SI to access string
   982                              <1> 
   983                              <1> .more:
   984 00002AF8 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   985 00002AFB 7413                <1> 	je .done			; If so, quit
   986                              <1> 
   987 00002AFD 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   988 00002B00 720B                <1> 	jb .noatoz
   989 00002B02 803C7A              <1> 	cmp byte [si], 'z'
   990 00002B05 7706                <1> 	ja .noatoz
   991                              <1> 
   992 00002B07 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   993                              <1> 
   994 00002B0A 46                  <1> 	inc si
   995 00002B0B EBEB                <1> 	jmp .more
   996                              <1> 
   997                              <1> .noatoz:
   998 00002B0D 46                  <1> 	inc si
   999 00002B0E EBE8                <1> 	jmp .more
  1000                              <1> 
  1001                              <1> .done:
  1002 00002B10 61                  <1> 	popa
  1003 00002B11 C3                  <1> 	ret
  1004                              <1> 
  1005                              <1> 
  1006                              <1> ; ------------------------------------------------------------------
  1007                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
  1008                              <1> ; IN/OUT: AX = string location
  1009                              <1> 
  1010                              <1> os_string_lowercase:
  1011 00002B12 60                  <1> 	pusha
  1012                              <1> 
  1013 00002B13 89C6                <1> 	mov si, ax			; Use SI to access string
  1014                              <1> 
  1015                              <1> .more:
  1016 00002B15 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
  1017 00002B18 7413                <1> 	je .done			; If so, quit
  1018                              <1> 
  1019 00002B1A 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
  1020 00002B1D 720B                <1> 	jb .noatoz
  1021 00002B1F 803C5A              <1> 	cmp byte [si], 'Z'
  1022 00002B22 7706                <1> 	ja .noatoz
  1023                              <1> 
  1024 00002B24 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
  1025                              <1> 
  1026 00002B27 46                  <1> 	inc si
  1027 00002B28 EBEB                <1> 	jmp .more
  1028                              <1> 
  1029                              <1> .noatoz:
  1030 00002B2A 46                  <1> 	inc si
  1031 00002B2B EBE8                <1> 	jmp .more
  1032                              <1> 
  1033                              <1> .done:
  1034 00002B2D 61                  <1> 	popa
  1035 00002B2E C3                  <1> 	ret
  1036                              <1> 
  1037                              <1> 
  1038                              <1> ; ------------------------------------------------------------------
  1039                              <1> ; os_string_copy -- Copy one string into another
  1040                              <1> ; IN/OUT: SI = source, DI = destination (programmer ensure sufficient room)
  1041                              <1> 
  1042                              <1> os_string_copy:
  1043 00002B2F 60                  <1> 	pusha
  1044                              <1> 
  1045                              <1> .more:
  1046 00002B30 AC                  <1> 	lodsb
  1047 00002B31 AA                  <1> 	stosb
  1048 00002B32 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
  1049 00002B34 75FA                <1> 	jne .more
  1050 00002B36 61                  <1> 	popa
  1051 00002B37 C3                  <1> 	ret
  1052                              <1> 
  1053                              <1> 
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; os_string_join -- Join two strings into a third string
  1056                              <1> ; IN/OUT: AX = string one, BX = string two, CX = destination string
  1057                              <1> 
  1058                              <1> os_string_join:
  1059 00002B38 60                  <1> 	pusha
  1060                              <1> 
  1061 00002B39 89C6                <1> 	mov si, ax
  1062 00002B3B 89CF                <1> 	mov di, cx
  1063 00002B3D E8EFFF              <1> 	call os_string_copy
  1064                              <1> 
  1065 00002B40 E859FF              <1> 	call os_string_length		; Get length of first string
  1066                              <1> 
  1067 00002B43 01C1                <1> 	add cx, ax			; Position at end of first string
  1068                              <1> 
  1069 00002B45 89DE                <1> 	mov si, bx			; Add second string onto it
  1070 00002B47 89CF                <1> 	mov di, cx
  1071 00002B49 E8E3FF              <1> 	call os_string_copy
  1072                              <1> 
  1073 00002B4C 61                  <1> 	popa
  1074 00002B4D C3                  <1> 	ret
  1075                              <1> 
  1076                              <1> 
  1077                              <1> ; ------------------------------------------------------------------
  1078                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
  1079                              <1> ; IN: AX = string location
  1080                              <1> 
  1081                              <1> os_string_chomp:
  1082 00002B4E 60                  <1> 	pusha
  1083                              <1> 
  1084 00002B4F 89C2                <1> 	mov dx, ax			; Save string location
  1085                              <1> 
  1086 00002B51 89C7                <1> 	mov di, ax			; Put location into DI
  1087 00002B53 31C9                <1> 	xor cx, cx			; Space counter
  1088                              <1> 
  1089                              <1> .keepcounting:				; Get number of leading spaces into BX
  1090 00002B55 803D20              <1> 	cmp byte [di], ' '
  1091 00002B58 7504                <1> 	jne .counted
  1092 00002B5A 41                  <1> 	inc cx
  1093 00002B5B 47                  <1> 	inc di
  1094 00002B5C EBF7                <1> 	jmp .keepcounting
  1095                              <1> 
  1096                              <1> .counted:
  1097 00002B5E 83F900              <1> 	cmp cx, 0			; No leading spaces?
  1098 00002B61 7410                <1> 	je .finished_copy
  1099                              <1> 
  1100 00002B63 89FE                <1> 	mov si, di			; Address of first non-space character
  1101 00002B65 89D7                <1> 	mov di, dx			; DI = original string start
  1102                              <1> 
  1103                              <1> .keep_copying:
  1104 00002B67 8A04                <1> 	mov al, [si]			; Copy SI into DI
  1105 00002B69 8805                <1> 	mov [di], al			; Including terminator
  1106 00002B6B 3C00                <1> 	cmp al, 0
  1107 00002B6D 7404                <1> 	je .finished_copy
  1108 00002B6F 46                  <1> 	inc si
  1109 00002B70 47                  <1> 	inc di
  1110 00002B71 EBF4                <1> 	jmp .keep_copying
  1111                              <1> 
  1112                              <1> .finished_copy:
  1113 00002B73 89D0                <1> 	mov ax, dx			; AX = original string start
  1114                              <1> 
  1115 00002B75 E824FF              <1> 	call os_string_length
  1116 00002B78 83F800              <1> 	cmp ax, 0			; If empty or all blank, done, return 'null'
  1117 00002B7B 740F                <1> 	je .done
  1118                              <1> 
  1119 00002B7D 89D6                <1> 	mov si, dx
  1120 00002B7F 01C6                <1> 	add si, ax			; Move to end of string
  1121                              <1> 
  1122                              <1> .more:
  1123 00002B81 4E                  <1> 	dec si
  1124 00002B82 803C20              <1> 	cmp byte [si], ' '
  1125 00002B85 7505                <1> 	jne .done
  1126 00002B87 C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
  1127 00002B8A EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
  1128                              <1> 
  1129                              <1> .done:
  1130 00002B8C 61                  <1> 	popa
  1131 00002B8D C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> 
  1134                              <1> ; ------------------------------------------------------------------
  1135                              <1> ; os_string_compare -- See if two strings match
  1136                              <1> ; IN: SI = string one, DI = string two
  1137                              <1> ; OUT: carry set if same, clear if different
  1138                              <1> 
  1139                              <1> os_string_compare:
  1140 00002B8E 60                  <1> 	pusha
  1141                              <1> 
  1142                              <1> .more:
  1143 00002B8F 8A04                <1> 	mov al, [si]			; Retrieve string contents
  1144 00002B91 8A1D                <1> 	mov bl, [di]
  1145                              <1> 
  1146 00002B93 38D8                <1> 	cmp al, bl			; Compare characters at current location
  1147 00002B95 7508                <1> 	jne .not_same
  1148                              <1> 
  1149 00002B97 3C00                <1> 	cmp al, 0			; End of first string? Must also be end of second
  1150 00002B99 7407                <1> 	je .terminated
  1151                              <1> 
  1152 00002B9B 46                  <1> 	inc si
  1153 00002B9C 47                  <1> 	inc di
  1154 00002B9D EBF0                <1> 	jmp .more
  1155                              <1> 
  1156                              <1> 
  1157                              <1> .not_same:				; If unequal lengths with same beginning, the byte
  1158 00002B9F 61                  <1> 	popa				; comparison fails at shortest string terminator
  1159 00002BA0 F8                  <1> 	clc				; Clear carry flag
  1160 00002BA1 C3                  <1> 	ret
  1161                              <1> 
  1162                              <1> 
  1163                              <1> .terminated:				; Both strings terminated at the same position
  1164 00002BA2 61                  <1> 	popa
  1165 00002BA3 F9                  <1> 	stc				; Set carry flag
  1166 00002BA4 C3                  <1> 	ret
  1167                              <1> 
  1168                              <1> 
  1169                              <1> ; ------------------------------------------------------------------
  1170                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
  1171                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
  1172                              <1> ; IN: SI = string; OUT: AX, BX, CX, DX = individual strings
  1173                              <1> 
  1174                              <1> os_string_parse:
  1175 00002BA5 56                  <1> 	push si
  1176                              <1> 
  1177 00002BA6 89F0                <1> 	mov ax, si			; AX = start of first string
  1178                              <1> 
  1179 00002BA8 31DB                <1> 	xor bx, bx			; By default, other strings start empty
  1180 00002BAA 31C9                <1> 	xor cx, cx
  1181 00002BAC 31D2                <1> 	xor dx, dx
  1182                              <1> 
  1183 00002BAE 50                  <1> 	push ax				; Save to retrieve at end
  1184                              <1> 
  1185                              <1> .loop1:
  1186 00002BAF AC                  <1> 	lodsb				; Get a byte
  1187 00002BB0 3C00                <1> 	cmp al, 0			; End of string?
  1188 00002BB2 742B                <1> 	je .finish
  1189 00002BB4 3C20                <1> 	cmp al, ' '			; A space?
  1190 00002BB6 75F7                <1> 	jne .loop1
  1191 00002BB8 4E                  <1> 	dec si
  1192 00002BB9 C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
  1193                              <1> 
  1194 00002BBC 46                  <1> 	inc si				; Store start of next string in BX
  1195 00002BBD 89F3                <1> 	mov bx, si
  1196                              <1> 
  1197                              <1> .loop2:					; Repeat the above for CX and DX...
  1198 00002BBF AC                  <1> 	lodsb
  1199 00002BC0 3C00                <1> 	cmp al, 0
  1200 00002BC2 741B                <1> 	je .finish
  1201 00002BC4 3C20                <1> 	cmp al, ' '
  1202 00002BC6 75F7                <1> 	jne .loop2
  1203 00002BC8 4E                  <1> 	dec si
  1204 00002BC9 C60400              <1> 	mov byte [si], 0
  1205                              <1> 
  1206 00002BCC 46                  <1> 	inc si
  1207 00002BCD 89F1                <1> 	mov cx, si
  1208                              <1> 
  1209                              <1> .loop3:
  1210 00002BCF AC                  <1> 	lodsb
  1211 00002BD0 3C00                <1> 	cmp al, 0
  1212 00002BD2 740B                <1> 	je .finish
  1213 00002BD4 3C20                <1> 	cmp al, ' '
  1214 00002BD6 75F7                <1> 	jne .loop3
  1215 00002BD8 4E                  <1> 	dec si
  1216 00002BD9 C60400              <1> 	mov byte [si], 0
  1217                              <1> 
  1218 00002BDC 46                  <1> 	inc si
  1219 00002BDD 89F2                <1> 	mov dx, si
  1220                              <1> 
  1221                              <1> .finish:
  1222 00002BDF 58                  <1> 	pop ax
  1223                              <1> 
  1224 00002BE0 5E                  <1> 	pop si
  1225 00002BE1 C3                  <1> 	ret
  1226                              <1> 
  1227                              <1> 
  1228                              <1> ; ------------------------------------------------------------------
  1229                              <1> ; os_string_to_int -- Convert decimal string to integer value
  1230                              <1> ; IN: SI = string location (max 5 chars, up to '65535')
  1231                              <1> ; OUT: AX = number
  1232                              <1> 
  1233                              <1> os_string_to_int:
  1234 00002BE2 E88E01              <1> 	call os_string_to_32int		; This function only exists for compatibility reasons
  1235 00002BE5 C3                  <1> 	ret
  1236                              <1> 
  1237                              <1> ; ------------------------------------------------------------------
  1238                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
  1239                              <1> ; IN: SI = string location (max 8 chars, up to 'FFFFFFFF')
  1240                              <1> ; OUT: EAX = number
  1241                              <1> 
  1242                              <1> os_string_to_hex:
  1243 00002BE6 6660                <1> 	pushad
  1244                              <1> 	
  1245 00002BE8 89F0                <1> 	mov ax, si			; First, uppercase the string
  1246 00002BEA E808FF              <1> 	call os_string_uppercase
  1247                              <1> 
  1248 00002BED 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1249                              <1> 	
  1250                              <1> .loop:
  1251 00002BF0 6650                <1> 	push eax
  1252 00002BF2 AC                  <1> 	lodsb					; Load a byte from SI
  1253 00002BF3 88C1                <1> 	mov cl, al
  1254 00002BF5 6658                <1> 	pop eax
  1255 00002BF7 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1256 00002BFA 0F842000            <1> 	je near .exit			; If we have, exit
  1257                              <1> 	
  1258 00002BFE 80F939              <1> 	cmp cl, '9'
  1259 00002C01 7E03                <1> 	jle .no_change
  1260                              <1> 	
  1261 00002C03 80E907              <1> 	sub cl, 7
  1262                              <1> 	
  1263                              <1> .no_change:
  1264 00002C06 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1265 00002C09 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1266 00002C10 66BB10000000        <1> 	mov ebx, 16 
  1267 00002C16 66F7E3              <1> 	mul ebx					; Multiply EAX by 16
  1268 00002C19 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1269 00002C1C EBD2                <1> 	jmp .loop				; Loop again
  1270                              <1> 	
  1271                              <1> .exit:
  1272 00002C1E 66A3[292C]          <1> 	mov [.tmp_dword], eax
  1273 00002C22 6661                <1> 	popad
  1274 00002C24 66A1[292C]          <1> 	mov eax, [.tmp_dword]
  1275 00002C28 C3                  <1> 	ret
  1276                              <1> 	
  1277 00002C29 00000000            <1> 	.tmp_dword	dd 0
  1278                              <1> 
  1279                              <1> ; ------------------------------------------------------------------
  1280                              <1> ; os_int_to_string -- Convert unsigned integer to string
  1281                              <1> ; IN: AX = unsigned int
  1282                              <1> ; OUT: AX = string location
  1283                              <1> 
  1284                              <1> os_int_to_string:
  1285 00002C2D 60                  <1> 	pusha
  1286                              <1> 
  1287 00002C2E 31C9                <1> 	xor cx, cx
  1288 00002C30 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1289 00002C33 BF[542C]            <1> 	mov di, .t			; Get our pointer ready
  1290                              <1> 
  1291                              <1> .push:
  1292 00002C36 31D2                <1> 	xor dx, dx
  1293 00002C38 F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1294 00002C3A 41                  <1> 	inc cx				; Increase pop loop counter
  1295 00002C3B 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1296 00002C3C 85C0                <1> 	test ax, ax			; Is quotient zero?
  1297 00002C3E 75F6                <1> 	jnz .push			; If not, loop again
  1298                              <1> .pop:
  1299 00002C40 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1300 00002C41 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1301 00002C44 2E8815              <1> 	mov [cs:di], dl
  1302 00002C47 47                  <1> 	inc di
  1303 00002C48 49                  <1> 	dec cx
  1304 00002C49 75F5                <1> 	jnz .pop
  1305                              <1> 
  1306 00002C4B 2EC60500            <1> 	mov byte [cs:di], 0		; Zero-terminate string
  1307                              <1> 
  1308 00002C4F 61                  <1> 	popa
  1309 00002C50 B8[542C]            <1> 	mov ax, .t			; Return location of string
  1310 00002C53 C3                  <1> 	ret
  1311                              <1> 
  1312                              <1> 
  1313 00002C54 00<rep 7h>          <1> 	.t times 7 db 0
  1314                              <1> 
  1315                              <1> 
  1316                              <1> ; ------------------------------------------------------------------
  1317                              <1> ; os_sint_to_string -- Convert signed integer to string
  1318                              <1> ; IN: AX = signed int
  1319                              <1> ; OUT: AX = string location
  1320                              <1> 
  1321                              <1> os_sint_to_string:
  1322 00002C5B 60                  <1> 	pusha
  1323                              <1> 
  1324 00002C5C 31C9                <1> 	xor cx, cx
  1325 00002C5E BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1326 00002C61 BF[8E2C]            <1> 	mov di, .t			; Get our pointer ready
  1327                              <1> 
  1328 00002C64 85C0                <1> 	test ax, ax			; Find out if X > 0 or not, force a sign
  1329 00002C66 7802                <1> 	js .neg				; If negative...
  1330 00002C68 EB08                <1> 	jmp .push			; ...or if positive
  1331                              <1> .neg:
  1332 00002C6A F7D8                <1> 	neg ax				; Make AX positive
  1333 00002C6C C606[8E2C]2D        <1> 	mov byte [.t], '-'		; Add a minus sign to our string
  1334 00002C71 47                  <1> 	inc di				; Update the index
  1335                              <1> .push:
  1336 00002C72 31D2                <1> 	xor dx, dx
  1337 00002C74 F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1338 00002C76 41                  <1> 	inc cx				; Increase pop loop counter
  1339 00002C77 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1340 00002C78 85C0                <1> 	test ax, ax			; Is quotient zero?
  1341 00002C7A 75F6                <1> 	jnz .push			; If not, loop again
  1342                              <1> .pop:
  1343 00002C7C 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1344 00002C7D 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1345 00002C80 8815                <1> 	mov [di], dl
  1346 00002C82 47                  <1> 	inc di
  1347 00002C83 49                  <1> 	dec cx
  1348 00002C84 75F6                <1> 	jnz .pop
  1349                              <1> 
  1350 00002C86 C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1351                              <1> 
  1352 00002C89 61                  <1> 	popa
  1353 00002C8A B8[8E2C]            <1> 	mov ax, .t			; Return location of string
  1354 00002C8D C3                  <1> 	ret
  1355                              <1> 
  1356                              <1> 
  1357 00002C8E 00<rep 7h>          <1> 	.t times 7 db 0
  1358                              <1> 
  1359                              <1> ; ------------------------------------------------------------------
  1360                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
  1361                              <1> ; IN/OUT: BX = string location
  1362                              <1> 
  1363                              <1> os_get_time_string:
  1364 00002C95 60                  <1> 	pusha
  1365                              <1> 	
  1366 00002C96 89DF                <1> 	mov di, bx			; Location to place the string
  1367                              <1> 
  1368 00002C98 B402                <1> 	mov ah, 02h			; Get the current time
  1369 00002C9A E8DDEA              <1> 	call os_int_1Ah
  1370                              <1> 	
  1371 00002C9D 723B                <1> 	jc .exit
  1372                              <1> 
  1373 00002C9F 51                  <1> 	push cx	
  1374                              <1> 
  1375 00002CA0 88E8                <1> 	mov al, ch
  1376 00002CA2 E81BE8              <1> 	call os_bcd_to_int
  1377 00002CA5 83F80A              <1> 	cmp ax, 10
  1378 00002CA8 7D05                <1> 	jge .hour_10
  1379                              <1> 	
  1380 00002CAA 50                  <1> 	push ax
  1381 00002CAB B030                <1> 	mov al, '0'
  1382 00002CAD AA                  <1> 	stosb
  1383 00002CAE 58                  <1> 	pop ax
  1384                              <1> 	
  1385                              <1> .hour_10:
  1386 00002CAF E87BFF              <1> 	call os_int_to_string
  1387 00002CB2 89C6                <1> 	mov si, ax
  1388                              <1> 	
  1389                              <1> .hour_loop:	
  1390 00002CB4 AC                  <1> 	lodsb
  1391 00002CB5 3C00                <1> 	cmp al, 0
  1392 00002CB7 7403                <1> 	je .hour_loop_end
  1393 00002CB9 AA                  <1> 	stosb
  1394 00002CBA EBF8                <1> 	jmp .hour_loop
  1395                              <1> 	
  1396                              <1> .hour_loop_end:
  1397 00002CBC B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
  1398 00002CBE AA                  <1> 	stosb
  1399                              <1> 		
  1400 00002CBF 59                  <1> 	pop cx
  1401 00002CC0 88C8                <1> 	mov al, cl
  1402 00002CC2 E8FBE7              <1> 	call os_bcd_to_int
  1403 00002CC5 83F80A              <1> 	cmp ax, 10
  1404 00002CC8 7D05                <1> 	jge .minute_10
  1405                              <1> 	
  1406 00002CCA 50                  <1> 	push ax
  1407 00002CCB B030                <1> 	mov al, '0'
  1408 00002CCD AA                  <1> 	stosb
  1409 00002CCE 58                  <1> 	pop ax
  1410                              <1> 	
  1411                              <1> .minute_10:
  1412 00002CCF E85BFF              <1> 	call os_int_to_string
  1413 00002CD2 89C6                <1> 	mov si, ax
  1414                              <1> 		
  1415                              <1> .minute_loop:	
  1416 00002CD4 AC                  <1> 	lodsb
  1417 00002CD5 AA                  <1> 	stosb
  1418                              <1> 	
  1419 00002CD6 3C00                <1> 	cmp al, 0
  1420 00002CD8 75FA                <1> 	jne .minute_loop
  1421                              <1> 
  1422                              <1> .exit:
  1423 00002CDA 61                  <1> 	popa
  1424 00002CDB C3                  <1> 	ret
  1425                              <1> 
  1426                              <1> ; ------------------------------------------------------------------
  1427                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
  1428                              <1> ; IN/OUT: BX = string location
  1429                              <1> 
  1430                              <1> os_get_date_string:
  1431 00002CDC 60                  <1> 	pusha
  1432                              <1> 
  1433 00002CDD 89DF                <1> 	mov di, bx
  1434                              <1> 	
  1435 00002CDF F8                  <1> 	clc				; For buggy BIOSes
  1436 00002CE0 B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
  1437 00002CE2 E895EA              <1> 	call os_int_1Ah
  1438 00002CE5 7306                <1> 	jnc .fmt1_day
  1439                              <1> 
  1440 00002CE7 F8                  <1> 	clc
  1441 00002CE8 B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
  1442 00002CEA E88DEA              <1> 	call os_int_1Ah
  1443                              <1> 
  1444                              <1> .fmt1_day:
  1445 00002CED 88D4                <1> 	mov ah, dl			; Day
  1446 00002CEF E81A00              <1> 	call .add_2digits
  1447                              <1> 
  1448 00002CF2 B02F                <1> 	mov al, '/'
  1449 00002CF4 AA                  <1> 	stosb				; Day-month separator
  1450                              <1> 
  1451                              <1> .fmt1_month:
  1452 00002CF5 88F4                <1> 	mov ah,	dh			; Month
  1453 00002CF7 E81200              <1> 	call .add_2digits
  1454                              <1> 
  1455 00002CFA B02F                <1> 	mov al, '/'
  1456 00002CFC AA                  <1> 	stosb
  1457                              <1> 
  1458                              <1> .fmt1_century:
  1459 00002CFD 88EC                <1> 	mov ah,	ch			; Century
  1460 00002CFF E80A00              <1> 	call .add_2digits
  1461                              <1> 
  1462                              <1> .fmt1_year:
  1463 00002D02 88CC                <1> 	mov ah, cl			; Year
  1464 00002D04 E80500              <1> 	call .add_2digits
  1465                              <1> 
  1466 00002D07 B000                <1> 	mov al, 0			; Terminate date string
  1467 00002D09 AA                  <1> 	stosb
  1468                              <1> 
  1469 00002D0A 61                  <1> 	popa
  1470 00002D0B C3                  <1> 	ret
  1471                              <1> 
  1472                              <1> .add_2digits:
  1473 00002D0C 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
  1474 00002D0E C0E804              <1> 	shr al, 4
  1475 00002D11 E80800              <1> 	call .add_digit
  1476 00002D14 88E0                <1> 	mov al, ah
  1477 00002D16 240F                <1> 	and al, 0Fh
  1478 00002D18 E80100              <1> 	call .add_digit
  1479 00002D1B C3                  <1> 	ret
  1480                              <1> 
  1481                              <1> .add_digit:
  1482 00002D1C 0430                <1> 	add al, '0'			; Convert AL to ASCII
  1483 00002D1E AA                  <1> 	stosb				; Put into string buffer
  1484 00002D1F C3                  <1> 	ret
  1485                              <1> 	
  1486                              <1> 	
  1487                              <1> ; ------------------------------------------------------------------
  1488                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
  1489                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1490                              <1> ; IN: AL = separator char, SI = beginning; OUT: DI = next token or 0 if none
  1491                              <1> 
  1492                              <1> os_string_tokenize:
  1493 00002D20 56                  <1> 	push si
  1494                              <1> 
  1495                              <1> .next_char:
  1496 00002D21 3804                <1> 	cmp byte [si], al
  1497 00002D23 7408                <1> 	je .return_token
  1498 00002D25 803C00              <1> 	cmp byte [si], 0
  1499 00002D28 740B                <1> 	jz .no_more
  1500 00002D2A 46                  <1> 	inc si
  1501 00002D2B EBF4                <1> 	jmp .next_char
  1502                              <1> 
  1503                              <1> .return_token:
  1504 00002D2D C60400              <1> 	mov byte [si], 0
  1505 00002D30 46                  <1> 	inc si
  1506 00002D31 89F7                <1> 	mov di, si
  1507 00002D33 5E                  <1> 	pop si
  1508 00002D34 C3                  <1> 	ret
  1509                              <1> 
  1510                              <1> .no_more:
  1511 00002D35 31FF                <1> 	xor di, di
  1512 00002D37 5E                  <1> 	pop si
  1513 00002D38 C3                  <1> 	ret
  1514                              <1> 
  1515                              <1> ; Converts an unsigned 32-bit integer into a string.
  1516                              <1> ; IN: EAX = unsigned int
  1517                              <1> ; OUT: AX = string location
  1518                              <1> 
  1519                              <1> os_32int_to_string:
  1520 00002D39 6660                <1> 	pushad
  1521                              <1> 
  1522 00002D3B 31C9                <1> 	xor cx, cx
  1523 00002D3D 66BB0A000000        <1> 	mov ebx, 10			; Set BX 10, for division and mod
  1524 00002D43 BF[682D]            <1> 	mov di, .t			; Get our pointer ready
  1525                              <1> 
  1526                              <1> .push:
  1527 00002D46 6631D2              <1> 	xor edx, edx
  1528 00002D49 66F7F3              <1> 	div ebx				; Remainder in DX, quotient in AX
  1529 00002D4C 41                  <1> 	inc cx				; Increase pop loop counter
  1530 00002D4D 6652                <1> 	push edx			; Push remainder, so as to reverse order when popping
  1531 00002D4F 6685C0              <1> 	test eax, eax		; Is quotient zero?
  1532 00002D52 75F2                <1> 	jnz .push			; If not, loop again
  1533                              <1> 
  1534                              <1> .pop:
  1535 00002D54 665A                <1> 	pop edx				; Pop off values in reverse order, and add 48 to make them digits
  1536 00002D56 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1537 00002D59 8815                <1> 	mov [di], dl
  1538 00002D5B 47                  <1> 	inc di
  1539 00002D5C 49                  <1> 	dec cx
  1540 00002D5D 75F5                <1> 	jnz .pop
  1541                              <1> 
  1542 00002D5F C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1543                              <1> 
  1544 00002D62 6661                <1> 	popad
  1545 00002D64 B8[682D]            <1> 	mov ax, .t			; Return location of string
  1546 00002D67 C3                  <1> 	ret
  1547                              <1> 
  1548                              <1> 
  1549 00002D68 00<rep Bh>          <1> 	.t times 11 db 0
  1550                              <1> 
  1551                              <1> ; Converts a string into a 32-bit integer.
  1552                              <1> ; IN: SI = string location
  1553                              <1> ; OUT: EAX = unsigned integer
  1554                              <1> 
  1555                              <1> os_string_to_32int:
  1556 00002D73 6660                <1> 	pushad
  1557 00002D75 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1558                              <1> 	
  1559                              <1> .loop:
  1560 00002D78 6650                <1> 	push eax
  1561 00002D7A AC                  <1> 	lodsb					; Load a byte from SI
  1562 00002D7B 88C1                <1> 	mov cl, al
  1563 00002D7D 6658                <1> 	pop eax
  1564 00002D7F 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1565 00002D82 0F841400            <1> 	je near .exit			; If we have, exit
  1566 00002D86 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1567 00002D89 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1568 00002D90 66F726[A92D]        <1> 	mul dword [.divisor]	; Multiply EAX by 10
  1569 00002D95 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1570 00002D98 EBDE                <1> 	jmp .loop				; Loop again
  1571                              <1> 	
  1572                              <1> .exit:
  1573 00002D9A 66A3[A52D]          <1> 	mov [.tmp_dword], eax
  1574 00002D9E 6661                <1> 	popad
  1575 00002DA0 66A1[A52D]          <1> 	mov eax, [.tmp_dword]
  1576 00002DA4 C3                  <1> 	ret
  1577                              <1> 	
  1578 00002DA5 00000000            <1> 	.tmp_dword	dd 0
  1579 00002DA9 0A000000            <1> 	.divisor	dd 10
  1580                              <1> 	
  1581                              <1> ; Prints a 32 bit integer in decimal.
  1582                              <1> ; IN: EAX = unsigned integer
  1583                              <1> ; OUT: nothing
  1584                              <1> 
  1585                              <1> os_print_32int:
  1586 00002DAD 6660                <1> 	pushad
  1587 00002DAF E887FF              <1> 	call os_32int_to_string
  1588 00002DB2 89C6                <1> 	mov si, ax
  1589 00002DB4 E8FFEA              <1> 	call os_print_string
  1590 00002DB7 6661                <1> 	popad
  1591 00002DB9 C3                  <1> 	ret
  1592                              <1> 	
  1593                              <1> ; ==================================================================
  1594                              <1> 
   822                                  	%INCLUDE "features/basic.asm"
   823                              <1> ; ==================================================================
   824                              <1> ; BASIC CODE INTERPRETER (4.5)
   825                              <1> ; ==================================================================
   826                              <1> 
   827                              <1> ; ------------------------------------------------------------------
   828                              <1> ; Token types
   829                              <1> 
   830                              <1> %DEFINE VARIABLE 1
   831                              <1> %DEFINE STRING_VAR 2
   832                              <1> %DEFINE NUMBER 3
   833                              <1> %DEFINE STRING 4
   834                              <1> %DEFINE QUOTE 5
   835                              <1> %DEFINE CHAR 6
   836                              <1> %DEFINE UNKNOWN 7
   837                              <1> %DEFINE LABEL 8
   838                              <1> 
   839                              <1> ; ------------------------------------------------------------------
   840                              <1> ; The BASIC interpreter execution starts here -- a parameter string
   841                              <1> ; is passed in SI and copied into the first string, unless SI = 0
   842                              <1> 
   843                              <1> os_run_basic:
   844 00002DBA C606820001          <1> 	mov byte [0082h], 1
   845                              <1> 	
   846 00002DBF 8926[D146]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
   847                              <1> 						; error printing code and quit in the middle
   848                              <1> 						; some nested loops, and we want to preserve
   849                              <1> 						; the stack
   850                              <1> 
   851 00002DC3 A3[D746]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
   852                              <1> 
   853 00002DC6 A3[D346]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
   854                              <1> 
   855 00002DC9 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
   856 00002DCB 4B                  <1> 	dec bx
   857 00002DCC 4B                  <1> 	dec bx
   858 00002DCD 891E[D546]          <1> 	mov word [prog_end], bx			; Make note of program end point
   859                              <1> 
   860                              <1> 
   861 00002DD1 E81D02              <1> 	call clear_ram				; Clear variables etc. from previous run
   862                              <1> 						; of a BASIC program
   863                              <1> 
   864 00002DD4 83FE00              <1> 	cmp si, 0				; Passed a parameter string?
   865 00002DD7 7406                <1> 	je mainloop
   866                              <1> 
   867 00002DD9 BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
   868 00002DDC E850FD              <1> 	call os_string_copy
   869                              <1> 
   870                              <1> 
   871                              <1> 
   872                              <1> mainloop:
   873 00002DDF E86D17              <1> 	call get_token				; Get a token from the start of the line
   874                              <1> 
   875 00002DE2 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
   876 00002DE5 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
   877                              <1> 
   878 00002DE7 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
   879 00002DEA 0F844702            <1> 	je near assign				; this is an assign (eg "X = Y + 5")
   880                              <1> 
   881 00002DEE 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
   882 00002DF1 0F844002            <1> 	je near assign
   883                              <1> 
   884 00002DF5 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
   885 00002DF8 74E5                <1> 	je mainloop
   886                              <1> 
   887 00002DFA B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
   888 00002DFC E96918              <1> 	jmp error
   889                              <1> 
   890                              <1> 
   891                              <1> .keyword:
   892 00002DFF BE007B              <1> 	mov si, token				; Start trying to match commands
   893                              <1> 
   894 00002E02 BF[DF46]            <1> 	mov di, alert_cmd
   895 00002E05 E886FD              <1> 	call os_string_compare
   896 00002E08 0F82CD04            <1> 	jc near do_alert
   897                              <1> 
   898 00002E0C BF[E546]            <1> 	mov di, askfile_cmd
   899 00002E0F E87CFD              <1> 	call os_string_compare
   900 00002E12 0F820005            <1> 	jc near do_askfile
   901                              <1> 
   902 00002E16 BF[ED46]            <1> 	mov di, break_cmd
   903 00002E19 E872FD              <1> 	call os_string_compare
   904 00002E1C 0F823105            <1> 	jc near do_break
   905                              <1> 
   906 00002E20 BF[F846]            <1> 	mov di, case_cmd
   907 00002E23 E868FD              <1> 	call os_string_compare
   908 00002E26 0F825305            <1> 	jc near do_case
   909                              <1> 
   910 00002E2A BF[F346]            <1> 	mov di, call_cmd
   911 00002E2D E85EFD              <1> 	call os_string_compare
   912 00002E30 0F822205            <1> 	jc near do_call
   913                              <1> 
   914 00002E34 BF[FD46]            <1> 	mov di, cls_cmd
   915 00002E37 E854FD              <1> 	call os_string_compare
   916 00002E3A 0F829105            <1> 	jc near do_cls
   917                              <1> 
   918 00002E3E BF[0147]            <1> 	mov di, cursor_cmd
   919 00002E41 E84AFD              <1> 	call os_string_compare
   920 00002E44 0F829B05            <1> 	jc near do_cursor
   921                              <1> 
   922 00002E48 BF[0847]            <1> 	mov di, curschar_cmd
   923 00002E4B E840FD              <1> 	call os_string_compare
   924 00002E4E 0F82C205            <1> 	jc near do_curschar
   925                              <1> 
   926 00002E52 BF[1147]            <1> 	mov di, curscol_cmd
   927 00002E55 E836FD              <1> 	call os_string_compare
   928 00002E58 0F82E005            <1> 	jc near do_curscol
   929                              <1> 
   930 00002E5C BF[1947]            <1> 	mov di, curspos_cmd
   931 00002E5F E82CFD              <1> 	call os_string_compare
   932 00002E62 0F82FE05            <1> 	jc near do_curspos
   933                              <1> 	
   934 00002E66 BF[2147]            <1> 	mov di, delete_cmd
   935 00002E69 E822FD              <1> 	call os_string_compare
   936 00002E6C 0F822C06            <1> 	jc near do_delete
   937                              <1> 	
   938 00002E70 BF[2847]            <1> 	mov di, do_cmd
   939 00002E73 E818FD              <1> 	call os_string_compare
   940 00002E76 0F827906            <1> 	jc near do_do
   941                              <1> 
   942 00002E7A BF[3047]            <1> 	mov di, end_cmd
   943 00002E7D E80EFD              <1> 	call os_string_compare
   944 00002E80 0F82B606            <1> 	jc near do_end
   945                              <1> 
   946 00002E84 BF[2B47]            <1> 	mov di, else_cmd
   947 00002E87 E804FD              <1> 	call os_string_compare
   948 00002E8A 0F828D06            <1> 	jc near do_else
   949                              <1> 
   950 00002E8E BF[3447]            <1> 	mov di, files_cmd
   951 00002E91 E8FAFC              <1> 	call os_string_compare
   952 00002E94 0F82B706            <1> 	jc near do_files
   953                              <1> 
   954 00002E98 BF[3A47]            <1> 	mov di, for_cmd
   955 00002E9B E8F0FC              <1> 	call os_string_compare
   956 00002E9E 0F821107            <1> 	jc near do_for
   957                              <1> 
   958 00002EA2 BF[4947]            <1> 	mov di, getkey_cmd
   959 00002EA5 E8E6FC              <1> 	call os_string_compare
   960 00002EA8 0F82B507            <1> 	jc near do_getkey
   961                              <1> 
   962 00002EAC BF[3E47]            <1> 	mov di, gosub_cmd
   963 00002EAF E8DCFC              <1> 	call os_string_compare
   964 00002EB2 0F82F307            <1> 	jc near do_gosub
   965                              <1> 
   966 00002EB6 BF[4447]            <1> 	mov di, goto_cmd
   967 00002EB9 E8D2FC              <1> 	call os_string_compare
   968 00002EBC 0F828608            <1> 	jc near do_goto
   969                              <1> 
   970 00002EC0 BF[5047]            <1> 	mov di, if_cmd
   971 00002EC3 E8C8FC              <1> 	call os_string_compare
   972 00002EC6 0F82FC08            <1> 	jc near do_if
   973                              <1> 
   974 00002ECA BF[5347]            <1> 	mov di, include_cmd
   975 00002ECD E8BEFC              <1> 	call os_string_compare
   976 00002ED0 0F82490A            <1> 	jc near do_include
   977                              <1> 
   978 00002ED4 BF[5B47]            <1> 	mov di, ink_cmd
   979 00002ED7 E8B4FC              <1> 	call os_string_compare
   980 00002EDA 0F826E0A            <1> 	jc near do_ink
   981                              <1> 
   982 00002EDE BF[5F47]            <1> 	mov di, input_cmd
   983 00002EE1 E8AAFC              <1> 	call os_string_compare
   984 00002EE4 0F82870A            <1> 	jc near do_input
   985                              <1> 	
   986 00002EE8 BF[6547]            <1> 	mov di, len_cmd
   987 00002EEB E8A0FC              <1> 	call os_string_compare
   988 00002EEE 0F82E90A            <1> 	jc near do_len
   989                              <1> 
   990 00002EF2 BF[6947]            <1> 	mov di, listbox_cmd
   991 00002EF5 E896FC              <1> 	call os_string_compare
   992 00002EF8 0F82270B            <1> 	jc near do_listbox
   993                              <1> 
   994 00002EFC BF[7147]            <1> 	mov di, load_cmd
   995 00002EFF E88CFC              <1> 	call os_string_compare
   996 00002F02 0F82B60B            <1> 	jc near do_load
   997                              <1> 
   998 00002F06 BF[7647]            <1> 	mov di, loop_cmd
   999 00002F09 E882FC              <1> 	call os_string_compare
  1000 00002F0C 0F821E0C            <1> 	jc near do_loop
  1001                              <1> 
  1002 00002F10 BF[7B47]            <1> 	mov di, move_cmd
  1003 00002F13 E878FC              <1> 	call os_string_compare
  1004 00002F16 0F82080D            <1> 	jc near do_move
  1005                              <1> 
  1006 00002F1A BF[8047]            <1> 	mov di, next_cmd
  1007 00002F1D E86EFC              <1> 	call os_string_compare
  1008 00002F20 0F82410D            <1> 	jc near do_next
  1009                              <1> 
  1010 00002F24 BF[8547]            <1> 	mov di, number_cmd
  1011 00002F27 E864FC              <1> 	call os_string_compare
  1012 00002F2A 0F82840D            <1> 	jc near do_number
  1013                              <1> 
  1014 00002F2E BF[8C47]            <1> 	mov di, page_cmd
  1015 00002F31 E85AFC              <1> 	call os_string_compare
  1016 00002F34 0F82E50D            <1> 	jc near do_page
  1017                              <1> 
  1018 00002F38 BF[9147]            <1> 	mov di, pause_cmd
  1019 00002F3B E850FC              <1> 	call os_string_compare
  1020 00002F3E 0F820A0E            <1> 	jc near do_pause
  1021                              <1> 
  1022 00002F42 BF[9747]            <1> 	mov di, peek_cmd
  1023 00002F45 E846FC              <1> 	call os_string_compare
  1024 00002F48 0F821E0E            <1> 	jc near do_peek
  1025                              <1> 
  1026 00002F4C BF[9C47]            <1> 	mov di, peekint_cmd
  1027 00002F4F E83CFC              <1> 	call os_string_compare
  1028 00002F52 0F82560E            <1> 	jc near do_peekint
  1029                              <1> 	
  1030 00002F56 BF[A447]            <1> 	mov di, poke_cmd
  1031 00002F59 E832FC              <1> 	call os_string_compare
  1032 00002F5C 0F82860E            <1> 	jc near do_poke
  1033                              <1> 	
  1034 00002F60 BF[A947]            <1> 	mov di, pokeint_cmd
  1035 00002F63 E828FC              <1> 	call os_string_compare
  1036 00002F66 0F82D40E            <1> 	jc near do_pokeint
  1037                              <1> 
  1038 00002F6A BF[B147]            <1> 	mov di, port_cmd
  1039 00002F6D E81EFC              <1> 	call os_string_compare
  1040 00002F70 0F820F0F            <1> 	jc near do_port
  1041                              <1> 
  1042 00002F74 BF[B647]            <1> 	mov di, print_cmd
  1043 00002F77 E814FC              <1> 	call os_string_compare
  1044 00002F7A 0F82870F            <1> 	jc near do_print
  1045                              <1> 
  1046 00002F7E BF[BC47]            <1> 	mov di, rand_cmd
  1047 00002F81 E80AFC              <1> 	call os_string_compare
  1048 00002F84 0F82AA10            <1> 	jc near do_rand
  1049                              <1> 
  1050 00002F88 BF[C147]            <1> 	mov di, read_cmd
  1051 00002F8B E800FC              <1> 	call os_string_compare
  1052 00002F8E 0F82F210            <1> 	jc near do_read
  1053                              <1> 
  1054 00002F92 BF[C647]            <1> 	mov di, rem_cmd
  1055 00002F95 E8F6FB              <1> 	call os_string_compare
  1056 00002F98 0F82BE11            <1> 	jc near do_rem
  1057                              <1> 
  1058 00002F9C BF[CA47]            <1> 	mov di, rename_cmd
  1059 00002F9F E8ECFB              <1> 	call os_string_compare
  1060 00002FA2 0F82C511            <1> 	jc near do_rename
  1061                              <1> 
  1062 00002FA6 BF[D147]            <1> 	mov di, return_cmd
  1063 00002FA9 E8E2FB              <1> 	call os_string_compare
  1064 00002FAC 0F827012            <1> 	jc near do_return
  1065                              <1> 
  1066 00002FB0 BF[D847]            <1> 	mov di, save_cmd
  1067 00002FB3 E8D8FB              <1> 	call os_string_compare
  1068 00002FB6 0F828712            <1> 	jc near do_save
  1069                              <1> 
  1070 00002FBA BF[DD47]            <1> 	mov di, serial_cmd
  1071 00002FBD E8CEFB              <1> 	call os_string_compare
  1072 00002FC0 0F823C13            <1> 	jc near do_serial
  1073                              <1> 
  1074 00002FC4 BF[E447]            <1> 	mov di, size_cmd
  1075 00002FC7 E8C4FB              <1> 	call os_string_compare
  1076 00002FCA 0F82D613            <1> 	jc near do_size
  1077                              <1> 
  1078 00002FCE BF[E947]            <1> 	mov di, sound_cmd
  1079 00002FD1 E8BAFB              <1> 	call os_string_compare
  1080 00002FD4 0F822114            <1> 	jc near do_sound
  1081                              <1> 	
  1082 00002FD8 BF[EF47]            <1> 	mov di, string_cmd
  1083 00002FDB E8B0FB              <1> 	call os_string_compare
  1084 00002FDE 0F825314            <1> 	jc near do_string
  1085                              <1> 
  1086 00002FE2 BF[F647]            <1> 	mov di, waitkey_cmd
  1087 00002FE5 E8A6FB              <1> 	call os_string_compare
  1088 00002FE8 0F82FE14            <1> 	jc near do_waitkey
  1089                              <1> 
  1090 00002FEC B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
  1091 00002FEE E97716              <1> 	jmp error
  1092                              <1> 
  1093                              <1> 
  1094                              <1> ; ------------------------------------------------------------------
  1095                              <1> ; CLEAR RAM
  1096                              <1> 
  1097                              <1> clear_ram:
  1098 00002FF1 60                  <1> 	pusha
  1099 00002FF2 B000                <1> 	mov al, 0
  1100                              <1> 
  1101 00002FF4 BF4C7A              <1> 	mov di, variables
  1102 00002FF7 B93400              <1> 	mov cx, 52
  1103 00002FFA F3AA                <1> 	rep stosb
  1104                              <1> 
  1105 00002FFC BF187A              <1> 	mov di, for_variables
  1106 00002FFF B93400              <1> 	mov cx, 52
  1107 00003002 F3AA                <1> 	rep stosb
  1108                              <1> 
  1109 00003004 BFE479              <1> 	mov di, for_code_points
  1110 00003007 B93400              <1> 	mov cx, 52
  1111 0000300A F3AA                <1> 	rep stosb
  1112                              <1> 	
  1113 0000300C BFD079              <1> 	mov di, do_loop_store
  1114 0000300F B90A00              <1> 	mov cx, 10
  1115 00003012 F3AA                <1> 	rep stosb
  1116                              <1> 
  1117 00003014 C606[4A48]00        <1> 	mov byte [gosub_depth], 0
  1118 00003019 C606[DA46]00        <1> 	mov byte [loop_in], 0
  1119                              <1> 
  1120 0000301E BFBC79              <1> 	mov di, gosub_points
  1121 00003021 B91400              <1> 	mov cx, 20
  1122 00003024 F3AA                <1> 	rep stosb
  1123                              <1> 
  1124 00003026 BF007C              <1> 	mov di, string_vars
  1125 00003029 B90004              <1> 	mov cx, 1024
  1126 0000302C F3AA                <1> 	rep stosb
  1127                              <1> 
  1128 0000302E C606[DC46]07        <1> 	mov byte [ink_colour], 7		; White ink
  1129                              <1> 
  1130 00003033 61                  <1> 	popa
  1131 00003034 C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> 
  1134                              <1> ; ------------------------------------------------------------------
  1135                              <1> ; ASSIGNMENT
  1136                              <1> 
  1137                              <1> assign:
  1138 00003035 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
  1139 00003038 0F84A700            <1> 	je .do_num_var
  1140                              <1> 
  1141 0000303C BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
  1142 0000303F B88000              <1> 	mov ax, 128
  1143 00003042 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1144 00003044 01C7                <1> 	add di, ax
  1145                              <1> 
  1146 00003046 57                  <1> 	push di
  1147                              <1> 
  1148 00003047 E80515              <1> 	call get_token
  1149 0000304A A0007B              <1> 	mov byte al, [token]
  1150 0000304D 3C3D                <1> 	cmp al, '='
  1151 0000304F 0F857D02            <1> 	jne near .error
  1152                              <1> 
  1153 00003053 E8F914              <1> 	call get_token				; See if second is quote
  1154 00003056 83F805              <1> 	cmp ax, QUOTE
  1155 00003059 7417                <1> 	je .second_is_quote
  1156                              <1> 
  1157 0000305B 83F802              <1> 	cmp ax, STRING_VAR
  1158 0000305E 0F856E02            <1> 	jne near .error
  1159                              <1> 
  1160 00003062 BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
  1161 00003065 B88000              <1> 	mov ax, 128
  1162 00003068 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1163 0000306A 01C6                <1> 	add si, ax
  1164                              <1> 
  1165 0000306C 5F                  <1> 	pop di
  1166 0000306D E8BFFA              <1> 	call os_string_copy
  1167                              <1> 
  1168 00003070 EB07                <1> 	jmp .string_check_for_more
  1169                              <1> 
  1170                              <1> 
  1171                              <1> .second_is_quote:
  1172 00003072 BE007B              <1> 	mov si, token
  1173 00003075 5F                  <1> 	pop di
  1174 00003076 E8B6FA              <1> 	call os_string_copy
  1175                              <1> 
  1176                              <1> 
  1177                              <1> .string_check_for_more:
  1178 00003079 57                  <1> 	push di
  1179 0000307A A1[D346]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1180 0000307D A3[D632]            <1> 	mov word [.tmp_loc], ax
  1181                              <1> 
  1182 00003080 E8CC14              <1> 	call get_token				; Any more to deal with in this assignment?
  1183 00003083 A0007B              <1> 	mov byte al, [token]
  1184 00003086 3C2B                <1> 	cmp al, '+'
  1185 00003088 740A                <1> 	je .string_theres_more
  1186                              <1> 
  1187 0000308A A1[D632]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1188 0000308D A3[D346]            <1> 	mov word [prog], ax			; that we just grabbed
  1189                              <1> 
  1190 00003090 5F                  <1> 	pop di
  1191 00003091 E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
  1192                              <1> 
  1193                              <1> 
  1194                              <1> .string_theres_more:
  1195 00003094 E8B814              <1> 	call get_token
  1196 00003097 83F802              <1> 	cmp ax, STRING_VAR
  1197 0000309A 740D                <1> 	je .another_string_var
  1198 0000309C 83F805              <1> 	cmp ax, QUOTE
  1199 0000309F 741E                <1> 	je .another_quote
  1200 000030A1 83F801              <1> 	cmp ax, VARIABLE
  1201 000030A4 7426                <1> 	je .add_number_var
  1202 000030A6 E92702              <1> 	jmp .error
  1203                              <1> 
  1204                              <1> 
  1205                              <1> .another_string_var:
  1206 000030A9 5F                  <1> 	pop di
  1207                              <1> 
  1208 000030AA BE007C              <1> 	mov si, string_vars
  1209 000030AD B88000              <1> 	mov ax, 128
  1210 000030B0 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1211 000030B2 01C6                <1> 	add si, ax
  1212                              <1> 
  1213 000030B4 89F8                <1> 	mov ax, di
  1214 000030B6 89F9                <1> 	mov cx, di
  1215 000030B8 89F3                <1> 	mov bx, si
  1216 000030BA E87BFA              <1> 	call os_string_join
  1217                              <1> 
  1218 000030BD EBBA                <1> 	jmp .string_check_for_more
  1219                              <1> 
  1220                              <1> 
  1221                              <1> 
  1222                              <1> .another_quote:
  1223 000030BF 5F                  <1> 	pop di
  1224                              <1> 
  1225 000030C0 89F8                <1> 	mov ax, di
  1226 000030C2 89F9                <1> 	mov cx, di
  1227 000030C4 BB007B              <1> 	mov bx, token
  1228 000030C7 E86EFA              <1> 	call os_string_join
  1229                              <1> 
  1230 000030CA EBAD                <1> 	jmp .string_check_for_more
  1231                              <1> 
  1232                              <1> 
  1233                              <1> .add_number_var:
  1234 000030CC 31C0                <1> 	xor ax, ax
  1235 000030CE A0007B              <1> 	mov byte al, [token]
  1236 000030D1 E85F14              <1> 	call get_var
  1237 000030D4 E856FB              <1> 	call os_int_to_string
  1238                              <1> 
  1239 000030D7 89C3                <1> 	mov bx, ax
  1240 000030D9 5F                  <1> 	pop di
  1241 000030DA 89F8                <1> 	mov ax, di
  1242 000030DC 89F9                <1> 	mov cx, di
  1243 000030DE E857FA              <1> 	call os_string_join
  1244                              <1> 
  1245 000030E1 EB96                <1> 	jmp .string_check_for_more
  1246                              <1> 	
  1247                              <1> 
  1248                              <1> 
  1249                              <1> 
  1250                              <1> .do_num_var:
  1251 000030E3 31C0                <1> 	xor ax, ax
  1252 000030E5 A0007B              <1> 	mov byte al, [token]
  1253 000030E8 A2[D532]            <1> 	mov byte [.tmp], al
  1254                              <1> 
  1255 000030EB E86114              <1> 	call get_token
  1256 000030EE A0007B              <1> 	mov byte al, [token]
  1257 000030F1 3C3D                <1> 	cmp al, '='
  1258 000030F3 0F85D901            <1> 	jne near .error
  1259                              <1> 
  1260 000030F7 E85514              <1> 	call get_token
  1261 000030FA 83F803              <1> 	cmp ax, NUMBER
  1262 000030FD 744D                <1> 	je .second_is_num
  1263                              <1> 
  1264 000030FF 83F801              <1> 	cmp ax, VARIABLE
  1265 00003102 7436                <1> 	je .second_is_variable
  1266                              <1> 
  1267 00003104 83F804              <1> 	cmp ax, STRING
  1268 00003107 0F842F01            <1> 	je near .second_is_string
  1269                              <1> 
  1270 0000310B 83F807              <1> 	cmp ax, UNKNOWN
  1271 0000310E 0F85BE01            <1> 	jne near .error
  1272                              <1> 
  1273 00003112 A0007B              <1> 	mov byte al, [token]			; Address of string var?
  1274 00003115 3C26                <1> 	cmp al, '&'
  1275 00003117 0F85B501            <1> 	jne near .error
  1276                              <1> 
  1277 0000311B E83114              <1> 	call get_token				; Let's see if there's a string var
  1278 0000311E 83F802              <1> 	cmp ax, STRING_VAR
  1279 00003121 0F85AB01            <1> 	jne near .error
  1280                              <1> 
  1281 00003125 BF007C              <1> 	mov di, string_vars
  1282 00003128 B88000              <1> 	mov ax, 128
  1283 0000312B F7E3                <1> 	mul bx
  1284 0000312D 01C7                <1> 	add di, ax
  1285                              <1> 
  1286 0000312F 89FB                <1> 	mov bx, di
  1287                              <1> 
  1288 00003131 A0[D532]            <1> 	mov byte al, [.tmp]
  1289 00003134 E80914              <1> 	call set_var
  1290                              <1> 
  1291 00003137 E9A5FC              <1> 	jmp mainloop
  1292                              <1> 
  1293                              <1> 
  1294                              <1> .second_is_variable:
  1295 0000313A 31C0                <1> 	xor ax, ax
  1296 0000313C A0007B              <1> 	mov byte al, [token]
  1297                              <1> 
  1298 0000313F E8F113              <1> 	call get_var
  1299 00003142 89C3                <1> 	mov bx, ax
  1300 00003144 A0[D532]            <1> 	mov byte al, [.tmp]
  1301 00003147 E8F613              <1> 	call set_var
  1302                              <1> 
  1303 0000314A EB10                <1> 	jmp .check_for_more
  1304                              <1> 
  1305                              <1> 
  1306                              <1> .second_is_num:
  1307 0000314C BE007B              <1> 	mov si, token
  1308 0000314F E890FA              <1> 	call os_string_to_int
  1309                              <1> 
  1310 00003152 89C3                <1> 	mov bx, ax				; Number to insert in variable table
  1311                              <1> 
  1312 00003154 31C0                <1> 	xor ax, ax
  1313 00003156 A0[D532]            <1> 	mov byte al, [.tmp]
  1314                              <1> 
  1315 00003159 E8E413              <1> 	call set_var
  1316                              <1> 
  1317                              <1> 
  1318                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
  1319                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
  1320                              <1> 	; there's a delimiter...
  1321                              <1> 
  1322                              <1> .check_for_more:
  1323 0000315C A1[D346]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1324 0000315F A3[D632]            <1> 	mov word [.tmp_loc], ax
  1325                              <1> 
  1326 00003162 E8EA13              <1> 	call get_token				; Any more to deal with in this assignment?
  1327 00003165 A0007B              <1> 	mov byte al, [token]
  1328 00003168 3C2B                <1> 	cmp al, '+'
  1329 0000316A 7419                <1> 	je .theres_more
  1330 0000316C 3C2D                <1> 	cmp al, '-'
  1331 0000316E 7415                <1> 	je .theres_more
  1332 00003170 3C2A                <1> 	cmp al, '*'
  1333 00003172 7411                <1> 	je .theres_more
  1334 00003174 3C2F                <1> 	cmp al, '/'
  1335 00003176 740D                <1> 	je .theres_more
  1336 00003178 3C25                <1> 	cmp al, '%'
  1337 0000317A 7409                <1> 	je .theres_more
  1338                              <1> 
  1339 0000317C A1[D632]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1340 0000317F A3[D346]            <1> 	mov word [prog], ax			; that we just grabbed
  1341                              <1> 
  1342 00003182 E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
  1343                              <1> 
  1344                              <1> 
  1345                              <1> .theres_more:
  1346 00003185 A2[D832]            <1> 	mov byte [.delim], al
  1347                              <1> 
  1348 00003188 E8C413              <1> 	call get_token
  1349 0000318B 83F801              <1> 	cmp ax, VARIABLE
  1350 0000318E 7459                <1> 	je .handle_variable
  1351                              <1> 
  1352 00003190 BE007B              <1> 	mov si, token
  1353 00003193 E84CFA              <1> 	call os_string_to_int
  1354 00003196 89C3                <1> 	mov bx, ax
  1355                              <1> 
  1356 00003198 31C0                <1> 	xor ax, ax
  1357 0000319A A0[D532]            <1> 	mov byte al, [.tmp]
  1358                              <1> 
  1359 0000319D E89313              <1> 	call get_var				; This also points SI at right place in variable table
  1360                              <1> 
  1361 000031A0 803E[D832]2B        <1> 	cmp byte [.delim], '+'
  1362 000031A5 7504                <1> 	jne .not_plus
  1363                              <1> 
  1364 000031A7 01D8                <1> 	add ax, bx
  1365 000031A9 EB2E                <1> 	jmp .finish
  1366                              <1> 
  1367                              <1> .not_plus:
  1368 000031AB 803E[D832]2D        <1> 	cmp byte [.delim], '-'
  1369 000031B0 7504                <1> 	jne .not_minus
  1370                              <1> 
  1371 000031B2 29D8                <1> 	sub ax, bx
  1372 000031B4 EB23                <1> 	jmp .finish
  1373                              <1> 
  1374                              <1> .not_minus:
  1375 000031B6 803E[D832]2A        <1> 	cmp byte [.delim], '*'
  1376 000031BB 7504                <1> 	jne .not_times
  1377                              <1> 
  1378 000031BD F7E3                <1> 	mul bx
  1379 000031BF EB18                <1> 	jmp .finish
  1380                              <1> 
  1381                              <1> .not_times:
  1382 000031C1 803E[D832]2F        <1> 	cmp byte [.delim], '/'
  1383 000031C6 750B                <1> 	jne .not_divide
  1384                              <1> 
  1385 000031C8 83FB00              <1> 	cmp bx, 0
  1386 000031CB 7417                <1> 	je .divide_zero
  1387                              <1> 	
  1388 000031CD 31D2                <1> 	xor dx, dx
  1389 000031CF F7F3                <1> 	div bx
  1390 000031D1 EB06                <1> 	jmp .finish
  1391                              <1> 
  1392                              <1> .not_divide:
  1393 000031D3 31D2                <1> 	xor dx, dx
  1394 000031D5 F7F3                <1> 	div bx
  1395 000031D7 89D0                <1> 	mov ax, dx				; Get remainder
  1396                              <1> 
  1397                              <1> .finish:
  1398 000031D9 89C3                <1> 	mov bx, ax
  1399 000031DB A0[D532]            <1> 	mov byte al, [.tmp]
  1400 000031DE E85F13              <1> 	call set_var
  1401                              <1> 
  1402 000031E1 E978FF              <1> 	jmp .check_for_more
  1403                              <1> 
  1404                              <1> .divide_zero:
  1405 000031E4 B302                <1> 	mov bl, err_divide_by_zero
  1406 000031E6 E97F14              <1> 	jmp error
  1407                              <1> 	
  1408                              <1> .handle_variable:
  1409 000031E9 31C0                <1> 	xor ax, ax
  1410 000031EB A0007B              <1> 	mov byte al, [token]
  1411                              <1> 
  1412 000031EE E84213              <1> 	call get_var
  1413                              <1> 
  1414 000031F1 89C3                <1> 	mov bx, ax
  1415                              <1> 
  1416 000031F3 31C0                <1> 	xor ax, ax
  1417 000031F5 A0[D532]            <1> 	mov byte al, [.tmp]
  1418                              <1> 
  1419 000031F8 E83813              <1> 	call get_var
  1420                              <1> 
  1421 000031FB 803E[D832]2B        <1> 	cmp byte [.delim], '+'
  1422 00003200 7504                <1> 	jne .vnot_plus
  1423                              <1> 
  1424 00003202 01D8                <1> 	add ax, bx
  1425 00003204 EB29                <1> 	jmp .vfinish
  1426                              <1> 
  1427                              <1> .vnot_plus:
  1428 00003206 803E[D832]2D        <1> 	cmp byte [.delim], '-'
  1429 0000320B 7504                <1> 	jne .vnot_minus
  1430                              <1> 
  1431 0000320D 29D8                <1> 	sub ax, bx
  1432 0000320F EB1E                <1> 	jmp .vfinish
  1433                              <1> 
  1434                              <1> .vnot_minus:
  1435 00003211 803E[D832]2A        <1> 	cmp byte [.delim], '*'
  1436 00003216 7504                <1> 	jne .vnot_times
  1437                              <1> 
  1438 00003218 F7E3                <1> 	mul bx
  1439 0000321A EB13                <1> 	jmp .vfinish
  1440                              <1> 
  1441                              <1> .vnot_times:
  1442 0000321C 803E[D832]2F        <1> 	cmp byte [.delim], '/'
  1443 00003221 7506                <1> 	jne .vnot_divide
  1444                              <1> 
  1445 00003223 31D2                <1> 	xor dx, dx
  1446 00003225 F7F3                <1> 	div bx
  1447 00003227 EBB0                <1> 	jmp .finish
  1448                              <1> 
  1449                              <1> .vnot_divide:
  1450 00003229 31D2                <1> 	xor dx, dx
  1451 0000322B F7F3                <1> 	div bx
  1452 0000322D 89D0                <1> 	mov ax, dx				; Get remainder
  1453                              <1> 
  1454                              <1> .vfinish:
  1455 0000322F 89C3                <1> 	mov bx, ax
  1456 00003231 A0[D532]            <1> 	mov byte al, [.tmp]
  1457 00003234 E80913              <1> 	call set_var
  1458                              <1> 
  1459 00003237 E922FF              <1> 	jmp .check_for_more
  1460                              <1> 
  1461                              <1> 
  1462                              <1> .second_is_string:				; These are "X = word" functions
  1463 0000323A BF007B              <1> 	mov di, token
  1464                              <1> 	
  1465 0000323D BE[1B48]            <1> 	mov si, ink_keyword
  1466 00003240 E84BF9              <1> 	call os_string_compare
  1467 00003243 742A                <1> 	je .is_ink
  1468                              <1> 	
  1469 00003245 BE[1F48]            <1> 	mov si, progstart_keyword
  1470 00003248 E843F9              <1> 	call os_string_compare
  1471 0000324B 7433                <1> 	je .is_progstart
  1472                              <1> 
  1473 0000324D BE[2948]            <1> 	mov si, ramstart_keyword
  1474 00003250 E83BF9              <1> 	call os_string_compare
  1475 00003253 743A                <1> 	je .is_ramstart
  1476                              <1> 
  1477 00003255 BE[3248]            <1> 	mov si, timer_keyword
  1478 00003258 E833F9              <1> 	call os_string_compare
  1479 0000325B 7444                <1> 	je .is_timer
  1480                              <1> 	
  1481 0000325D BE[3848]            <1> 	mov si, variables_keyword
  1482 00003260 E82BF9              <1> 	call os_string_compare
  1483 00003263 744E                <1> 	je .is_variables
  1484                              <1> 	
  1485 00003265 BE[4248]            <1> 	mov si, version_keyword
  1486 00003268 E823F9              <1> 	call os_string_compare
  1487 0000326B 7454                <1> 	je .is_version
  1488                              <1> 
  1489 0000326D EB61                <1> 	jmp .error
  1490                              <1> 
  1491                              <1> 
  1492                              <1> .is_ink:
  1493 0000326F 0FB606[D532]        <1> 	movzx ax, byte [.tmp]
  1494                              <1> 	
  1495 00003274 31C0                <1> 	xor ax, ax
  1496 00003276 8A1E[DC46]          <1> 	mov byte bl, [ink_colour]
  1497 0000327A E8C312              <1> 	call set_var
  1498                              <1> 	
  1499 0000327D E95FFB              <1> 	jmp mainloop
  1500                              <1> 
  1501                              <1> 
  1502                              <1> .is_progstart:
  1503 00003280 0FB606[D532]        <1> 	movzx ax, byte [.tmp]
  1504                              <1> 
  1505 00003285 8B1E[D746]          <1> 	mov word bx, [load_point]
  1506 00003289 E8B412              <1> 	call set_var
  1507                              <1> 
  1508 0000328C E950FB              <1> 	jmp mainloop
  1509                              <1> 
  1510                              <1> 
  1511                              <1> .is_ramstart:
  1512 0000328F 31C0                <1> 	xor ax, ax
  1513 00003291 A0[D532]            <1> 	mov byte al, [.tmp]
  1514                              <1> 
  1515 00003294 8B1E[D546]          <1> 	mov word bx, [prog_end]
  1516 00003298 43                  <1> 	inc bx
  1517 00003299 43                  <1> 	inc bx
  1518 0000329A 43                  <1> 	inc bx
  1519 0000329B E8A212              <1> 	call set_var
  1520                              <1> 
  1521 0000329E E93EFB              <1> 	jmp mainloop
  1522                              <1> 
  1523                              <1> 
  1524                              <1> .is_timer:
  1525 000032A1 B400                <1> 	mov ah, 0
  1526 000032A3 E8D4E4              <1> 	call os_int_1Ah
  1527 000032A6 89D3                <1> 	mov bx, dx
  1528                              <1> 
  1529 000032A8 31C0                <1> 	xor ax, ax
  1530 000032AA A0[D532]            <1> 	mov byte al, [.tmp]
  1531 000032AD E89012              <1> 	call set_var
  1532                              <1> 
  1533 000032B0 E92CFB              <1> 	jmp mainloop
  1534                              <1> 
  1535                              <1> 
  1536                              <1> .is_variables:
  1537 000032B3 BB[DA46]            <1> 	mov bx, vars_loc
  1538 000032B6 31C0                <1> 	xor ax, ax
  1539 000032B8 A0[D532]            <1> 	mov byte al, [.tmp]
  1540 000032BB E88212              <1> 	call set_var
  1541                              <1> 
  1542 000032BE E91EFB              <1> 	jmp mainloop
  1543                              <1> 
  1544                              <1> 
  1545                              <1> .is_version:
  1546 000032C1 B0FF                <1> 	mov al, 255
  1547                              <1> 	
  1548 000032C3 B700                <1> 	mov bh, 0
  1549 000032C5 88C3                <1> 	mov bl, al
  1550 000032C7 A0[D532]            <1> 	mov al, [.tmp]
  1551 000032CA E87312              <1> 	call set_var
  1552                              <1> 	
  1553 000032CD E90FFB              <1> 	jmp mainloop 
  1554                              <1> 
  1555                              <1> 
  1556                              <1> .error:
  1557 000032D0 B314                <1> 	mov bl, err_syntax
  1558 000032D2 E99313              <1> 	jmp error
  1559                              <1> 
  1560                              <1> 
  1561 000032D5 00                  <1> 	.tmp		db 0
  1562 000032D6 0000                <1> 	.tmp_loc	dw 0
  1563 000032D8 00                  <1> 	.delim		db 0
  1564                              <1> 
  1565                              <1> 
  1566                              <1> ; ==================================================================
  1567                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
  1568                              <1> 
  1569                              <1> ; ------------------------------------------------------------------
  1570                              <1> ; ALERT
  1571                              <1> 
  1572                              <1> do_alert:
  1573 000032D9 8A3E[DD46]          <1> 	mov bh, [work_page]			; Store the cursor position
  1574 000032DD B403                <1> 	mov ah, 03h
  1575 000032DF CD10                <1> 	int 10h
  1576                              <1> 
  1577 000032E1 E86B12              <1> 	call get_token
  1578                              <1> 
  1579 000032E4 83F805              <1> 	cmp ax, QUOTE
  1580 000032E7 7416                <1> 	je .is_quote
  1581                              <1> 	
  1582 000032E9 83F802              <1> 	cmp ax, STRING_VAR
  1583 000032EC 7405                <1> 	je .is_string
  1584                              <1> 
  1585 000032EE B314                <1> 	mov bl, err_syntax
  1586 000032F0 E97513              <1> 	jmp error
  1587                              <1> 
  1588                              <1> .is_string:
  1589 000032F3 BE007C              <1> 	mov si, string_vars
  1590 000032F6 B88000              <1> 	mov ax, 128
  1591 000032F9 F7E3                <1> 	mul bx
  1592 000032FB 01F0                <1> 	add ax, si
  1593 000032FD EB03                <1> 	jmp .display_message
  1594                              <1> 	
  1595                              <1> .is_quote:
  1596 000032FF B8007B              <1> 	mov ax, token				; First string for alert box
  1597                              <1> 	
  1598                              <1> .display_message:
  1599 00003302 31DB                <1> 	xor bx, bx				; Others are blank
  1600 00003304 31C9                <1> 	xor cx, cx
  1601 00003306 31D2                <1> 	xor dx, dx				; One-choice box
  1602 00003308 E803EE              <1> 	call os_dialog_box
  1603                              <1> 	
  1604 0000330B 8A3E[DD46]          <1> 	mov bh, [work_page]			; Move the cursor back
  1605 0000330F B402                <1> 	mov ah, 02h
  1606 00003311 CD10                <1> 	int 10h
  1607                              <1> 	
  1608 00003313 E9C9FA              <1> 	jmp mainloop
  1609                              <1> 
  1610                              <1> 
  1611                              <1> ;-------------------------------------------------------------------
  1612                              <1> ; ASKFILE
  1613                              <1> 
  1614                              <1> do_askfile:
  1615 00003316 8A3E[DD46]          <1> 	mov bh, [work_page]			; Store the cursor position
  1616 0000331A B403                <1> 	mov ah, 03h
  1617 0000331C CD10                <1> 	int 10h
  1618                              <1> 	
  1619 0000331E E82E12              <1> 	call get_token
  1620                              <1> 	
  1621 00003321 83F802              <1> 	cmp ax, STRING_VAR
  1622 00003324 7524                <1> 	jne .error
  1623                              <1> 	
  1624 00003326 BE007C              <1> 	mov si, string_vars			; Get the string location
  1625 00003329 B88000              <1> 	mov ax, 128
  1626 0000332C F7E3                <1> 	mul bx
  1627 0000332E 01F0                <1> 	add ax, si
  1628 00003330 A3[4F33]            <1> 	mov word [.tmp], ax
  1629                              <1> 	
  1630 00003333 E853E6              <1> 	call os_file_selector			; Present the selector
  1631                              <1> 	
  1632 00003336 8B3E[4F33]          <1> 	mov word di, [.tmp]			; Copy the string
  1633 0000333A 89C6                <1> 	mov si, ax
  1634 0000333C E8F0F7              <1> 	call os_string_copy
  1635                              <1> 
  1636 0000333F 8A3E[DD46]          <1> 	mov bh, [work_page]			; Move the cursor back
  1637 00003343 B402                <1> 	mov ah, 02h
  1638 00003345 CD10                <1> 	int 10h
  1639                              <1> 	
  1640 00003347 E995FA              <1> 	jmp mainloop
  1641                              <1> 	
  1642                              <1> .error:
  1643 0000334A B314                <1> 	mov bl, err_syntax
  1644 0000334C E91913              <1> 	jmp error
  1645                              <1> 
  1646                              <1> .data:
  1647 0000334F 0000                <1> 	.tmp					dw 0
  1648                              <1> 
  1649                              <1> 
  1650                              <1> ; ------------------------------------------------------------------
  1651                              <1> ; BREAK
  1652                              <1> 
  1653                              <1> do_break:
  1654 00003351 B3[BB]              <1> 	mov bl, err_break
  1655 00003353 E91213              <1> 	jmp error
  1656                              <1> 
  1657                              <1> 
  1658                              <1> ; ------------------------------------------------------------------
  1659                              <1> ; CALL
  1660                              <1> 
  1661                              <1> do_call:
  1662 00003356 E8F611              <1> 	call get_token
  1663 00003359 83F803              <1> 	cmp ax, NUMBER
  1664 0000335C 740A                <1> 	je .is_number
  1665                              <1> 
  1666 0000335E 31C0                <1> 	xor ax, ax
  1667 00003360 A0007B              <1> 	mov byte al, [token]
  1668 00003363 E8CD11              <1> 	call get_var
  1669 00003366 EB06                <1> 	jmp .execute_call
  1670                              <1> 
  1671                              <1> .is_number:
  1672 00003368 BE007B              <1> 	mov si, token
  1673 0000336B E874F8              <1> 	call os_string_to_int
  1674                              <1> 
  1675                              <1> .execute_call:
  1676 0000336E 31DB                <1> 	xor bx, bx
  1677 00003370 31C9                <1> 	xor cx, cx
  1678 00003372 31D2                <1> 	xor dx, dx
  1679 00003374 31FF                <1> 	xor di, di
  1680 00003376 31F6                <1> 	xor si, si
  1681                              <1> 
  1682 00003378 FFD0                <1> 	call ax
  1683                              <1> 
  1684 0000337A E962FA              <1> 	jmp mainloop
  1685                              <1> 
  1686                              <1> 
  1687                              <1> ; ------------------------------------------------------------------
  1688                              <1> ; CASE
  1689                              <1> 
  1690                              <1> do_case:
  1691 0000337D E8CF11              <1> 	call get_token
  1692 00003380 83F804              <1> 	cmp ax, STRING
  1693 00003383 7545                <1> 	jne .error
  1694                              <1> 	
  1695 00003385 BE007B              <1> 	mov si, token
  1696                              <1> 
  1697 00003388 BF[1548]            <1> 	mov di, upper_keyword
  1698 0000338B E800F8              <1> 	call os_string_compare
  1699 0000338E 720A                <1> 	jc .uppercase
  1700                              <1> 	
  1701 00003390 BF[0F48]            <1> 	mov di, lower_keyword
  1702 00003393 E8F8F7              <1> 	call os_string_compare
  1703 00003396 721A                <1> 	jc .lowercase
  1704                              <1> 	
  1705 00003398 EB30                <1> 	jmp .error
  1706                              <1> 	
  1707                              <1> .uppercase:
  1708 0000339A E8B211              <1> 	call get_token
  1709 0000339D 83F802              <1> 	cmp ax, STRING_VAR
  1710 000033A0 7528                <1> 	jne .error
  1711                              <1> 	
  1712 000033A2 BE007C              <1> 	mov si, string_vars
  1713 000033A5 B88000              <1> 	mov ax, 128
  1714 000033A8 F7E3                <1> 	mul bx
  1715 000033AA 01F0                <1> 	add ax, si
  1716                              <1> 	
  1717 000033AC E846F7              <1> 	call os_string_uppercase
  1718                              <1> 	
  1719 000033AF E92DFA              <1> 	jmp mainloop
  1720                              <1> 	
  1721                              <1> .lowercase:
  1722 000033B2 E89A11              <1> 	call get_token
  1723 000033B5 83F802              <1> 	cmp ax, STRING_VAR
  1724 000033B8 7510                <1> 	jne .error
  1725                              <1> 	
  1726 000033BA BE007C              <1> 	mov si, string_vars
  1727 000033BD B88000              <1> 	mov ax, 128
  1728 000033C0 F7E3                <1> 	mul bx
  1729 000033C2 01F0                <1> 	add ax, si
  1730                              <1> 	
  1731 000033C4 E84BF7              <1> 	call os_string_lowercase
  1732                              <1> 	
  1733 000033C7 E915FA              <1> 	jmp mainloop
  1734                              <1> 	
  1735                              <1> .error:
  1736 000033CA B314                <1> 	mov bl, err_syntax
  1737 000033CC E99912              <1> 	jmp error
  1738                              <1> 
  1739                              <1> 
  1740                              <1> ; ------------------------------------------------------------------
  1741                              <1> ; CLS
  1742                              <1> 
  1743                              <1> do_cls:
  1744 000033CF B405                <1> 	mov ah, 5
  1745 000033D1 A0[DD46]            <1> 	mov byte al, [work_page]
  1746 000033D4 CD10                <1> 	int 10h
  1747                              <1> 
  1748 000033D6 E838E5              <1> 	call os_clear_screen
  1749                              <1> 
  1750 000033D9 B405                <1> 	mov ah, 5
  1751 000033DB A0[DE46]            <1> 	mov byte al, [disp_page]
  1752 000033DE CD10                <1> 	int 10h
  1753                              <1> 
  1754 000033E0 E9FCF9              <1> 	jmp mainloop
  1755                              <1> 
  1756                              <1> 
  1757                              <1> 
  1758                              <1> ; ------------------------------------------------------------------
  1759                              <1> ; CURSOR
  1760                              <1> 
  1761                              <1> do_cursor:
  1762 000033E3 E86911              <1> 	call get_token
  1763                              <1> 
  1764 000033E6 BE007B              <1> 	mov si, token
  1765 000033E9 BF[0D34]            <1> 	mov di, .on_str
  1766 000033EC E89FF7              <1> 	call os_string_compare
  1767 000033EF 7210                <1> 	jc .turn_on
  1768                              <1> 
  1769 000033F1 BE007B              <1> 	mov si, token
  1770 000033F4 BF[1034]            <1> 	mov di, .off_str
  1771 000033F7 E894F7              <1> 	call os_string_compare
  1772 000033FA 720B                <1> 	jc .turn_off
  1773                              <1> 
  1774 000033FC B314                <1> 	mov bl, err_syntax
  1775 000033FE E96712              <1> 	jmp error
  1776                              <1> 
  1777                              <1> .turn_on:
  1778 00003401 E858E5              <1> 	call os_show_cursor
  1779 00003404 E9D8F9              <1> 	jmp mainloop
  1780                              <1> 
  1781                              <1> .turn_off:
  1782 00003407 E85DE5              <1> 	call os_hide_cursor
  1783 0000340A E9D2F9              <1> 	jmp mainloop
  1784                              <1> 
  1785                              <1> 
  1786 0000340D 4F4E00              <1> 	.on_str db "ON", 0
  1787 00003410 4F464600            <1> 	.off_str db "OFF", 0
  1788                              <1> 
  1789                              <1> 
  1790                              <1> ; ------------------------------------------------------------------
  1791                              <1> ; CURSCHAR
  1792                              <1> 
  1793                              <1> do_curschar:
  1794 00003414 E83811              <1> 	call get_token
  1795                              <1> 
  1796 00003417 83F801              <1> 	cmp ax, VARIABLE
  1797 0000341A 7405                <1> 	je .is_variable
  1798                              <1> 
  1799 0000341C B314                <1> 	mov bl, err_syntax
  1800 0000341E E94712              <1> 	jmp error
  1801                              <1> 
  1802                              <1> .is_variable:
  1803 00003421 31C0                <1> 	xor ax, ax
  1804 00003423 A0007B              <1> 	mov byte al, [token]
  1805                              <1> 
  1806 00003426 50                  <1> 	push ax				; Store variable we're going to use
  1807                              <1> 
  1808 00003427 B408                <1> 	mov ah, 08h
  1809 00003429 31DB                <1> 	xor bx, bx
  1810 0000342B 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  1811 0000342F CD10                <1> 	int 10h				; Get char at current cursor location
  1812                              <1> 
  1813 00003431 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
  1814 00003433 88C3                <1> 	mov bl, al
  1815                              <1> 
  1816 00003435 58                  <1> 	pop ax				; Get the variable back
  1817                              <1> 
  1818 00003436 E80711              <1> 	call set_var			; And store the value
  1819                              <1> 
  1820 00003439 E9A3F9              <1> 	jmp mainloop
  1821                              <1> 
  1822                              <1> 
  1823                              <1> ; ------------------------------------------------------------------
  1824                              <1> ; CURSCOL
  1825                              <1> 
  1826                              <1> do_curscol:
  1827 0000343C E81011              <1> 	call get_token
  1828                              <1> 
  1829 0000343F 83F801              <1> 	cmp ax, VARIABLE
  1830 00003442 751B                <1> 	jne .error
  1831                              <1> 
  1832 00003444 B400                <1> 	mov ah, 0
  1833 00003446 A0007B              <1> 	mov byte al, [token]
  1834 00003449 50                  <1> 	push ax
  1835                              <1> 
  1836 0000344A B408                <1> 	mov ah, 8
  1837 0000344C 31DB                <1> 	xor bx, bx
  1838 0000344E 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  1839 00003452 CD10                <1> 	int 10h
  1840 00003454 B700                <1> 	mov bh, 0
  1841 00003456 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1842                              <1> 
  1843 00003458 58                  <1> 	pop ax
  1844 00003459 E8E410              <1> 	call set_var
  1845                              <1> 
  1846 0000345C E980F9              <1> 	jmp mainloop
  1847                              <1> 
  1848                              <1> .error:
  1849 0000345F B314                <1> 	mov bl, err_syntax
  1850 00003461 E90412              <1> 	jmp error
  1851                              <1> 
  1852                              <1> 
  1853                              <1> ; ------------------------------------------------------------------
  1854                              <1> ; CURSPOS
  1855                              <1> 
  1856                              <1> do_curspos:
  1857 00003464 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  1858 00003468 B403                <1> 	mov ah, 3
  1859 0000346A CD10                <1> 	int 10h
  1860                              <1> 
  1861 0000346C E8E010              <1> 	call get_token
  1862 0000346F 83F801              <1> 	cmp ax, VARIABLE
  1863 00003472 7523                <1> 	jne .error
  1864                              <1> 
  1865 00003474 0FB606007B          <1> 	movzx ax, byte [token]
  1866 00003479 31DB                <1> 	xor bx, bx
  1867 0000347B 88D3                <1> 	mov bl, dl
  1868 0000347D E8C010              <1> 	call set_var
  1869                              <1> 
  1870 00003480 E8CC10              <1> 	call get_token
  1871 00003483 83F801              <1> 	cmp ax, VARIABLE
  1872 00003486 750F                <1> 	jne .error
  1873                              <1> 
  1874 00003488 0FB606007B          <1> 	movzx ax, byte [token]
  1875 0000348D 31DB                <1> 	xor bx, bx
  1876 0000348F 88F3                <1> 	mov bl, dh
  1877 00003491 E8AC10              <1> 	call set_var
  1878                              <1> 
  1879 00003494 E948F9              <1> 	jmp mainloop
  1880                              <1> 
  1881                              <1> .error:
  1882 00003497 B314                <1> 	mov bl, err_syntax
  1883 00003499 E9CC11              <1> 	jmp error
  1884                              <1> 
  1885                              <1> 
  1886                              <1> ; ------------------------------------------------------------------
  1887                              <1> ; DELETE
  1888                              <1> 
  1889                              <1> do_delete:
  1890 0000349C E8B010              <1> 	call get_token
  1891 0000349F 83F805              <1> 	cmp ax, QUOTE
  1892 000034A2 7413                <1> 	je .is_quote
  1893                              <1> 
  1894 000034A4 83F802              <1> 	cmp ax, STRING_VAR
  1895 000034A7 0F854300            <1> 	jne near .error
  1896                              <1> 
  1897 000034AB BE007C              <1> 	mov si, string_vars
  1898 000034AE B88000              <1> 	mov ax, 128
  1899 000034B1 F7E3                <1> 	mul bx
  1900 000034B3 01C6                <1> 	add si, ax
  1901 000034B5 EB03                <1> 	jmp .get_filename
  1902                              <1> 
  1903                              <1> .is_quote:
  1904 000034B7 BE007B              <1> 	mov si, token
  1905                              <1> 
  1906                              <1> .get_filename:
  1907 000034BA 89F0                <1> 	mov ax, si
  1908 000034BC E8CFDA              <1> 	call os_file_exists
  1909 000034BF 7207                <1> 	jc .no_file
  1910                              <1> 
  1911 000034C1 E8C9DB              <1> 	call os_remove_file
  1912 000034C4 721B                <1> 	jc .del_fail
  1913                              <1> 
  1914 000034C6 EB0D                <1> 	jmp .returngood
  1915                              <1> 
  1916                              <1> .no_file:
  1917 000034C8 31C0                <1> 	xor ax, ax
  1918 000034CA B052                <1> 	mov byte al, 'R'
  1919 000034CC BB0200              <1> 	mov bx, 2
  1920 000034CF E86E10              <1> 	call set_var
  1921 000034D2 E90AF9              <1> 	jmp mainloop
  1922                              <1> 
  1923                              <1> .returngood:
  1924 000034D5 31C0                <1> 	xor ax, ax
  1925 000034D7 B052                <1> 	mov byte al, 'R'
  1926 000034D9 31DB                <1> 	xor bx, bx
  1927 000034DB E86210              <1> 	call set_var
  1928 000034DE E9FEF8              <1> 	jmp mainloop
  1929                              <1> 
  1930                              <1> .del_fail:
  1931 000034E1 31C0                <1> 	xor ax, ax
  1932 000034E3 B052                <1> 	mov byte al, 'R'
  1933 000034E5 BB0100              <1> 	mov bx, 1
  1934 000034E8 E85510              <1> 	call set_var
  1935 000034EB E9F1F8              <1> 	jmp mainloop
  1936                              <1> 
  1937                              <1> .error:
  1938 000034EE B314                <1> 	mov bl, err_syntax
  1939 000034F0 E97511              <1> 	jmp error
  1940                              <1> 	
  1941                              <1> 
  1942                              <1> ; ------------------------------------------------------------------
  1943                              <1> ; DO
  1944                              <1> 
  1945                              <1> do_do:
  1946 000034F3 803E[DA46]14        <1> 	cmp byte [loop_in], 20
  1947 000034F8 741C                <1> 	je .loop_max
  1948 000034FA BFD079              <1> 	mov word di, do_loop_store
  1949 000034FD A0[DA46]            <1> 	mov byte al, [loop_in]
  1950 00003500 B400                <1> 	mov ah, 0
  1951 00003502 01C7                <1> 	add di, ax
  1952 00003504 A1[D346]            <1> 	mov word ax, [prog]
  1953 00003507 83E803              <1> 	sub ax, 3
  1954 0000350A AB                  <1> 	stosw
  1955 0000350B FE06[DA46]          <1> 	inc byte [loop_in]
  1956 0000350F FE06[DA46]          <1> 	inc byte [loop_in]
  1957 00003513 E9C9F8              <1> 	jmp mainloop
  1958                              <1> 
  1959                              <1> .loop_max:
  1960 00003516 B303                <1> 	mov bl, err_doloop_maximum
  1961 00003518 E94D11              <1> 	jmp error
  1962                              <1> 
  1963                              <1> 	
  1964                              <1> ;-------------------------------------------------------------------
  1965                              <1> ; ELSE
  1966                              <1> 
  1967                              <1> do_else:
  1968 0000351B 803E[DB46]01        <1> 	cmp byte [last_if_true], 1
  1969 00003520 7407                <1> 	je .last_true
  1970                              <1> 	
  1971 00003522 FF06[D346]          <1> 	inc word [prog]
  1972 00003526 E9B6F8              <1> 	jmp mainloop
  1973                              <1> 	
  1974                              <1> .last_true:
  1975 00003529 8B36[D346]          <1> 	mov word si, [prog]
  1976                              <1> 	
  1977                              <1> .next_line:
  1978 0000352D AC                  <1> 	lodsb
  1979 0000352E 3C0A                <1> 	cmp al, 10
  1980 00003530 75FB                <1> 	jne .next_line
  1981                              <1> 	
  1982 00003532 4E                  <1> 	dec si
  1983 00003533 8936[D346]          <1> 	mov word [prog], si
  1984                              <1> 	
  1985 00003537 E9A5F8              <1> 	jmp mainloop
  1986                              <1> 
  1987                              <1> 
  1988                              <1> ; ------------------------------------------------------------------
  1989                              <1> ; END
  1990                              <1> 
  1991                              <1> do_end:
  1992 0000353A B405                <1> 	mov ah, 5				; Restore active page
  1993 0000353C B000                <1> 	mov al, 0
  1994 0000353E CD10                <1> 	int 10h
  1995                              <1> 
  1996 00003540 C606[DD46]00        <1> 	mov byte [work_page], 0
  1997 00003545 C606[DE46]00        <1> 	mov byte [disp_page], 0
  1998                              <1> 
  1999 0000354A 8B26[D146]          <1> 	mov word sp, [orig_stack]
  2000 0000354E C3                  <1> 	ret
  2001                              <1> 
  2002                              <1> 
  2003                              <1> ; ------------------------------------------------------------------
  2004                              <1> ; FILES
  2005                              <1> 
  2006                              <1> do_files:
  2007 0000354F B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  2008 00003552 E8C8D5              <1> 	call os_get_file_list
  2009                              <1> 	
  2010 00003555 89C6                <1> 	mov si, ax
  2011                              <1> 
  2012 00003557 E8D6E3              <1> 	call os_get_cursor_pos			; move cursor to start of line
  2013 0000355A B200                <1> 	mov dl, 0
  2014 0000355C E8C8E3              <1> 	call os_move_cursor
  2015                              <1> 	
  2016 0000355F B409                <1> 	mov ah, 9				; print character function
  2017 00003561 8A3E[DD46]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  2018 00003565 8A1E[DC46]          <1> 	mov bl, [ink_colour]
  2019 00003569 B90100              <1> 	mov cx, 1
  2020                              <1> .file_list_loop:
  2021 0000356C AC                  <1> 	lodsb					; get a byte from the list
  2022 0000356D 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  2023 0000356F 7410                <1> 	je .nextfile
  2024                              <1> 	
  2025 00003571 3C00                <1> 	cmp al, 0				; the list is null terminated
  2026 00003573 7438                <1> 	je .end_of_list
  2027                              <1> 	
  2028 00003575 CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  2029                              <1> 
  2030 00003577 E8B6E3              <1> 	call os_get_cursor_pos			; find the location of the cursor
  2031 0000357A FEC2                <1> 	inc dl					; move the cursor forward
  2032 0000357C E8A8E3              <1> 	call os_move_cursor
  2033                              <1> 
  2034 0000357F EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  2035                              <1> 	
  2036                              <1> .nextfile:
  2037 00003581 E8ACE3              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  2038 00003584 80FA3C              <1> 	cmp dl, 60
  2039 00003587 7D1F                <1> 	jge .newline
  2040                              <1> 
  2041                              <1> .next_column:					; print spaces until the next column
  2042 00003589 B020                <1> 	mov al, ' '
  2043 0000358B CD10                <1> 	int 10h
  2044                              <1> 	
  2045 0000358D FEC2                <1> 	inc dl
  2046 0000358F E895E3              <1> 	call os_move_cursor
  2047                              <1> 	
  2048 00003592 80FA0F              <1> 	cmp dl, 15
  2049 00003595 74D5                <1> 	je .file_list_loop
  2050                              <1> 	
  2051 00003597 80FA1E              <1> 	cmp dl, 30
  2052 0000359A 74D0                <1> 	je .file_list_loop
  2053                              <1> 	
  2054 0000359C 80FA2D              <1> 	cmp dl, 45
  2055 0000359F 74CB                <1> 	je .file_list_loop
  2056                              <1> 	
  2057 000035A1 80FA3C              <1> 	cmp dl, 60
  2058 000035A4 74C6                <1> 	je .file_list_loop
  2059                              <1> 	
  2060 000035A6 EBE1                <1> 	jmp .next_column
  2061                              <1> 	
  2062                              <1> .newline:
  2063 000035A8 E869EA              <1> 	call os_print_newline			; create a new line
  2064 000035AB EBBF                <1> 	jmp .file_list_loop
  2065                              <1> 	
  2066                              <1> .end_of_list:
  2067 000035AD E864EA              <1> 	call os_print_newline
  2068 000035B0 E92CF8              <1> 	jmp mainloop				; preform next command
  2069                              <1> 	
  2070                              <1> .data:
  2071                              <1> 	.filelist		equ 64000
  2072                              <1> 	
  2073                              <1> 
  2074                              <1> 
  2075                              <1> ; ------------------------------------------------------------------
  2076                              <1> ; FOR
  2077                              <1> 
  2078                              <1> do_for:
  2079 000035B3 E8990F              <1> 	call get_token				; Get the variable we're using in this loop
  2080                              <1> 
  2081 000035B6 83F801              <1> 	cmp ax, VARIABLE
  2082 000035B9 0F859B00            <1> 	jne near .error
  2083                              <1> 
  2084 000035BD 0FB606007B          <1> 	movzx ax, byte [token]
  2085 000035C2 A2[5D36]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  2086                              <1> 
  2087 000035C5 E8870F              <1> 	call get_token
  2088                              <1> 
  2089 000035C8 0FB606007B          <1> 	movzx ax, byte [token]
  2090 000035CD 3C3D                <1> 	cmp al, '='
  2091 000035CF 0F858500            <1> 	jne .error
  2092                              <1> 
  2093 000035D3 E8790F              <1> 	call get_token				; Next we want a number
  2094                              <1> 
  2095 000035D6 83F801              <1> 	cmp ax, VARIABLE
  2096 000035D9 740D                <1> 	je .first_is_var
  2097                              <1> 
  2098 000035DB 83F803              <1> 	cmp ax, NUMBER
  2099 000035DE 7578                <1> 	jne .error
  2100                              <1> 
  2101 000035E0 BE007B              <1> 	mov si, token				; Convert it
  2102 000035E3 E8FCF5              <1> 	call os_string_to_int
  2103 000035E6 EB08                <1> 	jmp .continue
  2104                              <1> 
  2105                              <1> .first_is_var:
  2106 000035E8 0FB606007B          <1> 	movzx ax, byte [token]
  2107 000035ED E8430F              <1> 	call get_var
  2108                              <1> 	
  2109                              <1> 	; At this stage, we've read something like "FOR X = 1"
  2110                              <1> 	; so let's store that 1 in the variable table
  2111                              <1> 
  2112                              <1> .continue:
  2113 000035F0 89C3                <1> 	mov bx, ax
  2114 000035F2 0FB606[5D36]        <1> 	movzx ax, byte [.tmp_var]
  2115 000035F7 E8460F              <1> 	call set_var
  2116                              <1> 
  2117                              <1> 
  2118 000035FA E8520F              <1> 	call get_token				; Next we're looking for "TO"
  2119                              <1> 
  2120 000035FD 83F804              <1> 	cmp ax, STRING
  2121 00003600 7556                <1> 	jne .error
  2122                              <1> 
  2123 00003602 B8007B              <1> 	mov ax, token
  2124 00003605 E8EDF4              <1> 	call os_string_uppercase
  2125                              <1> 
  2126 00003608 BE007B              <1> 	mov si, token
  2127 0000360B BF[5E36]            <1> 	mov di, .to_string
  2128 0000360E E87DF5              <1> 	call os_string_compare
  2129 00003611 7345                <1> 	jnc .error
  2130                              <1> 
  2131                              <1> 
  2132                              <1> 	; So now we're at "FOR X = 1 TO"
  2133                              <1> 
  2134 00003613 E8390F              <1> 	call get_token
  2135                              <1> 
  2136 00003616 83F801              <1> 	cmp ax, VARIABLE
  2137 00003619 740D                <1> 	je .second_is_var
  2138                              <1> 
  2139 0000361B 83F803              <1> 	cmp ax, NUMBER
  2140 0000361E 7538                <1> 	jne .error
  2141                              <1> 
  2142                              <1> .second_is_number:
  2143 00003620 BE007B              <1> 	mov si, token					; Get target number
  2144 00003623 E8BCF5              <1> 	call os_string_to_int
  2145 00003626 EB08                <1> 	jmp .continue2
  2146                              <1> 
  2147                              <1> .second_is_var:
  2148 00003628 0FB606007B          <1> 	movzx ax, byte [token]
  2149 0000362D E8030F              <1> 	call get_var
  2150                              <1> 
  2151                              <1> .continue2:
  2152 00003630 89C3                <1> 	mov bx, ax
  2153                              <1> 
  2154 00003632 0FB606[5D36]        <1> 	movzx ax, byte [.tmp_var]
  2155                              <1> 
  2156 00003637 2C41                <1> 	sub al, 65					; Store target number in table
  2157 00003639 BF187A              <1> 	mov di, for_variables
  2158 0000363C 01C7                <1> 	add di, ax
  2159 0000363E 01C7                <1> 	add di, ax
  2160 00003640 89D8                <1> 	mov ax, bx
  2161 00003642 AB                  <1> 	stosw
  2162                              <1> 
  2163                              <1> 
  2164                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  2165                              <1> 	; our table the limit it should reach. But we also need to store the point in
  2166                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  2167                              <1> 
  2168 00003643 0FB606[5D36]        <1> 	movzx ax, byte [.tmp_var]
  2169                              <1> 
  2170 00003648 2C41                <1> 	sub al, 65					; Store code position to return to in table
  2171 0000364A BFE479              <1> 	mov di, for_code_points
  2172 0000364D 01C7                <1> 	add di, ax
  2173 0000364F 01C7                <1> 	add di, ax
  2174 00003651 A1[D346]            <1> 	mov word ax, [prog]
  2175 00003654 AB                  <1> 	stosw
  2176                              <1> 
  2177 00003655 E987F7              <1> 	jmp mainloop
  2178                              <1> 
  2179                              <1> 
  2180                              <1> .error:
  2181 00003658 B314                <1> 	mov bl, err_syntax
  2182 0000365A E90B10              <1> 	jmp error
  2183                              <1> 
  2184                              <1> 
  2185 0000365D 00                  <1> 	.tmp_var	db 0
  2186 0000365E 544F00              <1> 	.to_string	db 'TO', 0
  2187                              <1> 
  2188                              <1> 
  2189                              <1> ; ------------------------------------------------------------------
  2190                              <1> ; GETKEY
  2191                              <1> 
  2192                              <1> do_getkey:
  2193 00003661 E8EB0E              <1> 	call get_token
  2194 00003664 83F801              <1> 	cmp ax, VARIABLE
  2195 00003667 7405                <1> 	je .is_variable
  2196                              <1> 
  2197 00003669 B314                <1> 	mov bl, err_syntax
  2198 0000366B E9FA0F              <1> 	jmp error
  2199                              <1> 
  2200                              <1> .is_variable:
  2201 0000366E 0FB606007B          <1> 	movzx ax, byte [token]
  2202                              <1> 
  2203 00003673 50                  <1> 	push ax
  2204                              <1> 
  2205 00003674 E863DD              <1> 	call os_check_for_key
  2206                              <1> 
  2207 00003677 3DE048              <1> 	cmp ax, 48E0h
  2208 0000367A 7419                <1> 	je .up_pressed
  2209                              <1> 
  2210 0000367C 3DE050              <1> 	cmp ax, 50E0h
  2211 0000367F 7419                <1> 	je .down_pressed
  2212                              <1> 
  2213 00003681 3DE04B              <1> 	cmp ax, 4BE0h
  2214 00003684 7419                <1> 	je .left_pressed
  2215                              <1> 
  2216 00003686 3DE04D              <1> 	cmp ax, 4DE0h
  2217 00003689 7419                <1> 	je .right_pressed
  2218                              <1> 
  2219                              <1> .store:	
  2220 0000368B 0FB6D8              <1> 	movzx bx, al
  2221                              <1> 	
  2222 0000368E 58                  <1> 	pop ax
  2223                              <1> 
  2224 0000368F E8AE0E              <1> 	call set_var
  2225                              <1> 
  2226 00003692 E94AF7              <1> 	jmp mainloop
  2227                              <1> 
  2228                              <1> .up_pressed:
  2229 00003695 B80100              <1> 	mov ax, 1
  2230 00003698 EBF1                <1> 	jmp .store
  2231                              <1> 
  2232                              <1> .down_pressed:
  2233 0000369A B80200              <1> 	mov ax, 2
  2234 0000369D EBEC                <1> 	jmp .store
  2235                              <1> 
  2236                              <1> .left_pressed:
  2237 0000369F B80300              <1> 	mov ax, 3
  2238 000036A2 EBE7                <1> 	jmp .store
  2239                              <1> 
  2240                              <1> .right_pressed:
  2241 000036A4 B80400              <1> 	mov ax, 4
  2242 000036A7 EBE2                <1> 	jmp .store
  2243                              <1> 
  2244                              <1> ; ------------------------------------------------------------------
  2245                              <1> ; GOSUB
  2246                              <1> 
  2247                              <1> do_gosub:
  2248 000036A9 E8A30E              <1> 	call get_token				; Get the number (label)
  2249                              <1> 
  2250 000036AC 83F804              <1> 	cmp ax, STRING
  2251 000036AF 7405                <1> 	je .is_ok
  2252                              <1> 
  2253 000036B1 B305                <1> 	mov bl, err_goto_notlabel
  2254 000036B3 E9B20F              <1> 	jmp error
  2255                              <1> 
  2256                              <1> .is_ok:
  2257 000036B6 BE007B              <1> 	mov si, token				; Back up this label
  2258 000036B9 BF[2837]            <1> 	mov di, .tmp_token
  2259 000036BC E870F4              <1> 	call os_string_copy
  2260                              <1> 
  2261 000036BF B8[2837]            <1> 	mov ax, .tmp_token
  2262 000036C2 E8D7F3              <1> 	call os_string_length
  2263                              <1> 
  2264 000036C5 BF[2837]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2265 000036C8 01C7                <1> 	add di, ax
  2266 000036CA B03A                <1> 	mov al, ':'
  2267 000036CC AA                  <1> 	stosb
  2268 000036CD B000                <1> 	mov al, 0
  2269 000036CF AA                  <1> 	stosb	
  2270                              <1> 
  2271                              <1> 
  2272 000036D0 FE06[4A48]          <1> 	inc byte [gosub_depth]
  2273                              <1> 
  2274 000036D4 0FB606[4A48]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  2275                              <1> 
  2276 000036D9 3C09                <1> 	cmp al, 9
  2277 000036DB 7E05                <1> 	jle .within_limit
  2278                              <1> 
  2279 000036DD B307                <1> 	mov bl, err_nest_limit
  2280 000036DF E9860F              <1> 	jmp error
  2281                              <1> 
  2282                              <1> 
  2283                              <1> .within_limit:
  2284 000036E2 BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  2285 000036E5 01C7                <1> 	add di, ax				; Table is words (not bytes)
  2286 000036E7 01C7                <1> 	add di, ax
  2287 000036E9 A1[D346]            <1> 	mov word ax, [prog]
  2288 000036EC AB                  <1> 	stosw					; Store current location before jump
  2289                              <1> 
  2290                              <1> 
  2291 000036ED A1[D746]            <1> 	mov word ax, [load_point]
  2292 000036F0 A3[D346]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2293                              <1> 
  2294                              <1> .loop:
  2295 000036F3 E8590E              <1> 	call get_token
  2296                              <1> 
  2297 000036F6 83F808              <1> 	cmp ax, LABEL
  2298 000036F9 750D                <1> 	jne .line_loop
  2299                              <1> 
  2300 000036FB BE007B              <1> 	mov si, token
  2301 000036FE BF[2837]            <1> 	mov di, .tmp_token
  2302 00003701 E88AF4              <1> 	call os_string_compare
  2303 00003704 0F82D7F6            <1> 	jc mainloop
  2304                              <1> 
  2305                              <1> 
  2306                              <1> .line_loop:					; Go to end of line
  2307 00003708 8B36[D346]          <1> 	mov word si, [prog]
  2308 0000370C 8A04                <1> 	mov byte al, [si]
  2309 0000370E FF06[D346]          <1> 	inc word [prog]
  2310 00003712 3C0A                <1> 	cmp al, 10
  2311 00003714 75F2                <1> 	jne .line_loop
  2312                              <1> 
  2313 00003716 A1[D346]            <1> 	mov word ax, [prog]
  2314 00003719 8B1E[D546]          <1> 	mov word bx, [prog_end]
  2315 0000371D 39D8                <1> 	cmp ax, bx
  2316 0000371F 7F02                <1> 	jg .past_end
  2317                              <1> 
  2318 00003721 EBD0                <1> 	jmp .loop
  2319                              <1> 
  2320                              <1> 
  2321                              <1> .past_end:
  2322 00003723 B306                <1> 	mov bl, err_label_notfound
  2323 00003725 E9400F              <1> 	jmp error
  2324                              <1> 
  2325                              <1> 
  2326 00003728 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  2327                              <1> 
  2328                              <1> 
  2329                              <1> ; ------------------------------------------------------------------
  2330                              <1> ; GOTO
  2331                              <1> 
  2332                              <1> do_goto:
  2333 00003746 E8060E              <1> 	call get_token				; Get the next token
  2334                              <1> 
  2335 00003749 83F804              <1> 	cmp ax, STRING
  2336 0000374C 7405                <1> 	je .is_ok
  2337                              <1> 
  2338 0000374E B305                <1> 	mov bl, err_goto_notlabel
  2339 00003750 E9150F              <1> 	jmp error
  2340                              <1> 
  2341                              <1> .is_ok:
  2342 00003753 BE007B              <1> 	mov si, token				; Back up this label
  2343 00003756 BF[A837]            <1> 	mov di, .tmp_token
  2344 00003759 E8D3F3              <1> 	call os_string_copy
  2345                              <1> 
  2346 0000375C B8[A837]            <1> 	mov ax, .tmp_token
  2347 0000375F E83AF3              <1> 	call os_string_length
  2348                              <1> 
  2349 00003762 BF[A837]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2350 00003765 01C7                <1> 	add di, ax
  2351 00003767 B03A                <1> 	mov al, ':'
  2352 00003769 AA                  <1> 	stosb
  2353 0000376A B000                <1> 	mov al, 0
  2354 0000376C AA                  <1> 	stosb	
  2355                              <1> 
  2356 0000376D A1[D746]            <1> 	mov word ax, [load_point]
  2357 00003770 A3[D346]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2358                              <1> 
  2359                              <1> .loop:
  2360 00003773 E8D90D              <1> 	call get_token
  2361                              <1> 
  2362 00003776 83F808              <1> 	cmp ax, LABEL
  2363 00003779 750D                <1> 	jne .line_loop
  2364                              <1> 
  2365 0000377B BE007B              <1> 	mov si, token
  2366 0000377E BF[A837]            <1> 	mov di, .tmp_token
  2367 00003781 E80AF4              <1> 	call os_string_compare
  2368 00003784 0F8257F6            <1> 	jc mainloop
  2369                              <1> 
  2370                              <1> .line_loop:					; Go to end of line
  2371 00003788 8B36[D346]          <1> 	mov word si, [prog]
  2372 0000378C 8A04                <1> 	mov byte al, [si]
  2373 0000378E FF06[D346]          <1> 	inc word [prog]
  2374                              <1> 
  2375 00003792 3C0A                <1> 	cmp al, 10
  2376 00003794 75F2                <1> 	jne .line_loop
  2377                              <1> 
  2378 00003796 A1[D346]            <1> 	mov word ax, [prog]
  2379 00003799 8B1E[D546]          <1> 	mov word bx, [prog_end]
  2380 0000379D 39D8                <1> 	cmp ax, bx
  2381 0000379F 7F02                <1> 	jg .past_end
  2382                              <1> 
  2383 000037A1 EBD0                <1> 	jmp .loop
  2384                              <1> 
  2385                              <1> .past_end:
  2386 000037A3 B306                <1> 	mov bl, err_label_notfound
  2387 000037A5 E9C00E              <1> 	jmp error
  2388                              <1> 
  2389                              <1> 
  2390 000037A8 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  2391                              <1> 
  2392                              <1> 
  2393                              <1> ; ------------------------------------------------------------------
  2394                              <1> ; IF
  2395                              <1> 
  2396                              <1> do_if:
  2397 000037C6 E8860D              <1> 	call get_token
  2398                              <1> 
  2399 000037C9 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  2400 000037CC 740C                <1> 	je .num_var
  2401                              <1> 
  2402 000037CE 83F802              <1> 	cmp ax, STRING_VAR
  2403 000037D1 0F84B300            <1> 	je near .string_var
  2404                              <1> 
  2405 000037D5 B314                <1> 	mov bl, err_syntax
  2406 000037D7 E98E0E              <1> 	jmp error
  2407                              <1> 
  2408                              <1> .num_var:
  2409 000037DA 0FB606007B          <1> 	movzx ax, byte [token]
  2410 000037DF E8510D              <1> 	call get_var
  2411                              <1> 
  2412 000037E2 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  2413                              <1> 
  2414 000037E4 E8680D              <1> 	call get_token				; Get the delimiter
  2415 000037E7 A0007B              <1> 	mov byte al, [token]
  2416 000037EA 3C3D                <1> 	cmp al, '='
  2417 000037EC 740D                <1> 	je .equals
  2418 000037EE 3C3E                <1> 	cmp al, '>'
  2419 000037F0 7447                <1> 	je .greater
  2420 000037F2 3C3C                <1> 	cmp al, '<'
  2421 000037F4 746C                <1> 	je .less
  2422                              <1> 
  2423 000037F6 B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  2424 000037F8 E96D0E              <1> 	jmp error
  2425                              <1> 
  2426                              <1> .equals:
  2427 000037FB E8510D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  2428                              <1> 
  2429 000037FE 83F806              <1> 	cmp ax, CHAR
  2430 00003801 7417                <1> 	je .equals_char
  2431                              <1> 
  2432 00003803 A0007B              <1> 	mov byte al, [token]
  2433 00003806 E8530E              <1> 	call is_letter
  2434 00003809 721D                <1> 	jc .equals_var
  2435                              <1> 
  2436 0000380B BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  2437 0000380E E8D1F3              <1> 	call os_string_to_int
  2438                              <1> 
  2439 00003811 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  2440 00003813 0F84C200            <1> 	je near .on_to_then
  2441                              <1> 
  2442 00003817 E9E700              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2443                              <1> 
  2444                              <1> 
  2445                              <1> .equals_char:
  2446 0000381A 0FB606007B          <1> 	movzx ax, byte [token]
  2447                              <1> 
  2448 0000381F 39D0                <1> 	cmp ax, dx
  2449 00003821 0F84B400            <1> 	je near .on_to_then
  2450                              <1> 
  2451 00003825 E9D900              <1> 	jmp .finish_line
  2452                              <1> 
  2453                              <1> 
  2454                              <1> .equals_var:
  2455 00003828 0FB606007B          <1> 	movzx ax, byte [token]
  2456                              <1> 
  2457 0000382D E8030D              <1> 	call get_var
  2458                              <1> 
  2459 00003830 39D0                <1> 	cmp ax, dx				; Do the variables match?
  2460 00003832 0F84A300            <1> 	je near .on_to_then				; On to the THEN bit if so
  2461                              <1> 
  2462 00003836 E9C800              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2463                              <1> 
  2464                              <1> 
  2465                              <1> .greater:
  2466 00003839 E8130D              <1> 	call get_token				; Greater than a variable or number?
  2467 0000383C A0007B              <1> 	mov byte al, [token]
  2468 0000383F E81A0E              <1> 	call is_letter
  2469 00003842 720F                <1> 	jc .greater_var
  2470                              <1> 
  2471 00003844 BE007B              <1> 	mov si, token				; Must be a number here...
  2472 00003847 E898F3              <1> 	call os_string_to_int
  2473                              <1> 
  2474 0000384A 39D0                <1> 	cmp ax, dx
  2475 0000384C 0F8C8900            <1> 	jl near .on_to_then
  2476                              <1> 
  2477 00003850 E9AE00              <1> 	jmp .finish_line
  2478                              <1> 
  2479                              <1> .greater_var:					; Variable in this case
  2480 00003853 0FB606007B          <1> 	movzx ax, byte [token]
  2481                              <1> 
  2482 00003858 E8D80C              <1> 	call get_var
  2483                              <1> 
  2484 0000385B 39D0                <1> 	cmp ax, dx				; Make the comparison!
  2485 0000385D 7C7A                <1> 	jl .on_to_then
  2486                              <1> 
  2487 0000385F E99F00              <1> 	jmp .finish_line
  2488                              <1> 
  2489                              <1> .less:
  2490 00003862 E8EA0C              <1> 	call get_token
  2491 00003865 A0007B              <1> 	mov byte al, [token]
  2492 00003868 E8F10D              <1> 	call is_letter
  2493 0000386B 720D                <1> 	jc .less_var
  2494                              <1> 
  2495 0000386D BE007B              <1> 	mov si, token
  2496 00003870 E86FF3              <1> 	call os_string_to_int
  2497                              <1> 
  2498 00003873 39D0                <1> 	cmp ax, dx
  2499 00003875 7F62                <1> 	jg .on_to_then
  2500                              <1> 
  2501 00003877 E98700              <1> 	jmp .finish_line
  2502                              <1> 
  2503                              <1> .less_var:
  2504 0000387A 0FB606007B          <1> 	movzx ax, byte [token]
  2505                              <1> 
  2506 0000387F E8B10C              <1> 	call get_var
  2507                              <1> 
  2508 00003882 39D0                <1> 	cmp ax, dx
  2509 00003884 7F53                <1> 	jg .on_to_then
  2510                              <1> 
  2511 00003886 EB79                <1> 	jmp .finish_line
  2512                              <1> 
  2513                              <1> 
  2514                              <1> 
  2515                              <1> .string_var:
  2516 00003888 881E[1C39]          <1> 	mov byte [.tmp_string_var], bl
  2517                              <1> 
  2518 0000388C E8C00C              <1> 	call get_token
  2519                              <1> 
  2520 0000388F A0007B              <1> 	mov byte al, [token]
  2521 00003892 3C3D                <1> 	cmp al, '='
  2522 00003894 0F857F00            <1> 	jne .error
  2523                              <1> 
  2524 00003898 E8B40C              <1> 	call get_token
  2525 0000389B 83F802              <1> 	cmp ax, STRING_VAR
  2526 0000389E 7419                <1> 	je .second_is_string_var
  2527                              <1> 
  2528 000038A0 83F805              <1> 	cmp ax, QUOTE
  2529 000038A3 7572                <1> 	jne .error
  2530                              <1> 
  2531 000038A5 BE007C              <1> 	mov si, string_vars
  2532 000038A8 B88000              <1> 	mov ax, 128
  2533 000038AB F7E3                <1> 	mul bx
  2534 000038AD 01C6                <1> 	add si, ax
  2535 000038AF BF007B              <1> 	mov di, token
  2536 000038B2 E8D9F2              <1> 	call os_string_compare
  2537 000038B5 7422                <1> 	je .on_to_then
  2538                              <1> 
  2539 000038B7 EB48                <1> 	jmp .finish_line
  2540                              <1> 
  2541                              <1> 
  2542                              <1> .second_is_string_var:
  2543 000038B9 BE007C              <1> 	mov si, string_vars
  2544 000038BC B88000              <1> 	mov ax, 128
  2545 000038BF F7E3                <1> 	mul bx
  2546 000038C1 01C6                <1> 	add si, ax
  2547                              <1> 
  2548 000038C3 BF007C              <1> 	mov di, string_vars
  2549 000038C6 0FB61E[1C39]        <1> 	movzx bx, byte [.tmp_string_var]
  2550 000038CB B88000              <1> 	mov ax, 128
  2551 000038CE F7E3                <1> 	mul bx
  2552 000038D0 01C7                <1> 	add di, ax
  2553                              <1> 
  2554 000038D2 E8B9F2              <1> 	call os_string_compare
  2555 000038D5 7202                <1> 	jc .on_to_then
  2556                              <1> 
  2557 000038D7 EB28                <1> 	jmp .finish_line
  2558                              <1> 
  2559                              <1> 
  2560                              <1> .on_to_then:
  2561 000038D9 E8730C              <1> 	call get_token
  2562                              <1> 
  2563 000038DC BE007B              <1> 	mov si, token			; Look for AND for more comparison
  2564 000038DF BF[FE47]            <1> 	mov di, and_keyword
  2565 000038E2 E8A9F2              <1> 	call os_string_compare
  2566 000038E5 0F82DDFE            <1> 	jc do_if
  2567                              <1> 
  2568 000038E9 BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  2569 000038EC BF[0248]            <1> 	mov di, then_keyword
  2570 000038EF E89CF2              <1> 	call os_string_compare
  2571 000038F2 7205                <1> 	jc .then_present
  2572                              <1> 
  2573 000038F4 B314                <1> 	mov bl, err_syntax
  2574 000038F6 E96F0D              <1> 	jmp error
  2575                              <1> 
  2576                              <1> .then_present:				; Continue rest of line like any other command!
  2577 000038F9 C606[DB46]01        <1> 	mov byte [last_if_true], 1
  2578 000038FE E9DEF4              <1> 	jmp mainloop
  2579                              <1> 
  2580                              <1> 
  2581                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  2582 00003901 8B36[D346]          <1> 	mov word si, [prog]
  2583 00003905 8A04                <1> 	mov byte al, [si]
  2584 00003907 FF06[D346]          <1> 	inc word [prog]
  2585 0000390B 3C0A                <1> 	cmp al, 10
  2586 0000390D 75F2                <1> 	jne .finish_line
  2587                              <1> 
  2588 0000390F C606[DB46]00        <1> 	mov byte [last_if_true], 0
  2589 00003914 E9C8F4              <1> 	jmp mainloop
  2590                              <1> 
  2591                              <1> 
  2592                              <1> .error:
  2593 00003917 B314                <1> 	mov bl, err_syntax
  2594 00003919 E94C0D              <1> 	jmp error
  2595                              <1> 
  2596                              <1> 
  2597 0000391C 00                  <1> 	.tmp_string_var		db 0
  2598                              <1> 
  2599                              <1> 
  2600                              <1> ; ------------------------------------------------------------------
  2601                              <1> ; INCLUDE
  2602                              <1> 
  2603                              <1> do_include:
  2604 0000391D E82F0C              <1> 	call get_token
  2605 00003920 83F805              <1> 	cmp ax, QUOTE
  2606 00003923 7406                <1> 	je .is_ok
  2607                              <1> 
  2608 00003925 BE1400              <1> 	mov si, err_syntax
  2609 00003928 E93D0D              <1> 	jmp error
  2610                              <1> 
  2611                              <1> .is_ok:
  2612 0000392B B8007B              <1> 	mov ax, token
  2613 0000392E 8B0E[D546]          <1> 	mov word cx, [prog_end]
  2614 00003932 41                  <1> 	inc cx				; Add a bit of space after original code
  2615 00003933 41                  <1> 	inc cx
  2616 00003934 41                  <1> 	inc cx
  2617 00003935 51                  <1> 	push cx
  2618 00003936 E811D3              <1> 	call os_load_file
  2619 00003939 720A                <1> 	jc .load_fail
  2620                              <1> 
  2621 0000393B 59                  <1> 	pop cx
  2622 0000393C 01D9                <1> 	add cx, bx
  2623 0000393E 890E[D546]          <1> 	mov word [prog_end], cx
  2624                              <1> 
  2625 00003942 E99AF4              <1> 	jmp mainloop
  2626                              <1> 
  2627                              <1> 
  2628                              <1> .load_fail:
  2629 00003945 59                  <1> 	pop cx
  2630 00003946 BE0400              <1> 	mov si, err_file_notfound
  2631 00003949 E91C0D              <1> 	jmp error
  2632                              <1> 
  2633                              <1> 
  2634                              <1> ; ------------------------------------------------------------------
  2635                              <1> ; INK
  2636                              <1> 
  2637                              <1> do_ink:
  2638 0000394C E8000C              <1> 	call get_token				; Get column
  2639                              <1> 
  2640 0000394F 83F801              <1> 	cmp ax, VARIABLE
  2641 00003952 740C                <1> 	je .first_is_var
  2642                              <1> 
  2643 00003954 BE007B              <1> 	mov si, token
  2644 00003957 E888F2              <1> 	call os_string_to_int
  2645 0000395A A2[DC46]            <1> 	mov byte [ink_colour], al
  2646 0000395D E97FF4              <1> 	jmp mainloop
  2647                              <1> 
  2648                              <1> .first_is_var:
  2649 00003960 B80000              <1> 	mov ax, 0
  2650 00003963 A0007B              <1> 	mov byte al, [token]
  2651 00003966 E8CA0B              <1> 	call get_var
  2652 00003969 A2[DC46]            <1> 	mov byte [ink_colour], al
  2653 0000396C E970F4              <1> 	jmp mainloop
  2654                              <1> 
  2655                              <1> 
  2656                              <1> ; ------------------------------------------------------------------
  2657                              <1> ; INPUT
  2658                              <1> 
  2659                              <1> do_input:
  2660 0000396F B000                <1> 	mov al, 0				; Clear string from previous usage
  2661 00003971 BF807A              <1> 	mov di, .tmpstring
  2662 00003974 B98000              <1> 	mov cx, 128
  2663 00003977 F3AA                <1> 	rep stosb
  2664                              <1> 
  2665 00003979 E8D30B              <1> 	call get_token
  2666                              <1> 
  2667 0000397C 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  2668 0000397F 740B                <1> 	je .number_var
  2669                              <1> 
  2670 00003981 83F802              <1> 	cmp ax, STRING_VAR
  2671 00003984 7437                <1> 	je .string_var
  2672                              <1> 
  2673 00003986 BE1400              <1> 	mov si, err_syntax
  2674 00003989 E9DC0C              <1> 	jmp error
  2675                              <1> 
  2676                              <1> .number_var:
  2677 0000398C B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  2678 0000398F E8F1E8              <1> 	call os_input_string
  2679                              <1> 
  2680 00003992 B8807A              <1> 	mov ax, .tmpstring
  2681 00003995 E804F1              <1> 	call os_string_length
  2682 00003998 83F800              <1> 	cmp ax, 0
  2683 0000399B 750A                <1> 	jne .char_entered
  2684                              <1> 
  2685 0000399D C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  2686 000039A2 C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  2687                              <1> 
  2688                              <1> .char_entered:
  2689 000039A7 BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  2690 000039AA E835F2              <1> 	call os_string_to_int
  2691 000039AD 89C3                <1> 	mov bx, ax
  2692                              <1> 
  2693 000039AF 0FB606007B          <1> 	movzx ax, byte [token]
  2694 000039B4 E8890B              <1> 	call set_var				; ...and store it!
  2695                              <1> 
  2696 000039B7 E85AE6              <1> 	call os_print_newline
  2697                              <1> 
  2698 000039BA E922F4              <1> 	jmp mainloop
  2699                              <1> 
  2700                              <1> 
  2701                              <1> .string_var:
  2702 000039BD 53                  <1> 	push bx
  2703                              <1> 
  2704 000039BE B8807A              <1> 	mov ax, .tmpstring
  2705 000039C1 E8BFE8              <1> 	call os_input_string
  2706                              <1> 
  2707 000039C4 BE807A              <1> 	mov si, .tmpstring
  2708 000039C7 BF007C              <1> 	mov di, string_vars
  2709                              <1> 
  2710 000039CA 5B                  <1> 	pop bx
  2711                              <1> 
  2712 000039CB B88000              <1> 	mov ax, 128
  2713 000039CE F7E3                <1> 	mul bx
  2714                              <1> 
  2715 000039D0 01C7                <1> 	add di, ax
  2716 000039D2 E85AF1              <1> 	call os_string_copy
  2717                              <1> 
  2718 000039D5 E83CE6              <1> 	call os_print_newline
  2719                              <1> 
  2720 000039D8 E904F4              <1> 	jmp mainloop
  2721                              <1> 
  2722                              <1> 
  2723                              <1> ;	.tmpstring	times 128 db 0
  2724                              <1> 	.tmpstring	equ 32768-1024-256-128
  2725                              <1> 
  2726                              <1> ; -----------------------------------------------------------
  2727                              <1> ; LEN
  2728                              <1> 
  2729                              <1> do_len:
  2730 000039DB E8710B              <1> 	call get_token
  2731 000039DE 83F802              <1> 	cmp ax, STRING_VAR
  2732 000039E1 7538                <1> 	jne .error
  2733                              <1>  
  2734 000039E3 BE007C              <1> 	mov si, string_vars
  2735 000039E6 B88000              <1> 	mov ax, 128
  2736 000039E9 F7E3                <1> 	mul bx
  2737 000039EB 01C6                <1> 	add si, ax
  2738                              <1> 
  2739 000039ED 89F0                <1> 	mov ax, si
  2740 000039EF E8AAF0              <1> 	call os_string_length
  2741 000039F2 A3[213A]            <1> 	mov word [.num1], ax
  2742                              <1> 
  2743 000039F5 E8570B              <1> 	call get_token
  2744 000039F8 83F801              <1> 	cmp ax, VARIABLE
  2745 000039FB 7406                <1> 	je .is_ok
  2746                              <1> 	
  2747 000039FD BE1400              <1> 	mov si, err_syntax
  2748 00003A00 E9650C              <1> 	jmp error
  2749                              <1> 
  2750                              <1> .is_ok:
  2751 00003A03 0FB606007B          <1> 	movzx ax, byte [token]
  2752 00003A08 88C3                <1> 	mov bl, al
  2753 00003A0A EB00                <1> 	jmp .finish
  2754                              <1> 
  2755                              <1> .finish:	
  2756 00003A0C 8B1E[213A]          <1> 	mov bx, [.num1]
  2757 00003A10 A0007B              <1> 	mov byte al, [token]
  2758 00003A13 E82A0B              <1> 	call set_var
  2759 00003A16 31C0                <1> 	xor ax, ax
  2760 00003A18 E9C4F3              <1> 	jmp mainloop
  2761                              <1>  
  2762                              <1> .error:
  2763 00003A1B BE1400              <1> 	mov si, err_syntax
  2764 00003A1E E9470C              <1> 	jmp error
  2765                              <1> 
  2766                              <1> 
  2767 00003A21 0000                <1> 	.num1 dw 0
  2768                              <1> 
  2769                              <1> 
  2770                              <1> ; ------------------------------------------------------------------
  2771                              <1> ; LISTBOX
  2772                              <1> 
  2773                              <1> do_listbox:
  2774 00003A23 8A3E[DD46]          <1> 	mov bh, [work_page]			; Store the cursor position
  2775 00003A27 B403                <1> 	mov ah, 03h
  2776 00003A29 CD10                <1> 	int 10h
  2777                              <1> 	
  2778 00003A2B E8210B              <1> 	call get_token
  2779 00003A2E 83F802              <1> 	cmp ax, STRING_VAR
  2780 00003A31 757C                <1> 	jne .error
  2781                              <1> 
  2782 00003A33 BE007C              <1> 	mov si, string_vars
  2783 00003A36 B88000              <1> 	mov ax, 128
  2784 00003A39 F7E3                <1> 	mul bx
  2785 00003A3B 01C6                <1> 	add si, ax
  2786                              <1> 
  2787 00003A3D 8936[B53A]          <1> 	mov word [.s1], si
  2788                              <1> 
  2789 00003A41 E80B0B              <1> 	call get_token
  2790 00003A44 83F802              <1> 	cmp ax, STRING_VAR
  2791 00003A47 7566                <1> 	jne .error
  2792                              <1> 
  2793 00003A49 BE007C              <1> 	mov si, string_vars
  2794 00003A4C B88000              <1> 	mov ax, 128
  2795 00003A4F F7E3                <1> 	mul bx
  2796 00003A51 01C6                <1> 	add si, ax
  2797                              <1> 
  2798 00003A53 8936[B73A]          <1> 	mov word [.s2], si
  2799                              <1> 
  2800 00003A57 E8F50A              <1> 	call get_token
  2801 00003A5A 83F802              <1> 	cmp ax, STRING_VAR
  2802 00003A5D 7550                <1> 	jne .error
  2803                              <1> 
  2804 00003A5F BE007C              <1> 	mov si, string_vars
  2805 00003A62 B88000              <1> 	mov ax, 128
  2806 00003A65 F7E3                <1> 	mul bx
  2807 00003A67 01C6                <1> 	add si, ax
  2808                              <1> 
  2809 00003A69 8936[B93A]          <1> 	mov word [.s3], si
  2810                              <1> 
  2811                              <1> 
  2812 00003A6D E8DF0A              <1> 	call get_token
  2813 00003A70 83F801              <1> 	cmp ax, VARIABLE
  2814 00003A73 753A                <1> 	jne .error
  2815                              <1> 
  2816 00003A75 A0007B              <1> 	mov byte al, [token]
  2817 00003A78 A2[BB3A]            <1> 	mov byte [.var], al
  2818                              <1> 
  2819 00003A7B A1[B53A]            <1> 	mov word ax, [.s1]
  2820 00003A7E 8B1E[B73A]          <1> 	mov word bx, [.s2]
  2821 00003A82 8B0E[B93A]          <1> 	mov word cx, [.s3]
  2822                              <1> 
  2823 00003A86 E8ECE1              <1> 	call os_list_dialog
  2824 00003A89 7217                <1> 	jc .esc_pressed
  2825                              <1> 
  2826 00003A8B 60                  <1> 	pusha
  2827 00003A8C 8A3E[DD46]          <1> 	mov bh, [work_page]			; Move the cursor back
  2828 00003A90 B402                <1> 	mov ah, 02h
  2829 00003A92 CD10                <1> 	int 10h
  2830 00003A94 61                  <1> 	popa
  2831                              <1> 
  2832 00003A95 89C3                <1> 	mov bx, ax
  2833 00003A97 0FB606[BB3A]        <1> 	movzx ax, byte [.var]
  2834 00003A9C E8A10A              <1> 	call set_var
  2835                              <1> 
  2836 00003A9F E93DF3              <1> 	jmp mainloop
  2837                              <1> 
  2838                              <1> 
  2839                              <1> .esc_pressed:
  2840 00003AA2 0FB606[BB3A]        <1> 	movzx ax, byte [.var]
  2841 00003AA7 31DB                <1> 	xor bx, bx
  2842 00003AA9 E8940A              <1> 	call set_var
  2843 00003AAC E930F3              <1> 	jmp mainloop
  2844                              <1> 
  2845                              <1> 
  2846                              <1> .error:
  2847 00003AAF BE1400              <1> 	mov si, err_syntax
  2848 00003AB2 E9B30B              <1> 	jmp error
  2849                              <1> 
  2850 00003AB5 0000                <1> 	.s1 dw 0
  2851 00003AB7 0000                <1> 	.s2 dw 0
  2852 00003AB9 0000                <1> 	.s3 dw 0
  2853 00003ABB 00                  <1> 	.var db 0
  2854                              <1> 
  2855                              <1> 
  2856                              <1> ; ------------------------------------------------------------------
  2857                              <1> ; LOAD
  2858                              <1> 
  2859                              <1> do_load:
  2860 00003ABC E8900A              <1> 	call get_token
  2861 00003ABF 83F805              <1> 	cmp ax, QUOTE
  2862 00003AC2 7411                <1> 	je .is_quote
  2863                              <1> 
  2864 00003AC4 83F802              <1> 	cmp ax, STRING_VAR
  2865 00003AC7 755F                <1> 	jne .error
  2866                              <1> 
  2867 00003AC9 BE007C              <1> 	mov si, string_vars
  2868 00003ACC B88000              <1> 	mov ax, 128
  2869 00003ACF F7E3                <1> 	mul bx
  2870 00003AD1 01C6                <1> 	add si, ax
  2871 00003AD3 EB03                <1> 	jmp .get_position
  2872                              <1> 
  2873                              <1> .is_quote:
  2874 00003AD5 BE007B              <1> 	mov si, token
  2875                              <1> 
  2876                              <1> .get_position:
  2877 00003AD8 89F0                <1> 	mov ax, si
  2878 00003ADA E8B1D4              <1> 	call os_file_exists
  2879 00003ADD 7239                <1> 	jc .file_not_exists
  2880                              <1> 
  2881 00003ADF 89C2                <1> 	mov dx, ax			; Store for now
  2882                              <1> 
  2883 00003AE1 E86B0A              <1> 	call get_token
  2884                              <1> 
  2885 00003AE4 83F801              <1> 	cmp ax, VARIABLE
  2886 00003AE7 7425                <1> 	je .second_is_var
  2887                              <1> 
  2888 00003AE9 83F803              <1> 	cmp ax, NUMBER
  2889 00003AEC 753A                <1> 	jne .error
  2890                              <1> 
  2891 00003AEE BE007B              <1> 	mov si, token
  2892 00003AF1 E8EEF0              <1> 	call os_string_to_int
  2893                              <1> 
  2894                              <1> .load_part:
  2895 00003AF4 89C1                <1> 	mov cx, ax
  2896                              <1> 
  2897 00003AF6 89D0                <1> 	mov ax, dx
  2898                              <1> 
  2899 00003AF8 E84FD1              <1> 	call os_load_file
  2900                              <1> 
  2901 00003AFB 31C0                <1> 	xor ax, ax
  2902 00003AFD B053                <1> 	mov byte al, 'S'
  2903 00003AFF E83E0A              <1> 	call set_var
  2904                              <1> 
  2905 00003B02 31C0                <1> 	xor ax, ax
  2906 00003B04 B052                <1> 	mov byte al, 'R'
  2907 00003B06 31DB                <1> 	xor bx, bx
  2908 00003B08 E8350A              <1> 	call set_var
  2909                              <1> 
  2910 00003B0B E9D1F2              <1> 	jmp mainloop
  2911                              <1> 
  2912                              <1> 
  2913                              <1> .second_is_var:
  2914 00003B0E 0FB606007B          <1> 	movzx ax, byte [token]
  2915 00003B13 E81D0A              <1> 	call get_var
  2916 00003B16 EBDC                <1> 	jmp .load_part
  2917                              <1> 
  2918                              <1> 
  2919                              <1> .file_not_exists:
  2920 00003B18 31C0                <1> 	xor ax, ax
  2921 00003B1A B052                <1> 	mov byte al, 'R'
  2922 00003B1C BB0100              <1> 	mov bx, 1
  2923 00003B1F E81E0A              <1> 	call set_var
  2924                              <1> 
  2925 00003B22 E82A0A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2926                              <1> 
  2927 00003B25 E9B7F2              <1> 	jmp mainloop
  2928                              <1> 
  2929                              <1> 
  2930                              <1> .error:
  2931 00003B28 BE1400              <1> 	mov si, err_syntax
  2932 00003B2B E93A0B              <1> 	jmp error
  2933                              <1> 
  2934                              <1> 
  2935                              <1> ; ------------------------------------------------------------------
  2936                              <1> ; LOOP
  2937                              <1> 
  2938                              <1> do_loop:
  2939 00003B2E 803E[DA46]00        <1> 	cmp byte [loop_in], 0
  2940 00003B33 0F84CA00            <1> 	je .no_do
  2941                              <1> 
  2942 00003B37 802E[DA46]02        <1> 	sub byte [loop_in], 2
  2943                              <1> 
  2944 00003B3C 31D2                <1> 	xor dx, dx
  2945                              <1> 
  2946 00003B3E E80E0A              <1> 	call get_token
  2947 00003B41 BF007B              <1> 	mov di, token
  2948                              <1> 	
  2949 00003B44 BE[193C]            <1> 	mov si, .endless_word
  2950 00003B47 E844F0              <1> 	call os_string_compare
  2951 00003B4A 0F829C00            <1> 	jc .loop_back
  2952                              <1> 	
  2953 00003B4E BE[0D3C]            <1> 	mov si, .while_word
  2954 00003B51 E83AF0              <1> 	call os_string_compare
  2955 00003B54 0F82A300            <1> 	jc .while_set
  2956                              <1> 	
  2957 00003B58 BE[133C]            <1> 	mov si, .until_word
  2958 00003B5B E830F0              <1> 	call os_string_compare
  2959 00003B5E 0F83A500            <1> 	jnc .error
  2960                              <1> 	
  2961                              <1> .get_first_var:
  2962 00003B62 E8EA09              <1> 	call get_token
  2963 00003B65 83F801              <1> 	cmp ax, VARIABLE
  2964 00003B68 0F859B00            <1> 	jne .error
  2965                              <1> 	
  2966 00003B6C A0007B              <1> 	mov al, [token]
  2967 00003B6F E8C109              <1> 	call get_var
  2968 00003B72 89C1                <1> 	mov cx, ax
  2969                              <1> 	
  2970                              <1> .check_equals:
  2971 00003B74 E8D809              <1> 	call get_token
  2972 00003B77 83F807              <1> 	cmp ax, UNKNOWN
  2973 00003B7A 0F858900            <1> 	jne .error
  2974                              <1> 
  2975 00003B7E A1007B              <1> 	mov ax, [token]
  2976 00003B81 3C3D                <1> 	cmp al, '='
  2977 00003B83 740A                <1> 	je .sign_ok
  2978 00003B85 3C3E                <1> 	cmp al, '>'
  2979 00003B87 7406                <1> 	je .sign_ok
  2980 00003B89 3C3C                <1> 	cmp al, '<'
  2981 00003B8B 7402                <1> 	je .sign_ok
  2982 00003B8D EB78                <1> 	jmp .error
  2983                              <1> 	.sign_ok:
  2984 00003B8F A2[213C]            <1> 	mov byte [.sign], al
  2985                              <1> 	
  2986                              <1> .get_second_var:
  2987 00003B92 E8BA09              <1>  	call get_token
  2988                              <1> 
  2989 00003B95 83F803              <1> 	cmp ax, NUMBER
  2990 00003B98 7419                <1> 	je .second_is_num
  2991                              <1> 
  2992 00003B9A 83F801              <1> 	cmp ax, VARIABLE
  2993 00003B9D 740C                <1> 	je .second_is_var
  2994                              <1> 
  2995 00003B9F 83F806              <1> 	cmp ax, CHAR
  2996 00003BA2 7563                <1> 	jne .error
  2997                              <1> 
  2998                              <1> .second_is_char:
  2999 00003BA4 B400                <1> 	mov ah, 0
  3000 00003BA6 A0007B              <1> 	mov al, [token]
  3001 00003BA9 EB0E                <1> 	jmp .check_true
  3002                              <1> 	
  3003                              <1> .second_is_var:
  3004 00003BAB A0007B              <1> 	mov al, [token]
  3005 00003BAE E88209              <1> 	call get_var
  3006 00003BB1 EB06                <1> 	jmp .check_true
  3007                              <1> 	
  3008                              <1> .second_is_num:
  3009 00003BB3 BE007B              <1> 	mov si, token
  3010 00003BB6 E829F0              <1> 	call os_string_to_int
  3011                              <1> 	
  3012                              <1> .check_true:
  3013 00003BB9 8A1E[213C]          <1> 	mov byte bl, [.sign]
  3014 00003BBD 80FB3D              <1> 	cmp bl, '='
  3015 00003BC0 7407                <1> 	je .sign_equals
  3016                              <1> 	
  3017 00003BC2 80FB3E              <1> 	cmp bl, '>'
  3018 00003BC5 7408                <1> 	je .sign_greater
  3019                              <1> 	
  3020 00003BC7 EB0C                <1> 	jmp .sign_lesser
  3021                              <1> 	
  3022                              <1> .sign_equals:
  3023 00003BC9 39C8                <1> 	cmp ax, cx
  3024 00003BCB 7516                <1> 	jne .false
  3025 00003BCD EB0C                <1> 	jmp .true
  3026                              <1> 	
  3027                              <1> .sign_greater:
  3028 00003BCF 39C8                <1> 	cmp ax, cx
  3029 00003BD1 7D10                <1> 	jge .false
  3030 00003BD3 EB06                <1> 	jmp .true
  3031                              <1> 	
  3032                              <1> .sign_lesser:
  3033 00003BD5 39C8                <1> 	cmp ax, cx
  3034 00003BD7 7E0A                <1> 	jle .false
  3035 00003BD9 EB00                <1> 	jmp .true
  3036                              <1> .true:
  3037 00003BDB 83FA01              <1> 	cmp dx, 1
  3038 00003BDE 740A                <1> 	je .loop_back
  3039 00003BE0 E9FCF1              <1> 	jmp mainloop
  3040                              <1> .false:
  3041 00003BE3 83FA01              <1> 	cmp dx, 1
  3042 00003BE6 0F84F5F1            <1> 	je mainloop
  3043                              <1> 	
  3044                              <1> .loop_back:	
  3045 00003BEA BED079              <1> 	mov word si, do_loop_store
  3046 00003BED A0[DA46]            <1> 	mov byte al, [loop_in]
  3047 00003BF0 B400                <1> 	mov ah, 0
  3048 00003BF2 01C6                <1> 	add si, ax
  3049 00003BF4 AD                  <1> 	lodsw
  3050 00003BF5 A3[D346]            <1> 	mov word [prog], ax
  3051 00003BF8 E9E4F1              <1> 	jmp mainloop
  3052                              <1> 	
  3053                              <1> .while_set:
  3054 00003BFB BA0100              <1> 	mov dx, 1
  3055 00003BFE E961FF              <1> 	jmp .get_first_var
  3056                              <1> 	
  3057                              <1> .no_do:
  3058 00003C01 BE0900              <1> 	mov si, err_loop
  3059 00003C04 E9610A              <1> 	jmp error
  3060                              <1> 
  3061                              <1> .error:
  3062 00003C07 BE1400              <1> 	mov si, err_syntax
  3063 00003C0A E95B0A              <1> 	jmp error
  3064                              <1> 	
  3065                              <1> .data:
  3066 00003C0D 5748494C4500        <1> 	.while_word			db "WHILE", 0
  3067 00003C13 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  3068 00003C19 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  3069 00003C21 00                  <1> 	.sign				db 0
  3070                              <1> 	
  3071                              <1> 	
  3072                              <1> ; ------------------------------------------------------------------
  3073                              <1> ; MOVE
  3074                              <1> 
  3075                              <1> do_move:
  3076 00003C22 E82A09              <1> 	call get_token
  3077                              <1> 
  3078 00003C25 83F801              <1> 	cmp ax, VARIABLE
  3079 00003C28 740A                <1> 	je .first_is_var
  3080                              <1> 
  3081 00003C2A BE007B              <1> 	mov si, token
  3082 00003C2D E8B2EF              <1> 	call os_string_to_int
  3083 00003C30 88C2                <1> 	mov dl, al
  3084 00003C32 EB0A                <1> 	jmp .onto_second
  3085                              <1> 
  3086                              <1> .first_is_var:
  3087 00003C34 0FB606007B          <1> 	movzx ax, byte [token]
  3088 00003C39 E8F708              <1> 	call get_var
  3089 00003C3C 88C2                <1> 	mov dl, al
  3090                              <1> 
  3091                              <1> .onto_second:
  3092 00003C3E E80E09              <1> 	call get_token
  3093                              <1> 
  3094 00003C41 83F801              <1> 	cmp ax, VARIABLE
  3095 00003C44 740A                <1> 	je .second_is_var
  3096                              <1> 
  3097 00003C46 BE007B              <1> 	mov si, token
  3098 00003C49 E896EF              <1> 	call os_string_to_int
  3099 00003C4C 88C6                <1> 	mov dh, al
  3100 00003C4E EB0A                <1> 	jmp .finish
  3101                              <1> 
  3102                              <1> .second_is_var:
  3103 00003C50 0FB606007B          <1> 	movzx ax, byte [token]
  3104 00003C55 E8DB08              <1> 	call get_var
  3105 00003C58 88C6                <1> 	mov dh, al
  3106                              <1> 
  3107                              <1> .finish:
  3108 00003C5A 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  3109 00003C5E B402                <1> 	mov ah, 2
  3110 00003C60 CD10                <1> 	int 10h
  3111                              <1> 
  3112 00003C62 E97AF1              <1> 	jmp mainloop
  3113                              <1> 
  3114                              <1> 
  3115                              <1> ; ------------------------------------------------------------------
  3116                              <1> ; NEXT
  3117                              <1> 
  3118                              <1> do_next:
  3119 00003C65 E8E708              <1> 	call get_token
  3120                              <1> 
  3121 00003C68 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  3122 00003C6B 753F                <1> 	jne .error
  3123                              <1> 
  3124 00003C6D 0FB606007B          <1> 	movzx ax, byte [token]
  3125 00003C72 E8BE08              <1> 	call get_var
  3126                              <1> 
  3127 00003C75 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  3128                              <1> 
  3129 00003C76 89C3                <1> 	mov bx, ax
  3130                              <1> 
  3131 00003C78 0FB606007B          <1> 	movzx ax, byte [token]
  3132                              <1> 
  3133 00003C7D 2C41                <1> 	sub al, 65
  3134 00003C7F BE187A              <1> 	mov si, for_variables
  3135 00003C82 01C6                <1> 	add si, ax
  3136 00003C84 01C6                <1> 	add si, ax
  3137 00003C86 AD                  <1> 	lodsw					; Get the target number from the table
  3138                              <1> 
  3139 00003C87 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  3140 00003C88 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  3141 00003C8A 741D                <1> 	je .loop_finished
  3142                              <1> 
  3143 00003C8C 0FB606007B          <1> 	movzx ax, byte [token]
  3144 00003C91 E8AC08              <1> 	call set_var
  3145                              <1> 
  3146 00003C94 0FB606007B          <1> 	movzx ax, byte [token]
  3147 00003C99 2C41                <1> 	sub al, 65
  3148 00003C9B BEE479              <1> 	mov si, for_code_points
  3149 00003C9E 01C6                <1> 	add si, ax
  3150 00003CA0 01C6                <1> 	add si, ax
  3151 00003CA2 AD                  <1> 	lodsw
  3152                              <1> 
  3153 00003CA3 A3[D346]            <1> 	mov word [prog], ax
  3154 00003CA6 E936F1              <1> 	jmp mainloop
  3155                              <1> 
  3156                              <1> 
  3157                              <1> .loop_finished:
  3158 00003CA9 E933F1              <1> 	jmp mainloop
  3159                              <1> 
  3160                              <1> .error:
  3161 00003CAC BE1400              <1> 	mov si, err_syntax
  3162 00003CAF E9B609              <1> 	jmp error
  3163                              <1> 
  3164                              <1> 
  3165                              <1> 
  3166                              <1> ;-------------------------------------------------------------------
  3167                              <1> ; NUMBER
  3168                              <1> 
  3169                              <1> do_number:
  3170 00003CB2 E89A08              <1> 	call get_token			; Check if it's string to number, or number to string
  3171                              <1> 
  3172 00003CB5 83F802              <1> 	cmp ax, STRING_VAR
  3173 00003CB8 7407                <1> 	je .is_string
  3174                              <1> 
  3175 00003CBA 83F801              <1> 	cmp ax, VARIABLE
  3176 00003CBD 742C                <1> 	je .is_variable
  3177                              <1> 
  3178 00003CBF EB54                <1> 	jmp .error
  3179                              <1> 
  3180                              <1> .is_string:
  3181                              <1> 
  3182 00003CC1 BE007C              <1> 	mov si, string_vars
  3183 00003CC4 B88000              <1> 	mov ax, 128
  3184 00003CC7 F7E3                <1> 	mul bx
  3185 00003CC9 01C6                <1> 	add si, ax
  3186 00003CCB 8936[1B3D]          <1> 	mov [.tmp], si
  3187                              <1> 
  3188 00003CCF E87D08              <1> 	call get_token
  3189                              <1> 
  3190 00003CD2 8B36[1B3D]          <1> 	mov si, [.tmp]
  3191                              <1> 
  3192 00003CD6 83F801              <1> 	cmp ax, VARIABLE
  3193 00003CD9 753A                <1> 	jne .error
  3194                              <1> 
  3195 00003CDB E804EF              <1> 	call os_string_to_int
  3196 00003CDE 89C3                <1> 	mov bx, ax
  3197                              <1> 
  3198 00003CE0 0FB606007B          <1> 	movzx ax, byte [token]
  3199 00003CE5 E85808              <1> 	call set_var
  3200                              <1> 
  3201 00003CE8 E9F4F0              <1> 	jmp mainloop
  3202                              <1> 
  3203                              <1> .is_variable:
  3204 00003CEB 0FB606007B          <1> 	movzx ax, byte [token]
  3205 00003CF0 E84008              <1> 	call get_var
  3206                              <1> 
  3207 00003CF3 E837EF              <1> 	call os_int_to_string		; Convert to a string
  3208 00003CF6 A3[1B3D]            <1> 	mov [.tmp], ax
  3209                              <1> 
  3210 00003CF9 E85308              <1> 	call get_token			; Get the second parameter
  3211                              <1> 
  3212 00003CFC 8B36[1B3D]          <1> 	mov si, [.tmp]
  3213                              <1> 
  3214 00003D00 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  3215 00003D03 7510                <1> 	jne .error
  3216                              <1> 
  3217 00003D05 BF007C              <1> 	mov di, string_vars		; Locate string variable
  3218 00003D08 B88000              <1> 	mov ax, 128
  3219 00003D0B F7E3                <1> 	mul bx
  3220 00003D0D 01C7                <1> 	add di, ax
  3221                              <1> 
  3222 00003D0F E81DEE              <1> 	call os_string_copy		; Save converted string
  3223                              <1> 
  3224 00003D12 E9CAF0              <1> 	jmp mainloop
  3225                              <1> 
  3226                              <1> .error:
  3227 00003D15 BE1400              <1> 	mov si, err_syntax
  3228 00003D18 E94D09              <1> 	jmp error
  3229                              <1> 
  3230                              <1> 
  3231 00003D1B 0000                <1> 	.tmp		dw 	0
  3232                              <1> 
  3233                              <1> 
  3234                              <1> ;-------------------------------------------------------------------
  3235                              <1> ; PAGE
  3236                              <1> 
  3237                              <1> do_page:
  3238 00003D1D E82F08              <1> 	call get_token
  3239 00003D20 83F803              <1> 	cmp ax, NUMBER
  3240 00003D23 7521                <1> 	jne .error
  3241                              <1> 
  3242 00003D25 BE007B              <1> 	mov si, token
  3243 00003D28 E8B7EE              <1> 	call os_string_to_int
  3244 00003D2B A2[DD46]            <1> 	mov byte [work_page], al	; Set work page variable
  3245                              <1> 
  3246 00003D2E E81E08              <1> 	call get_token
  3247 00003D31 83F803              <1> 	cmp ax, NUMBER
  3248 00003D34 7510                <1> 	jne .error
  3249                              <1> 
  3250 00003D36 BE007B              <1> 	mov si, token
  3251 00003D39 E8A6EE              <1> 	call os_string_to_int
  3252 00003D3C A2[DE46]            <1> 	mov byte [disp_page], al	; Set display page variable
  3253                              <1> 
  3254                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  3255 00003D3F B405                <1> 	mov ah, 5
  3256 00003D41 CD10                <1> 	int 10h
  3257                              <1> 
  3258 00003D43 E999F0              <1> 	jmp mainloop
  3259                              <1> 
  3260                              <1> .error:
  3261 00003D46 BE1400              <1> 	mov si, err_syntax
  3262 00003D49 E91C09              <1> 	jmp error
  3263                              <1> 
  3264                              <1> 
  3265                              <1> ; ------------------------------------------------------------------
  3266                              <1> ; PAUSE
  3267                              <1> 
  3268                              <1> do_pause:
  3269 00003D4C E80008              <1> 	call get_token
  3270                              <1> 
  3271 00003D4F 83F801              <1> 	cmp ax, VARIABLE
  3272 00003D52 7408                <1> 	je .is_var
  3273                              <1> 
  3274 00003D54 BE007B              <1> 	mov si, token
  3275 00003D57 E888EE              <1> 	call os_string_to_int
  3276 00003D5A EB08                <1> 	jmp .finish
  3277                              <1> 
  3278                              <1> .is_var:
  3279 00003D5C 0FB606007B          <1> 	movzx ax, byte [token]
  3280 00003D61 E8CF07              <1> 	call get_var
  3281                              <1> 
  3282                              <1> .finish:
  3283 00003D64 E822D8              <1> 	call os_pause
  3284 00003D67 E975F0              <1> 	jmp mainloop
  3285                              <1> 
  3286                              <1> 
  3287                              <1> ; ------------------------------------------------------------------
  3288                              <1> ; PEEK
  3289                              <1> 
  3290                              <1> do_peek:
  3291 00003D6A E8E207              <1> 	call get_token
  3292                              <1> 
  3293 00003D6D 83F801              <1> 	cmp ax, VARIABLE
  3294 00003D70 7533                <1> 	jne .error
  3295                              <1> 
  3296 00003D72 0FB606007B          <1> 	movzx ax, byte [token]
  3297 00003D77 A2[AB3D]            <1> 	mov byte [.tmp_var], al
  3298                              <1> 
  3299 00003D7A E8D207              <1> 	call get_token
  3300                              <1> 
  3301 00003D7D 83F801              <1> 	cmp ax, VARIABLE
  3302 00003D80 741B                <1> 	je .dereference
  3303                              <1> 
  3304 00003D82 83F803              <1> 	cmp ax, NUMBER
  3305 00003D85 751E                <1> 	jne .error
  3306                              <1> 
  3307 00003D87 BE007B              <1> 	mov si, token
  3308 00003D8A E855EE              <1> 	call os_string_to_int
  3309                              <1> 
  3310                              <1> .store:
  3311 00003D8D 89C6                <1> 	mov si, ax
  3312 00003D8F 0FB61C              <1> 	movzx bx, byte [si]
  3313 00003D92 0FB606[AB3D]        <1> 	movzx ax, byte [.tmp_var]
  3314 00003D97 E8A607              <1> 	call set_var
  3315                              <1> 
  3316 00003D9A E942F0              <1> 	jmp mainloop
  3317                              <1> 
  3318                              <1> .dereference:
  3319 00003D9D A0007B              <1> 	mov byte al, [token]
  3320 00003DA0 E89007              <1> 	call get_var
  3321 00003DA3 EBE8                <1> 	jmp .store
  3322                              <1> 
  3323                              <1> .error:
  3324 00003DA5 BE1400              <1> 	mov si, err_syntax
  3325 00003DA8 E9BD08              <1> 	jmp error
  3326                              <1> 
  3327                              <1> 
  3328 00003DAB 00                  <1> 	.tmp_var	db 0
  3329                              <1> 	
  3330                              <1> 	
  3331                              <1> 	
  3332                              <1> ; ------------------------------------------------------------------
  3333                              <1> ; PEEKINT
  3334                              <1> 
  3335                              <1> do_peekint:
  3336 00003DAC E8A007              <1> 	call get_token
  3337                              <1> 	
  3338 00003DAF 83F801              <1> 	cmp ax, VARIABLE
  3339 00003DB2 752C                <1> 	jne .error
  3340                              <1> 
  3341                              <1> .get_second:
  3342 00003DB4 A0007B              <1> 	mov al, [token]
  3343 00003DB7 89C1                <1> 	mov cx, ax
  3344                              <1> 	
  3345 00003DB9 E89307              <1> 	call get_token
  3346                              <1> 	
  3347 00003DBC 83F801              <1> 	cmp ax, VARIABLE
  3348 00003DBF 740D                <1> 	je .address_is_var
  3349                              <1> 	
  3350 00003DC1 83F803              <1> 	cmp ax, NUMBER
  3351 00003DC4 751A                <1> 	jne .error
  3352                              <1> 	
  3353                              <1> .address_is_number:
  3354 00003DC6 BE007B              <1> 	mov si, token
  3355 00003DC9 E816EE              <1> 	call os_string_to_int
  3356 00003DCC EB06                <1> 	jmp .load_data
  3357                              <1> 	
  3358                              <1> .address_is_var:
  3359 00003DCE A0007B              <1> 	mov al, [token]
  3360 00003DD1 E85F07              <1> 	call get_var
  3361                              <1> 	
  3362                              <1> .load_data:
  3363 00003DD4 89C6                <1> 	mov si, ax
  3364 00003DD6 8B1C                <1> 	mov bx, [si]
  3365 00003DD8 89C8                <1> 	mov ax, cx
  3366 00003DDA E86307              <1> 	call set_var
  3367                              <1> 	
  3368 00003DDD E9FFEF              <1> 	jmp mainloop
  3369                              <1> 	
  3370                              <1> .error:
  3371 00003DE0 BE1400              <1> 	mov si, err_syntax
  3372 00003DE3 E98208              <1> 	jmp error
  3373                              <1> 
  3374                              <1> 
  3375                              <1> 
  3376                              <1> ; ------------------------------------------------------------------
  3377                              <1> ; POKE
  3378                              <1> 
  3379                              <1> do_poke:
  3380 00003DE6 E86607              <1> 	call get_token
  3381                              <1> 
  3382 00003DE9 83F801              <1> 	cmp ax, VARIABLE
  3383 00003DEC 7415                <1> 	je .first_is_var
  3384                              <1> 
  3385 00003DEE 83F803              <1> 	cmp ax, NUMBER
  3386 00003DF1 7544                <1> 	jne .error
  3387                              <1> 
  3388 00003DF3 BE007B              <1> 	mov si, token
  3389 00003DF6 E8E9ED              <1> 	call os_string_to_int
  3390                              <1> 
  3391 00003DF9 3DFF00              <1> 	cmp ax, 255
  3392 00003DFC 7F39                <1> 	jg .error
  3393                              <1> 
  3394 00003DFE A2[3D3E]            <1> 	mov byte [.first_value], al
  3395 00003E01 EB0B                <1> 	jmp .onto_second
  3396                              <1> 
  3397                              <1> 
  3398                              <1> .first_is_var:
  3399 00003E03 0FB606007B          <1> 	movzx ax, byte [token]
  3400 00003E08 E82807              <1> 	call get_var
  3401                              <1> 
  3402 00003E0B A2[3D3E]            <1> 	mov byte [.first_value], al
  3403                              <1> 
  3404                              <1> .onto_second:
  3405 00003E0E E83E07              <1> 	call get_token
  3406                              <1> 
  3407 00003E11 83F801              <1> 	cmp ax, VARIABLE
  3408 00003E14 7417                <1> 	je .second_is_var
  3409                              <1> 
  3410 00003E16 83F803              <1> 	cmp ax, NUMBER
  3411 00003E19 751C                <1> 	jne .error
  3412                              <1> 
  3413 00003E1B BE007B              <1> 	mov si, token
  3414 00003E1E E8C1ED              <1> 	call os_string_to_int
  3415                              <1> 
  3416                              <1> .got_value:
  3417 00003E21 89C7                <1> 	mov di, ax
  3418 00003E23 0FB606[3D3E]        <1> 	movzx ax, byte [.first_value]
  3419 00003E28 8805                <1> 	mov byte [di], al
  3420                              <1> 
  3421 00003E2A E9B2EF              <1> 	jmp mainloop
  3422                              <1> 
  3423                              <1> .second_is_var:
  3424 00003E2D 0FB606007B          <1> 	movzx ax, byte [token]
  3425 00003E32 E8FE06              <1> 	call get_var
  3426 00003E35 EBEA                <1> 	jmp .got_value
  3427                              <1> 
  3428                              <1> .error:
  3429 00003E37 BE1400              <1> 	mov si, err_syntax
  3430 00003E3A E92B08              <1> 	jmp error
  3431                              <1> 
  3432                              <1> 
  3433 00003E3D 00                  <1> 	.first_value	db 0
  3434                              <1> 
  3435                              <1> 
  3436                              <1> 
  3437                              <1> 
  3438                              <1> ; ------------------------------------------------------------------
  3439                              <1> ; POKEINT
  3440                              <1> 
  3441                              <1> do_pokeint:
  3442 00003E3E E80E07              <1> 	call get_token
  3443                              <1> 	
  3444 00003E41 83F801              <1> 	cmp ax, VARIABLE
  3445 00003E44 740D                <1> 	je .data_is_var
  3446                              <1> 	
  3447 00003E46 83F803              <1> 	cmp ax, NUMBER
  3448 00003E49 7532                <1> 	jne .error
  3449                              <1> 
  3450                              <1> .data_is_num:
  3451 00003E4B BE007B              <1> 	mov si, token
  3452 00003E4E E891ED              <1> 	call os_string_to_int
  3453 00003E51 EB06                <1> 	jmp .get_second
  3454                              <1> 	
  3455                              <1> .data_is_var:
  3456 00003E53 A0007B              <1> 	mov al, [token]
  3457 00003E56 E8DA06              <1> 	call get_var
  3458                              <1> 	
  3459                              <1> .get_second:
  3460 00003E59 89C1                <1> 	mov cx, ax
  3461                              <1> 	
  3462 00003E5B E8F106              <1> 	call get_token
  3463                              <1> 	
  3464 00003E5E 83F801              <1> 	cmp ax, VARIABLE
  3465 00003E61 740D                <1> 	je .address_is_var
  3466                              <1> 	
  3467 00003E63 83F803              <1> 	cmp ax, NUMBER
  3468 00003E66 7515                <1> 	jne .error
  3469                              <1> 	
  3470                              <1> .address_is_num:
  3471 00003E68 BE007B              <1> 	mov si, token
  3472 00003E6B E874ED              <1> 	call os_string_to_int
  3473 00003E6E EB06                <1> 	jmp .save_data
  3474                              <1> 	
  3475                              <1> .address_is_var:
  3476 00003E70 A0007B              <1> 	mov al, [token]
  3477 00003E73 E8BD06              <1> 	call get_var
  3478                              <1> 	
  3479                              <1> .save_data:
  3480 00003E76 89C6                <1> 	mov si, ax
  3481 00003E78 890C                <1> 	mov [si], cx
  3482                              <1> 	
  3483 00003E7A E962EF              <1> 	jmp mainloop
  3484                              <1> 	
  3485                              <1> .error:
  3486 00003E7D BE1400              <1> 	mov si, err_syntax
  3487 00003E80 E9E507              <1> 	jmp error
  3488                              <1> 
  3489                              <1> 
  3490                              <1> 
  3491                              <1> 
  3492                              <1> ; ------------------------------------------------------------------
  3493                              <1> ; PORT
  3494                              <1> 
  3495                              <1> do_port:
  3496 00003E83 E8C906              <1> 	call get_token
  3497 00003E86 BE007B              <1> 	mov si, token
  3498                              <1> 
  3499 00003E89 BF[FE3E]            <1> 	mov di, .out_cmd
  3500 00003E8C E8FFEC              <1> 	call os_string_compare
  3501 00003E8F 720A                <1> 	jc .do_out_cmd
  3502                              <1> 
  3503 00003E91 BF[023F]            <1> 	mov di, .in_cmd
  3504 00003E94 E8F7EC              <1> 	call os_string_compare
  3505 00003E97 7237                <1> 	jc .do_in_cmd
  3506                              <1> 
  3507 00003E99 EB5D                <1> 	jmp .error
  3508                              <1> 
  3509                              <1> 
  3510                              <1> .do_out_cmd:
  3511 00003E9B E8B106              <1> 	call get_token
  3512 00003E9E 83F803              <1> 	cmp ax, NUMBER
  3513 00003EA1 7555                <1> 	jne .error
  3514                              <1> 
  3515 00003EA3 BE007B              <1> 	mov si, token
  3516 00003EA6 E839ED              <1> 	call os_string_to_int		; Now AX = port number
  3517 00003EA9 89C2                <1> 	mov dx, ax
  3518                              <1> 
  3519 00003EAB E8A106              <1> 	call get_token
  3520 00003EAE 83F803              <1> 	cmp ax, NUMBER
  3521 00003EB1 7407                <1> 	je .out_is_num
  3522                              <1> 
  3523 00003EB3 83F801              <1> 	cmp ax, VARIABLE
  3524 00003EB6 740C                <1> 	je .out_is_var
  3525                              <1> 
  3526 00003EB8 EB3E                <1> 	jmp .error
  3527                              <1> 
  3528                              <1> .out_is_num:
  3529 00003EBA BE007B              <1> 	mov si, token
  3530 00003EBD E822ED              <1> 	call os_string_to_int
  3531 00003EC0 EE                  <1> 	out dx, al
  3532 00003EC1 E91BEF              <1> 	jmp mainloop
  3533                              <1> 
  3534                              <1> .out_is_var:
  3535 00003EC4 0FB606007B          <1> 	movzx ax, byte [token]
  3536 00003EC9 E86706              <1> 	call get_var
  3537                              <1> 
  3538 00003ECC EE                  <1> 	out dx, al
  3539 00003ECD E90FEF              <1> 	jmp mainloop
  3540                              <1> 
  3541                              <1> 
  3542                              <1> .do_in_cmd:
  3543 00003ED0 E87C06              <1> 	call get_token
  3544 00003ED3 83F803              <1> 	cmp ax, NUMBER
  3545 00003ED6 7520                <1> 	jne .error
  3546                              <1> 
  3547 00003ED8 BE007B              <1> 	mov si, token
  3548 00003EDB E804ED              <1> 	call os_string_to_int
  3549 00003EDE 89C2                <1> 	mov dx, ax
  3550                              <1> 
  3551 00003EE0 E86C06              <1> 	call get_token
  3552 00003EE3 83F801              <1> 	cmp ax, VARIABLE
  3553 00003EE6 7510                <1> 	jne .error
  3554                              <1> 
  3555 00003EE8 8A0E007B            <1> 	mov byte cl, [token]
  3556                              <1> 
  3557 00003EEC EC                  <1> 	in al, dx
  3558 00003EED 0FB6D8              <1> 	movzx bx, al
  3559                              <1> 
  3560 00003EF0 88C8                <1> 	mov al, cl
  3561 00003EF2 E84B06              <1> 	call set_var
  3562                              <1> 
  3563 00003EF5 E9E7EE              <1> 	jmp mainloop
  3564                              <1> 
  3565                              <1> 
  3566                              <1> .error:
  3567 00003EF8 BE1400              <1> 	mov si, err_syntax
  3568 00003EFB E96A07              <1> 	jmp error
  3569                              <1> 
  3570                              <1> 
  3571 00003EFE 4F555400            <1> 	.out_cmd	db "OUT", 0
  3572 00003F02 494E00              <1> 	.in_cmd		db "IN", 0
  3573                              <1> 
  3574                              <1> 
  3575                              <1> ; ------------------------------------------------------------------
  3576                              <1> ; PRINT
  3577                              <1> 
  3578                              <1> do_print:
  3579 00003F05 E84706              <1> 	call get_token				; Get part after PRINT
  3580                              <1> 
  3581 00003F08 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  3582 00003F0B 7428                <1> 	je .print_quote
  3583                              <1> 
  3584 00003F0D 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  3585 00003F10 7410                <1> 	je .print_var
  3586                              <1> 
  3587 00003F12 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  3588 00003F15 7457                <1> 	je .print_string_var
  3589                              <1> 
  3590 00003F17 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  3591 00003F1A 745E                <1> 	je .print_keyword
  3592                              <1> 
  3593 00003F1C BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  3594 00003F1F E94607              <1> 	jmp error
  3595                              <1> 
  3596                              <1> 
  3597                              <1> .print_var:
  3598 00003F22 0FB606007B          <1> 	movzx ax, byte [token]
  3599 00003F27 E80906              <1> 	call get_var				; Get its value
  3600                              <1> 
  3601 00003F2A E800ED              <1> 	call os_int_to_string			; Convert to string
  3602 00003F2D 89C6                <1> 	mov si, ax
  3603 00003F2F E884D9              <1> 	call os_print_string
  3604                              <1> 
  3605 00003F32 E9C500              <1> 	jmp .newline_or_not
  3606                              <1> 
  3607                              <1> 
  3608                              <1> .print_quote:					; If it's quoted text, print it
  3609 00003F35 BE007B              <1> 	mov si, token
  3610                              <1> .print_quote_loop:
  3611 00003F38 AC                  <1> 	lodsb
  3612 00003F39 3C00                <1> 	cmp al, 0
  3613 00003F3B 0F84BB00            <1> 	je .newline_or_not
  3614                              <1> 
  3615 00003F3F B409                <1> 	mov ah, 09h
  3616 00003F41 8A1E[DC46]          <1> 	mov byte bl, [ink_colour]
  3617 00003F45 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  3618 00003F49 B90100              <1> 	mov cx, 1
  3619 00003F4C CD10                <1> 	int 10h
  3620                              <1> 
  3621 00003F4E B403                <1> 	mov ah, 3
  3622 00003F50 CD10                <1> 	int 10h
  3623                              <1> 
  3624 00003F52 80FA4F              <1> 	cmp dl, 79
  3625 00003F55 7D0C                <1> 	jge .quote_newline
  3626 00003F57 FEC2                <1> 	inc dl
  3627                              <1> 
  3628                              <1> .move_cur_quote:
  3629 00003F59 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  3630 00003F5D B402                <1> 	mov ah, 02h
  3631 00003F5F CD10                <1> 	int 10h
  3632 00003F61 EBD5                <1> 	jmp .print_quote_loop
  3633                              <1> 
  3634                              <1> 
  3635                              <1> .quote_newline:
  3636 00003F63 80FE18              <1> 	cmp dh, 24
  3637 00003F66 74F1                <1> 	je .move_cur_quote
  3638 00003F68 B200                <1> 	mov dl, 0
  3639 00003F6A FEC6                <1> 	inc dh
  3640 00003F6C EBEB                <1> 	jmp .move_cur_quote
  3641                              <1> 
  3642                              <1> .print_string_var:
  3643 00003F6E BE007C              <1> 	mov si, string_vars
  3644 00003F71 B88000              <1> 	mov ax, 128
  3645 00003F74 F7E3                <1> 	mul bx
  3646 00003F76 01C6                <1> 	add si, ax
  3647                              <1> 
  3648 00003F78 EBBE                <1> 	jmp .print_quote_loop
  3649                              <1> 
  3650                              <1> 
  3651                              <1> .print_keyword:
  3652 00003F7A BE007B              <1> 	mov si, token
  3653 00003F7D BF[0748]            <1> 	mov di, chr_keyword
  3654 00003F80 E80BEC              <1> 	call os_string_compare
  3655 00003F83 720E                <1> 	jc .is_chr
  3656                              <1> 
  3657 00003F85 BF[0B48]            <1> 	mov di, hex_keyword
  3658 00003F88 E803EC              <1> 	call os_string_compare
  3659 00003F8B 7243                <1> 	jc .is_hex
  3660                              <1> 
  3661 00003F8D BE1400              <1> 	mov si, err_syntax
  3662 00003F90 E9D506              <1> 	jmp error
  3663                              <1> 
  3664                              <1> .is_chr:
  3665 00003F93 E8B905              <1> 	call get_token
  3666                              <1> 
  3667 00003F96 83F801              <1> 	cmp ax, VARIABLE
  3668 00003F99 7405                <1> 	je .is_chr_variable
  3669                              <1> 	
  3670 00003F9B 83F803              <1> 	cmp ax, NUMBER
  3671 00003F9E 740A                <1> 	je .is_chr_number
  3672                              <1> 
  3673                              <1> .is_chr_variable:
  3674 00003FA0 0FB606007B          <1> 	movzx ax, byte [token]
  3675 00003FA5 E88B05              <1> 	call get_var
  3676 00003FA8 EB06                <1> 	jmp .print_chr
  3677                              <1> 	
  3678                              <1> .is_chr_number:
  3679 00003FAA BE007B              <1> 	mov si, token
  3680 00003FAD E832EC              <1> 	call os_string_to_int
  3681                              <1> 
  3682                              <1> .print_chr:
  3683 00003FB0 B409                <1> 	mov ah, 09h
  3684 00003FB2 8A1E[DC46]          <1> 	mov byte bl, [ink_colour]
  3685 00003FB6 8A3E[DD46]          <1> 	mov byte bh, [work_page]
  3686 00003FBA B90100              <1> 	mov cx, 1
  3687 00003FBD CD10                <1> 	int 10h
  3688                              <1> 
  3689 00003FBF B403                <1> 	mov ah, 3		; Move the cursor forward
  3690 00003FC1 CD10                <1> 	int 10h
  3691 00003FC3 FEC2                <1> 	inc dl
  3692 00003FC5 80FA4F              <1> 	cmp dl, 79
  3693 00003FC8 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  3694                              <1> .move_cur:
  3695 00003FCA B402                <1> 	mov ah, 2
  3696 00003FCC CD10                <1> 	int 10h
  3697                              <1> 
  3698 00003FCE EB2A                <1> 	jmp .newline_or_not
  3699                              <1> 
  3700                              <1> 
  3701                              <1> .is_hex:
  3702 00003FD0 E87C05              <1> 	call get_token
  3703                              <1> 
  3704 00003FD3 83F801              <1> 	cmp ax, VARIABLE
  3705 00003FD6 751C                <1> 	jne .error
  3706                              <1> 
  3707 00003FD8 0FB606007B          <1> 	movzx ax, byte [token]
  3708 00003FDD E85305              <1> 	call get_var
  3709                              <1> 
  3710 00003FE0 E885E2              <1> 	call os_print_2hex
  3711                              <1> 
  3712 00003FE3 EB15                <1> 	jmp .newline_or_not
  3713                              <1> 
  3714                              <1> .end_line:
  3715 00003FE5 B200                <1> 	mov dl, 0
  3716 00003FE7 FEC6                <1> 	inc dh
  3717 00003FE9 80FE19              <1> 	cmp dh, 25
  3718 00003FEC 7CDC                <1> 	jl .move_cur
  3719 00003FEE B618                <1> 	mov dh, 24
  3720 00003FF0 B24F                <1> 	mov dl, 79
  3721 00003FF2 EBD6                <1> 	jmp .move_cur
  3722                              <1> 
  3723                              <1> .error:
  3724 00003FF4 BE1400              <1> 	mov si, err_syntax
  3725 00003FF7 E96E06              <1> 	jmp error
  3726                              <1> 	
  3727                              <1> 
  3728                              <1> 
  3729                              <1> .newline_or_not:
  3730                              <1> 	; We want to see if the command ends with ';' -- which means that
  3731                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3732                              <1> 	; current program location to pop ahead and see if there's the ';'
  3733                              <1> 	; character -- otherwise we put the program location back and resume
  3734                              <1> 	; the main loop
  3735                              <1> 
  3736 00003FFA A1[D346]            <1> 	mov word ax, [prog]
  3737 00003FFD A3[3040]            <1> 	mov word [.tmp_loc], ax
  3738                              <1> 
  3739 00004000 E84C05              <1> 	call get_token
  3740 00004003 83F807              <1> 	cmp ax, UNKNOWN
  3741 00004006 750C                <1> 	jne .ignore
  3742                              <1> 
  3743 00004008 0FB606007B          <1> 	movzx ax, byte [token]
  3744 0000400D 3C3B                <1> 	cmp al, ';'
  3745 0000400F 7503                <1> 	jne .ignore
  3746                              <1> 
  3747 00004011 E9CBED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3748                              <1> 
  3749                              <1> .ignore:
  3750 00004014 B405                <1> 	mov ah, 5
  3751 00004016 A0[DD46]            <1> 	mov al, [work_page]
  3752 00004019 CD10                <1> 	int 10h
  3753                              <1> 
  3754 0000401B 8A3E[DD46]          <1> 	mov bh, [work_page]
  3755 0000401F E8F2DF              <1> 	call os_print_newline
  3756                              <1> 
  3757 00004022 B405                <1> 	mov ah, 5
  3758 00004024 A0[DE46]            <1> 	mov al, [disp_page]
  3759                              <1> 
  3760 00004027 A1[3040]            <1> 	mov word ax, [.tmp_loc]
  3761 0000402A A3[D346]            <1> 	mov word [prog], ax
  3762                              <1> 
  3763 0000402D E9AFED              <1> 	jmp mainloop
  3764                              <1> 
  3765                              <1> 
  3766 00004030 0000                <1> 	.tmp_loc	dw 0
  3767                              <1> 
  3768                              <1> 
  3769                              <1> ; ------------------------------------------------------------------
  3770                              <1> ; RAND
  3771                              <1> 
  3772                              <1> do_rand:
  3773 00004032 E81A05              <1> 	call get_token
  3774 00004035 83F801              <1> 	cmp ax, VARIABLE
  3775 00004038 7544                <1> 	jne .error
  3776                              <1> 
  3777 0000403A A0007B              <1> 	mov byte al, [token]
  3778 0000403D A2[7940]            <1> 	mov byte [.tmp], al
  3779                              <1> 
  3780 00004040 E80C05              <1> 	call get_token
  3781 00004043 83F803              <1> 	cmp ax, NUMBER
  3782 00004046 7536                <1> 	jne .error
  3783                              <1> 
  3784 00004048 BE007B              <1> 	mov si, token
  3785 0000404B E894EB              <1> 	call os_string_to_int
  3786 0000404E A3[7A40]            <1> 	mov word [.num1], ax
  3787                              <1> 
  3788 00004051 E8FB04              <1> 	call get_token
  3789 00004054 83F803              <1> 	cmp ax, NUMBER
  3790 00004057 7525                <1> 	jne .error
  3791                              <1> 
  3792 00004059 BE007B              <1> 	mov si, token
  3793 0000405C E883EB              <1> 	call os_string_to_int
  3794 0000405F A3[7C40]            <1> 	mov word [.num2], ax
  3795                              <1> 
  3796 00004062 A1[7A40]            <1> 	mov word ax, [.num1]
  3797 00004065 8B1E[7C40]          <1> 	mov word bx, [.num2]
  3798 00004069 E82FD4              <1> 	call os_get_random
  3799                              <1> 
  3800 0000406C 89CB                <1> 	mov bx, cx
  3801 0000406E 0FB606[7940]        <1> 	movzx ax, byte [.tmp]
  3802 00004073 E8CA04              <1> 	call set_var
  3803                              <1> 
  3804 00004076 E966ED              <1> 	jmp mainloop
  3805                              <1> 
  3806                              <1> 
  3807 00004079 00                  <1> 	.tmp	db 0
  3808 0000407A 0000                <1> 	.num1	dw 0
  3809 0000407C 0000                <1> 	.num2	dw 0
  3810                              <1> 
  3811                              <1> 
  3812                              <1> .error:
  3813 0000407E BE1400              <1> 	mov si, err_syntax
  3814 00004081 E9E405              <1> 	jmp error
  3815                              <1> 
  3816                              <1> 
  3817                              <1> ; ------------------------------------------------------------------
  3818                              <1> ; READ
  3819                              <1> 
  3820                              <1> do_read:
  3821 00004084 E8C804              <1> 	call get_token				; Get the next token
  3822                              <1> 
  3823 00004087 83F804              <1> 	cmp ax, STRING				; Check for a label
  3824 0000408A 7406                <1> 	je .is_ok
  3825                              <1> 
  3826 0000408C BE0500              <1> 	mov si, err_goto_notlabel
  3827 0000408F E9D605              <1> 	jmp error
  3828                              <1> 
  3829                              <1> .is_ok:
  3830 00004092 BE007B              <1> 	mov si, token				; Back up this label
  3831 00004095 BFE27A              <1> 	mov di, .tmp_token
  3832 00004098 E894EA              <1> 	call os_string_copy
  3833                              <1> 
  3834 0000409B B8E27A              <1> 	mov ax, .tmp_token
  3835 0000409E E8FBE9              <1> 	call os_string_length
  3836                              <1> 
  3837 000040A1 BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3838 000040A4 01C7                <1> 	add di, ax
  3839 000040A6 B03A                <1> 	mov al, ':'
  3840 000040A8 AA                  <1> 	stosb
  3841 000040A9 B000                <1> 	mov al, 0
  3842 000040AB AA                  <1> 	stosb
  3843                              <1> 
  3844 000040AC E8A004              <1> 	call get_token				; Now get the offset variable
  3845 000040AF 83F801              <1> 	cmp ax, VARIABLE
  3846 000040B2 7406                <1> 	je .second_part_is_var
  3847                              <1> 
  3848 000040B4 BE1400              <1> 	mov si, err_syntax
  3849 000040B7 E9AE05              <1> 	jmp error
  3850                              <1> 
  3851                              <1> 
  3852                              <1> .second_part_is_var:
  3853 000040BA 0FB606007B          <1> 	movzx ax, byte [token]
  3854 000040BF E87104              <1> 	call get_var
  3855                              <1> 
  3856 000040C2 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3857 000040C5 7F06                <1> 	jg .var_bigger_than_zero
  3858                              <1> 
  3859 000040C7 BE1400              <1> 	mov si, err_syntax
  3860 000040CA E99B05              <1> 	jmp error
  3861                              <1> 
  3862                              <1> 
  3863                              <1> .var_bigger_than_zero:
  3864 000040CD A3[5741]            <1> 	mov word [.to_skip], ax
  3865                              <1> 
  3866                              <1> 
  3867 000040D0 E87C04              <1> 	call get_token				; And now the var to store result into
  3868 000040D3 83F801              <1> 	cmp ax, VARIABLE
  3869 000040D6 7406                <1> 	je .third_part_is_var
  3870                              <1> 
  3871 000040D8 BE1400              <1> 	mov si, err_syntax
  3872 000040DB E98A05              <1> 	jmp error
  3873                              <1> 
  3874                              <1> 
  3875                              <1> .third_part_is_var:				; Keep it for later
  3876 000040DE 0FB606007B          <1> 	movzx ax, byte [token]
  3877 000040E3 A2[5941]            <1> 	mov byte [.var_to_use], al
  3878                              <1> 
  3879                              <1> 
  3880                              <1> 
  3881                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3882                              <1> 
  3883 000040E6 A1[D346]            <1> 	mov word ax, [prog]			; Store current location
  3884 000040E9 A3[5541]            <1> 	mov word [.curr_location], ax
  3885                              <1> 
  3886 000040EC A1[D746]            <1> 	mov word ax, [load_point]
  3887 000040EF A3[D346]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3888                              <1> 
  3889                              <1> .loop:
  3890 000040F2 E85A04              <1> 	call get_token
  3891                              <1> 
  3892 000040F5 83F808              <1> 	cmp ax, LABEL
  3893 000040F8 750B                <1> 	jne .line_loop
  3894                              <1> 
  3895 000040FA BE007B              <1> 	mov si, token
  3896 000040FD BFE27A              <1> 	mov di, .tmp_token
  3897 00004100 E88BEA              <1> 	call os_string_compare
  3898 00004103 7221                <1> 	jc .found_label
  3899                              <1> 
  3900                              <1> .line_loop:					; Go to end of line
  3901 00004105 8B36[D346]          <1> 	mov word si, [prog]
  3902 00004109 8A04                <1> 	mov byte al, [si]
  3903 0000410B FF06[D346]          <1> 	inc word [prog]
  3904                              <1> 
  3905 0000410F 3C0A                <1> 	cmp al, 10
  3906 00004111 75F2                <1> 	jne .line_loop
  3907                              <1> 
  3908 00004113 A1[D346]            <1> 	mov word ax, [prog]
  3909 00004116 8B1E[D546]          <1> 	mov word bx, [prog_end]
  3910 0000411A 39D8                <1> 	cmp ax, bx
  3911 0000411C 7F02                <1> 	jg .past_end
  3912                              <1> 
  3913 0000411E EBD2                <1> 	jmp .loop
  3914                              <1> 
  3915                              <1> .past_end:
  3916 00004120 BE0600              <1> 	mov si, err_label_notfound
  3917 00004123 E94205              <1> 	jmp error
  3918                              <1> 
  3919                              <1> 
  3920                              <1> .found_label:
  3921 00004126 8B0E[5741]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3922                              <1> 
  3923                              <1> .data_skip_loop:
  3924 0000412A 51                  <1> 	push cx
  3925 0000412B E82104              <1> 	call get_token
  3926 0000412E 59                  <1> 	pop cx
  3927 0000412F E2F9                <1> 	loop .data_skip_loop
  3928                              <1> 
  3929 00004131 83F803              <1> 	cmp ax, NUMBER
  3930 00004134 7406                <1> 	je .data_is_num
  3931                              <1> 
  3932 00004136 BE1400              <1> 	mov si, err_syntax
  3933 00004139 E92C05              <1> 	jmp error
  3934                              <1> 
  3935                              <1> .data_is_num:
  3936 0000413C BE007B              <1> 	mov si, token
  3937 0000413F E8A0EA              <1> 	call os_string_to_int
  3938                              <1> 
  3939 00004142 89C3                <1> 	mov bx, ax
  3940 00004144 0FB606[5941]        <1> 	movzx ax, byte [.var_to_use]
  3941 00004149 E8F403              <1> 	call set_var
  3942                              <1> 
  3943 0000414C A1[5541]            <1> 	mov word ax, [.curr_location]
  3944 0000414F A3[D346]            <1> 	mov word [prog], ax
  3945                              <1> 
  3946 00004152 E98AEC              <1> 	jmp mainloop
  3947                              <1> 
  3948                              <1> 
  3949 00004155 0000                <1> 	.curr_location	dw 0
  3950                              <1> 
  3951 00004157 0000                <1> 	.to_skip	dw 0
  3952 00004159 00                  <1> 	.var_to_use	db 0
  3953                              <1> ;	.tmp_token 	times 30 db 0
  3954                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3955                              <1> 
  3956                              <1> 
  3957                              <1> ; ------------------------------------------------------------------
  3958                              <1> ; REM
  3959                              <1> 
  3960                              <1> do_rem:
  3961 0000415A 8B36[D346]          <1> 	mov word si, [prog]
  3962 0000415E 8A04                <1> 	mov byte al, [si]
  3963 00004160 FF06[D346]          <1> 	inc word [prog]
  3964 00004164 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3965 00004166 75F2                <1> 	jne do_rem
  3966                              <1> 
  3967 00004168 E974EC              <1> 	jmp mainloop
  3968                              <1> 
  3969                              <1> 
  3970                              <1> ; ------------------------------------------------------------------
  3971                              <1> ; RENAME
  3972                              <1> 
  3973                              <1> do_rename:
  3974 0000416B E8E103              <1> 	call get_token
  3975                              <1> 
  3976 0000416E 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3977 00004171 7407                <1> 	je .first_is_string
  3978                              <1> 
  3979 00004173 83F805              <1> 	cmp ax, QUOTE
  3980 00004176 740E                <1> 	je .first_is_quote
  3981                              <1> 
  3982 00004178 EB61                <1> 	jmp .error
  3983                              <1> 
  3984                              <1> .first_is_string:
  3985 0000417A BE007C              <1> 	mov si, string_vars		; Locate string
  3986 0000417D B88000              <1> 	mov ax, 128
  3987 00004180 F7E3                <1> 	mul bx
  3988 00004182 01C6                <1> 	add si, ax
  3989                              <1> 
  3990 00004184 EB03                <1> 	jmp .save_file1
  3991                              <1> 
  3992                              <1> .first_is_quote:
  3993 00004186 BE007B              <1> 	mov si, token			; The location of quotes is provided
  3994                              <1> 
  3995                              <1> .save_file1:
  3996 00004189 BF[0842]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3997 0000418C E8A0E9              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3998                              <1> 	
  3999                              <1> .get_second:
  4000 0000418F E8BD03              <1> 	call get_token
  4001                              <1> 
  4002 00004192 83F802              <1> 	cmp ax, STRING_VAR
  4003 00004195 7407                <1> 	je .second_is_string
  4004                              <1> 
  4005 00004197 83F805              <1> 	cmp ax, QUOTE
  4006 0000419A 740E                <1> 	je .second_is_quote
  4007                              <1> 
  4008 0000419C EB3D                <1> 	jmp .error
  4009                              <1> 
  4010                              <1> .second_is_string:
  4011 0000419E BE007C              <1> 	mov si, string_vars		; Locate second string
  4012 000041A1 B88000              <1> 	mov ax, 128
  4013 000041A4 F7E3                <1> 	mul bx
  4014 000041A6 01C6                <1> 	add si, ax
  4015                              <1> 
  4016 000041A8 EB03                <1> 	jmp .save_file2
  4017                              <1> 
  4018                              <1> .second_is_quote:
  4019 000041AA BE007B              <1> 	mov si, token
  4020                              <1> 
  4021                              <1> .save_file2:
  4022 000041AD BF[1442]            <1> 	mov word di, .file2
  4023 000041B0 E87CE9              <1> 	call os_string_copy
  4024                              <1> 	
  4025                              <1> .check_exists:
  4026 000041B3 B8[0842]            <1> 	mov word ax, .file1		; Check if the source file exists
  4027 000041B6 E8D5CD              <1> 	call os_file_exists
  4028 000041B9 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  4029                              <1> 
  4030 000041BB F8                  <1> 	clc
  4031 000041BC B8[1442]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  4032 000041BF E8CCCD              <1> 	call os_file_exists
  4033 000041C2 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  4034                              <1> 	
  4035                              <1> .rename:
  4036 000041C4 B8[0842]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  4037 000041C7 BB[1442]            <1> 	mov word bx, .file2
  4038 000041CA E842CF              <1> 	call os_rename_file
  4039                              <1> 
  4040 000041CD 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  4041                              <1> 
  4042 000041CF 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  4043 000041D1 B052                <1> 	mov byte al, 'R'
  4044 000041D3 31DB                <1> 	xor bx, bx
  4045 000041D5 E86803              <1> 	call set_var
  4046                              <1> 
  4047 000041D8 E904EC              <1> 	jmp mainloop
  4048                              <1> 
  4049                              <1> .error:
  4050 000041DB BE1400              <1> 	mov si, err_syntax
  4051 000041DE E98704              <1> 	jmp error
  4052                              <1> 
  4053                              <1> .file_not_found:
  4054 000041E1 31C0                <1> 	xor ax, ax			; Set R variable to 1
  4055 000041E3 B052                <1> 	mov byte al, 'R'
  4056 000041E5 BB0100              <1> 	mov bx, 1
  4057 000041E8 E85503              <1> 	call set_var
  4058                              <1> 
  4059 000041EB E9F1EB              <1> 	jmp mainloop
  4060                              <1> 
  4061                              <1> .rename_failed:
  4062 000041EE 31C0                <1> 	xor ax, ax			; Set R variable to 2
  4063 000041F0 B052                <1> 	mov byte al, 'R'
  4064 000041F2 BB0200              <1> 	mov bx, 2
  4065 000041F5 E84803              <1> 	call set_var
  4066                              <1> 
  4067 000041F8 E9E4EB              <1> 	jmp mainloop
  4068                              <1> 
  4069                              <1> .file_exists:
  4070 000041FB 31C0                <1> 	xor ax, ax
  4071 000041FD B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  4072 000041FF BB0300              <1> 	mov bx, 3
  4073 00004202 E83B03              <1> 	call set_var
  4074                              <1> 
  4075 00004205 E9D7EB              <1> 	jmp mainloop
  4076                              <1> 
  4077                              <1> .data:
  4078 00004208 00<rep Ch>          <1> 	.file1				times 12 db 0
  4079 00004214 00<rep Ch>          <1> 	.file2				times 12 db 0
  4080                              <1> 
  4081                              <1> 
  4082                              <1> ; ------------------------------------------------------------------
  4083                              <1> ; RETURN
  4084                              <1> 
  4085                              <1> do_return:
  4086 00004220 0FB606[4A48]        <1> 	movzx ax, byte [gosub_depth]
  4087 00004225 3C00                <1> 	cmp al, 0
  4088 00004227 7506                <1> 	jne .is_ok
  4089                              <1> 
  4090 00004229 BE1200              <1> 	mov si, err_return
  4091 0000422C E93904              <1> 	jmp error
  4092                              <1> 
  4093                              <1> .is_ok:
  4094 0000422F BEBC79              <1> 	mov si, gosub_points
  4095 00004232 01C6                <1> 	add si, ax				; Table is words (not bytes)
  4096 00004234 01C6                <1> 	add si, ax
  4097 00004236 AD                  <1> 	lodsw
  4098 00004237 A3[D346]            <1> 	mov word [prog], ax
  4099 0000423A FE0E[4A48]          <1> 	dec byte [gosub_depth]
  4100                              <1> 
  4101 0000423E E99EEB              <1> 	jmp mainloop	
  4102                              <1> 
  4103                              <1> 
  4104                              <1> ; ------------------------------------------------------------------
  4105                              <1> ; SAVE
  4106                              <1> 
  4107                              <1> do_save:
  4108 00004241 E80B03              <1> 	call get_token
  4109 00004244 83F805              <1> 	cmp ax, QUOTE
  4110 00004247 7413                <1> 	je .is_quote
  4111                              <1> 
  4112 00004249 83F802              <1> 	cmp ax, STRING_VAR
  4113 0000424C 0F859500            <1> 	jne near .error
  4114                              <1> 
  4115 00004250 BE007C              <1> 	mov si, string_vars
  4116 00004253 B88000              <1> 	mov ax, 128
  4117 00004256 F7E3                <1> 	mul bx
  4118 00004258 01C6                <1> 	add si, ax
  4119 0000425A EB03                <1> 	jmp .get_position
  4120                              <1> 
  4121                              <1> .is_quote:
  4122 0000425C BE007B              <1> 	mov si, token
  4123                              <1> 
  4124                              <1> .get_position:
  4125 0000425F BF[F142]            <1> 	mov di, .tmp_filename
  4126 00004262 E8CAE8              <1> 	call os_string_copy
  4127                              <1> 
  4128 00004265 E8E702              <1> 	call get_token
  4129                              <1> 
  4130 00004268 83F801              <1> 	cmp ax, VARIABLE
  4131 0000426B 744A                <1> 	je .second_is_var
  4132                              <1> 
  4133 0000426D 83F803              <1> 	cmp ax, NUMBER
  4134 00004270 7573                <1> 	jne .error
  4135                              <1> 
  4136 00004272 BE007B              <1> 	mov si, token
  4137 00004275 E86AE9              <1> 	call os_string_to_int
  4138                              <1> 
  4139                              <1> .set_data_loc:
  4140 00004278 A3[ED42]            <1> 	mov word [.data_loc], ax
  4141                              <1> 
  4142 0000427B E8D102              <1> 	call get_token
  4143                              <1> 
  4144 0000427E 83F801              <1> 	cmp ax, VARIABLE
  4145 00004281 743E                <1> 	je .third_is_var
  4146                              <1> 
  4147 00004283 83F803              <1> 	cmp ax, NUMBER
  4148 00004286 755D                <1> 	jne .error
  4149                              <1> 
  4150 00004288 BE007B              <1> 	mov si, token
  4151 0000428B E854E9              <1> 	call os_string_to_int
  4152                              <1> 
  4153                              <1> .check_exists:
  4154 0000428E A3[EF42]            <1> 	mov word [.data_size], ax
  4155 00004291 B8[F142]            <1> 	mov word ax, .tmp_filename
  4156 00004294 E8F7CC              <1> 	call os_file_exists
  4157 00004297 7202                <1> 	jc .write_file
  4158 00004299 EB30                <1> 	jmp .file_exists_fail
  4159                              <1> 	
  4160                              <1> .write_file:
  4161                              <1> 
  4162 0000429B B8[F142]            <1> 	mov word ax, .tmp_filename
  4163 0000429E 8B1E[ED42]          <1> 	mov word bx, [.data_loc]
  4164 000042A2 8B0E[EF42]          <1> 	mov word cx, [.data_size]
  4165                              <1> 	
  4166 000042A6 E803CB              <1> 	call os_write_file
  4167 000042A9 722D                <1> 	jc .save_failure
  4168                              <1> 
  4169 000042AB 31C0                <1> 	xor ax, ax
  4170 000042AD B052                <1> 	mov byte al, 'R'
  4171 000042AF 31DB                <1> 	xor bx, bx
  4172 000042B1 E88C02              <1> 	call set_var
  4173                              <1> 
  4174 000042B4 E928EB              <1> 	jmp mainloop
  4175                              <1> 
  4176                              <1> 
  4177                              <1> .second_is_var:
  4178 000042B7 0FB606007B          <1> 	movzx ax, byte [token]
  4179 000042BC E87402              <1> 	call get_var
  4180 000042BF EBB7                <1> 	jmp .set_data_loc
  4181                              <1> 
  4182                              <1> 
  4183                              <1> .third_is_var:
  4184 000042C1 0FB606007B          <1> 	movzx ax, byte [token]
  4185 000042C6 E86A02              <1> 	call get_var
  4186 000042C9 EBC3                <1> 	jmp .check_exists
  4187                              <1> 
  4188                              <1> .file_exists_fail:
  4189 000042CB 31C0                <1> 	xor ax, ax
  4190 000042CD B052                <1> 	mov byte al, 'R'
  4191 000042CF BB0200              <1> 	mov bx, 2
  4192 000042D2 E86B02              <1> 	call set_var
  4193 000042D5 E907EB              <1> 	jmp mainloop
  4194                              <1> 	
  4195                              <1> .save_failure:
  4196 000042D8 31C0                <1> 	xor ax, ax
  4197 000042DA B052                <1> 	mov byte al, 'R'
  4198 000042DC BB0100              <1> 	mov bx, 1
  4199 000042DF E85E02              <1> 	call set_var
  4200                              <1> 
  4201 000042E2 E9FAEA              <1> 	jmp mainloop
  4202                              <1> 
  4203                              <1> .error:
  4204 000042E5 BE1400              <1> 	mov si, err_syntax
  4205 000042E8 E97D03              <1> 	jmp error
  4206                              <1> 
  4207                              <1> 
  4208 000042EB 0000                <1> 	.filename_loc	dw 0
  4209 000042ED 0000                <1> 	.data_loc	dw 0
  4210 000042EF 0000                <1> 	.data_size	dw 0
  4211                              <1> 
  4212 000042F1 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  4213                              <1> 
  4214                              <1> 
  4215                              <1> ; ------------------------------------------------------------------
  4216                              <1> ; SERIAL
  4217                              <1> 
  4218                              <1> do_serial:
  4219 00004300 E84C02              <1> 	call get_token
  4220 00004303 BE007B              <1> 	mov si, token
  4221                              <1> 
  4222 00004306 BF[9843]            <1> 	mov di, .on_cmd
  4223 00004309 E882E8              <1> 	call os_string_compare
  4224 0000430C 7212                <1> 	jc .do_on_cmd
  4225                              <1> 
  4226 0000430E BF[9B43]            <1> 	mov di, .send_cmd
  4227 00004311 E87AE8              <1> 	call os_string_compare
  4228 00004314 7237                <1> 	jc .do_send_cmd
  4229                              <1> 
  4230 00004316 BF[A043]            <1> 	mov di, .rec_cmd
  4231 00004319 E872E8              <1> 	call os_string_compare
  4232 0000431C 7258                <1> 	jc .do_rec_cmd
  4233                              <1> 
  4234 0000431E EB72                <1> 	jmp .error
  4235                              <1> 
  4236                              <1> .do_on_cmd:
  4237 00004320 E82C02              <1> 	call get_token
  4238 00004323 83F803              <1> 	cmp ax, NUMBER
  4239 00004326 7402                <1> 	je .do_on_cmd_ok
  4240 00004328 EB68                <1> 	jmp .error
  4241                              <1> 
  4242                              <1> .do_on_cmd_ok:
  4243 0000432A BE007B              <1> 	mov si, token
  4244 0000432D E8B2E8              <1> 	call os_string_to_int
  4245 00004330 3DB004              <1> 	cmp ax, 1200
  4246 00004333 740F                <1> 	je .on_cmd_slow_mode
  4247 00004335 3D8025              <1> 	cmp ax, 9600
  4248 00004338 7402                <1> 	je .on_cmd_fast_mode
  4249                              <1> 
  4250 0000433A EB56                <1> 	jmp .error
  4251                              <1> 
  4252                              <1> .on_cmd_fast_mode:
  4253 0000433C 31C0                <1> 	xor ax, ax
  4254 0000433E E82AD5              <1> 	call os_serial_port_enable
  4255 00004341 E99BEA              <1> 	jmp mainloop
  4256                              <1> 
  4257                              <1> .on_cmd_slow_mode:
  4258 00004344 B80100              <1> 	mov ax, 1
  4259 00004347 E821D5              <1> 	call os_serial_port_enable
  4260 0000434A E992EA              <1> 	jmp mainloop
  4261                              <1> 
  4262                              <1> 
  4263                              <1> .do_send_cmd:
  4264 0000434D E8FF01              <1> 	call get_token
  4265 00004350 83F803              <1> 	cmp ax, NUMBER
  4266 00004353 7407                <1> 	je .send_number
  4267                              <1> 
  4268 00004355 83F801              <1> 	cmp ax, VARIABLE
  4269 00004358 740E                <1> 	je .send_variable
  4270                              <1> 
  4271 0000435A EB36                <1> 	jmp .error
  4272                              <1> 
  4273                              <1> .send_number:
  4274 0000435C BE007B              <1> 	mov si, token
  4275 0000435F E880E8              <1> 	call os_string_to_int
  4276 00004362 E81AD5              <1> 	call os_send_via_serial
  4277 00004365 E977EA              <1> 	jmp mainloop
  4278                              <1> 
  4279                              <1> .send_variable:
  4280 00004368 0FB606007B          <1> 	movzx ax, byte [token]
  4281 0000436D E8C301              <1> 	call get_var
  4282 00004370 E80CD5              <1> 	call os_send_via_serial
  4283 00004373 E969EA              <1> 	jmp mainloop
  4284                              <1> 
  4285                              <1> 
  4286                              <1> .do_rec_cmd:
  4287 00004376 E8D601              <1> 	call get_token
  4288 00004379 83F801              <1> 	cmp ax, VARIABLE
  4289 0000437C 7514                <1> 	jne .error
  4290                              <1> 
  4291 0000437E A0007B              <1> 	mov byte al, [token]
  4292                              <1> 
  4293 00004381 0FB6C8              <1> 	movzx cx, al
  4294 00004384 E80AD5              <1> 	call os_get_via_serial
  4295                              <1> 
  4296 00004387 0FB6D8              <1> 	movzx bx, al
  4297 0000438A 88C8                <1> 	mov al, cl
  4298 0000438C E8B101              <1> 	call set_var
  4299                              <1> 
  4300 0000438F E94DEA              <1> 	jmp mainloop
  4301                              <1> 
  4302                              <1> 
  4303                              <1> .error:
  4304 00004392 BE1400              <1> 	mov si, err_syntax
  4305 00004395 E9D002              <1> 	jmp error
  4306                              <1> 
  4307                              <1> 
  4308 00004398 4F4E00              <1> 	.on_cmd		db "ON", 0
  4309 0000439B 53454E4400          <1> 	.send_cmd	db "SEND", 0
  4310 000043A0 52454300            <1> 	.rec_cmd	db "REC", 0
  4311                              <1> 
  4312                              <1> 
  4313                              <1> ; ------------------------------------------------------------------
  4314                              <1> ; SIZE
  4315                              <1> 
  4316                              <1> do_size:
  4317 000043A4 E8A801              <1> 	call get_token
  4318                              <1> 
  4319 000043A7 83F802              <1> 	cmp ax, STRING_VAR
  4320 000043AA 7407                <1> 	je .is_string
  4321                              <1> 
  4322 000043AC 83F805              <1> 	cmp ax, QUOTE
  4323 000043AF 7410                <1> 	je .is_quote
  4324                              <1> 
  4325 000043B1 EB29                <1> 	jmp .error
  4326                              <1> 
  4327                              <1> .is_string:
  4328 000043B3 BE007C              <1> 	mov si, string_vars
  4329 000043B6 B88000              <1> 	mov ax, 128
  4330 000043B9 F7E3                <1> 	mul bx
  4331 000043BB 01C6                <1> 	add si, ax
  4332                              <1> 
  4333 000043BD 89F0                <1> 	mov ax, si
  4334 000043BF EB03                <1> 	jmp .get_size
  4335                              <1> 
  4336                              <1> .is_quote:
  4337 000043C1 B8007B              <1> 	mov ax, token
  4338                              <1> 
  4339                              <1> .get_size:
  4340 000043C4 E87DCD              <1> 	call os_get_file_size
  4341 000043C7 7219                <1> 	jc .file_not_found
  4342                              <1> 
  4343 000043C9 31C0                <1> 	xor ax, ax
  4344 000043CB B053                <1> 	mov al, 'S'
  4345 000043CD E87001              <1> 	call set_var
  4346                              <1> 
  4347 000043D0 31C0                <1> 	xor ax, ax
  4348 000043D2 B052                <1> 	mov al, 'R'
  4349 000043D4 31DB                <1> 	xor bx, bx
  4350 000043D6 E86701              <1> 	call set_var
  4351                              <1> 
  4352 000043D9 E903EA              <1> 	jmp mainloop
  4353                              <1> 
  4354                              <1> .error:
  4355 000043DC BE1400              <1> 	mov si, err_syntax
  4356 000043DF E98602              <1> 	jmp error
  4357                              <1> 
  4358                              <1> .file_not_found:
  4359 000043E2 0FB606007B          <1> 	movzx ax, byte [token]
  4360 000043E7 89DB                <1> 	mov bx, bx
  4361 000043E9 E85401              <1> 	call set_var
  4362                              <1> 
  4363 000043EC 31C0                <1> 	xor ax, ax
  4364 000043EE B052                <1> 	mov al, 'R'
  4365 000043F0 BB0100              <1> 	mov bx, 1
  4366 000043F3 E84A01              <1>  	call set_var
  4367                              <1>  	
  4368 000043F6 E9E6E9              <1> 	jmp mainloop
  4369                              <1> 
  4370                              <1> 
  4371                              <1> 
  4372                              <1> ; ------------------------------------------------------------------
  4373                              <1> ; SOUND
  4374                              <1> 
  4375                              <1> do_sound:
  4376 000043F9 E85301              <1> 	call get_token
  4377                              <1> 
  4378 000043FC 83F801              <1> 	cmp ax, VARIABLE
  4379 000043FF 7408                <1> 	je .first_is_var
  4380                              <1> 
  4381 00004401 BE007B              <1> 	mov si, token
  4382 00004404 E8DBE7              <1> 	call os_string_to_int
  4383 00004407 EB08                <1> 	jmp .done_first
  4384                              <1> 
  4385                              <1> .first_is_var:
  4386 00004409 0FB606007B          <1> 	movzx ax, byte [token]
  4387 0000440E E82201              <1> 	call get_var
  4388                              <1> 
  4389                              <1> .done_first:
  4390 00004411 E8FFE2              <1> 	call os_speaker_tone
  4391                              <1> 
  4392 00004414 E83801              <1> 	call get_token
  4393                              <1> 
  4394 00004417 83F801              <1> 	cmp ax, VARIABLE
  4395 0000441A 7408                <1> 	je .second_is_var
  4396                              <1> 
  4397 0000441C BE007B              <1> 	mov si, token
  4398 0000441F E8C0E7              <1> 	call os_string_to_int
  4399 00004422 EB08                <1> 	jmp .finish
  4400                              <1> 
  4401                              <1> .second_is_var:
  4402 00004424 0FB606007B          <1> 	movzx ax, byte [token]
  4403 00004429 E80701              <1> 	call get_var
  4404                              <1> 
  4405                              <1> .finish:
  4406 0000442C E85AD1              <1> 	call os_pause
  4407 0000442F E821E3              <1> 	call os_speaker_off
  4408                              <1> 
  4409 00004432 E9AAE9              <1> 	jmp mainloop
  4410                              <1> 
  4411                              <1> 
  4412                              <1> ;-------------------------------------------------------------------
  4413                              <1> ; STRING
  4414                              <1> do_string:
  4415 00004435 E81701              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  4416 00004438 BE007B              <1> 	mov si, token
  4417                              <1> 	
  4418 0000443B BF[DF44]            <1> 	mov di, .get_cmd
  4419 0000443E E84DE7              <1> 	call os_string_compare
  4420 00004441 720B                <1> 	jc .set_str
  4421                              <1> 		
  4422 00004443 BF[E344]            <1> 	mov di, .set_cmd
  4423 00004446 E845E7              <1> 	call os_string_compare
  4424 00004449 7208                <1> 	jc .get_str
  4425                              <1> 	
  4426 0000444B E98500              <1> 	jmp .error
  4427                              <1> 	
  4428                              <1> 	.set_str:
  4429 0000444E B90100              <1> 	mov cx, 1
  4430 00004451 EB03                <1> 	jmp .check_second
  4431                              <1> 	.get_str:
  4432 00004453 B90200              <1> 	mov cx, 2
  4433                              <1> 
  4434                              <1> .check_second:
  4435 00004456 E8F600              <1> 	call get_token			; The next should be a string variable, locate it
  4436                              <1> 	
  4437 00004459 83F802              <1> 	cmp ax, STRING_VAR
  4438 0000445C 7575                <1> 	jne .error
  4439                              <1> 	
  4440 0000445E BE007C              <1> 	mov si, string_vars
  4441 00004461 B88000              <1> 	mov ax, 128
  4442 00004464 F7E3                <1> 	mul bx
  4443 00004466 01C6                <1> 	add si, ax
  4444 00004468 8936[E744]          <1> 	mov word [.string_loc], si
  4445                              <1> 	
  4446                              <1> .check_third:
  4447 0000446C E8E000              <1> 	call get_token			; Now there should be a number
  4448                              <1> 	
  4449 0000446F 83F803              <1> 	cmp ax, NUMBER
  4450 00004472 7407                <1> 	je .third_is_number
  4451                              <1> 	
  4452 00004474 83F801              <1> 	cmp ax, VARIABLE
  4453 00004477 740A                <1> 	je .third_is_variable
  4454                              <1> 	
  4455 00004479 EB58                <1> 	jmp .error
  4456                              <1> 	
  4457                              <1> .third_is_number:	
  4458 0000447B BE007B              <1> 	mov si, token
  4459 0000447E E861E7              <1> 	call os_string_to_int
  4460 00004481 EB0A                <1> 	jmp .got_number	
  4461                              <1> 
  4462                              <1> .third_is_variable:
  4463 00004483 B400                <1> 	mov ah, 0
  4464 00004485 A0007B              <1> 	mov al, [token]
  4465 00004488 E8A800              <1> 	call get_var
  4466 0000448B EB00                <1> 	jmp .got_number
  4467                              <1> 
  4468                              <1> .got_number:
  4469 0000448D 3D8000              <1> 	cmp ax, 128
  4470 00004490 7F47                <1> 	jg .outrange
  4471 00004492 83F800              <1> 	cmp ax, 0
  4472 00004495 7442                <1> 	je .outrange
  4473 00004497 83E801              <1> 	sub ax, 1
  4474 0000449A 89C2                <1> 	mov dx, ax
  4475                              <1> 	
  4476                              <1> .check_forth:
  4477 0000449C E8B000              <1> 	call get_token			; Next a numerical variable
  4478                              <1> 	
  4479 0000449F 83F801              <1> 	cmp ax, VARIABLE
  4480 000044A2 752F                <1> 	jne .error
  4481                              <1> 	
  4482 000044A4 A0007B              <1> 	mov byte al, [token]
  4483 000044A7 A2[E944]            <1> 	mov byte [.tmp], al
  4484                              <1> 	
  4485 000044AA 83F902              <1> 	cmp cx, 2
  4486 000044AD 7414                <1> 	je .set_var
  4487                              <1> 	
  4488                              <1> .get_var:
  4489 000044AF 8B36[E744]          <1> 	mov word si, [.string_loc]	; Move to string location
  4490 000044B3 01D6                <1> 	add si, dx			; Add offset
  4491 000044B5 AC                  <1> 	lodsb				; Load data
  4492 000044B6 B400                <1> 	mov ah, 0
  4493 000044B8 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  4494 000044BA A0[E944]            <1> 	mov byte al, [.tmp]
  4495 000044BD E88000              <1> 	call set_var
  4496 000044C0 E91CE9              <1> 	jmp mainloop
  4497                              <1> 	
  4498                              <1> .set_var:
  4499 000044C3 A0[E944]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  4500 000044C6 E86A00              <1> 	call get_var			; Get it's value
  4501 000044C9 8B3E[E744]          <1> 	mov di, [.string_loc]		; Locate the string
  4502 000044CD 01D7                <1> 	add di, dx			; Add the offset
  4503 000044CF AA                  <1> 	stosb				; Store data
  4504 000044D0 E90CE9              <1> 	jmp mainloop
  4505                              <1> 	
  4506                              <1> .error:
  4507 000044D3 BE1400              <1> 	mov si, err_syntax
  4508 000044D6 E98F01              <1> 	jmp error
  4509                              <1> 	
  4510                              <1> .outrange:
  4511 000044D9 BE1300              <1> 	mov si, err_string_range
  4512 000044DC E98901              <1> 	jmp error
  4513                              <1> 
  4514                              <1> .data:
  4515 000044DF 47455400            <1> 	.get_cmd		db "GET", 0
  4516 000044E3 53455400            <1> 	.set_cmd		db "SET", 0
  4517 000044E7 0000                <1> 	.string_loc		dw 0
  4518 000044E9 00                  <1> 	.tmp			db 0
  4519                              <1> 
  4520                              <1> 
  4521                              <1> 
  4522                              <1> ; ------------------------------------------------------------------
  4523                              <1> ; WAITKEY
  4524                              <1> 
  4525                              <1> do_waitkey:
  4526 000044EA E86200              <1> 	call get_token
  4527 000044ED 83F801              <1> 	cmp ax, VARIABLE
  4528 000044F0 7406                <1> 	je .is_variable
  4529                              <1> 
  4530 000044F2 BE1400              <1> 	mov si, err_syntax
  4531 000044F5 E97001              <1> 	jmp error
  4532                              <1> 
  4533                              <1> .is_variable:
  4534 000044F8 0FB606007B          <1> 	movzx ax, byte [token]
  4535                              <1> 
  4536 000044FD 50                  <1> 	push ax
  4537                              <1> 
  4538 000044FE E836CE              <1> 	call os_wait_for_key
  4539                              <1> 
  4540 00004501 80FC48              <1> 	cmp ah, 48h
  4541 00004504 7419                <1> 	je .up_pressed
  4542                              <1> 	
  4543 00004506 80FC50              <1> 	cmp ah, 50h
  4544 00004509 7419                <1> 	je .down_pressed
  4545                              <1> 
  4546 0000450B 80FC4B              <1> 	cmp ah, 4Bh
  4547 0000450E 7419                <1> 	je .left_pressed
  4548                              <1> 
  4549 00004510 80FC4D              <1> 	cmp ah, 4Dh
  4550 00004513 7419                <1> 	je .right_pressed
  4551                              <1> 
  4552                              <1> .store:
  4553 00004515 0FB6D8              <1> 	movzx bx, al
  4554                              <1> 
  4555 00004518 58                  <1> 	pop ax
  4556                              <1> 
  4557 00004519 E82400              <1> 	call set_var
  4558                              <1> 
  4559 0000451C E9C0E8              <1> 	jmp mainloop
  4560                              <1> 
  4561                              <1> 
  4562                              <1> .up_pressed:
  4563 0000451F B80100              <1> 	mov ax, 1
  4564 00004522 EBF1                <1> 	jmp .store
  4565                              <1> 
  4566                              <1> .down_pressed:
  4567 00004524 B80200              <1> 	mov ax, 2
  4568 00004527 EBEC                <1> 	jmp .store
  4569                              <1> 
  4570                              <1> .left_pressed:
  4571 00004529 B80300              <1> 	mov ax, 3
  4572 0000452C EBE7                <1> 	jmp .store
  4573                              <1> 
  4574                              <1> .right_pressed:
  4575 0000452E B80400              <1> 	mov ax, 4
  4576 00004531 EBE2                <1> 	jmp .store
  4577                              <1> 
  4578                              <1> 
  4579                              <1> ; ==================================================================
  4580                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  4581                              <1> 
  4582                              <1> ; ------------------------------------------------------------------
  4583                              <1> ; Get value of variable character specified in AL (eg 'A')
  4584                              <1> 
  4585                              <1> get_var:
  4586 00004533 B400                <1> 	mov ah, 0
  4587 00004535 2C41                <1> 	sub al, 65
  4588 00004537 BE4C7A              <1> 	mov si, variables
  4589 0000453A 01C6                <1> 	add si, ax
  4590 0000453C 01C6                <1> 	add si, ax
  4591 0000453E AD                  <1> 	lodsw
  4592 0000453F C3                  <1> 	ret
  4593                              <1> 
  4594                              <1> 
  4595                              <1> ; ------------------------------------------------------------------
  4596                              <1> ; Set value of variable character specified in AL (eg 'A')
  4597                              <1> ; with number specified in BX
  4598                              <1> 
  4599                              <1> set_var:
  4600 00004540 B400                <1> 	mov ah, 0
  4601 00004542 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  4602                              <1> 
  4603 00004544 BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  4604 00004547 01C7                <1> 	add di, ax
  4605 00004549 01C7                <1> 	add di, ax
  4606 0000454B 89D8                <1> 	mov ax, bx
  4607 0000454D AB                  <1> 	stosw
  4608 0000454E C3                  <1> 	ret
  4609                              <1> 
  4610                              <1> 
  4611                              <1> ; ------------------------------------------------------------------
  4612                              <1> ; Get token from current position in prog
  4613                              <1> 
  4614                              <1> get_token:
  4615 0000454F 8B36[D346]          <1> 	mov word si, [prog]
  4616 00004553 AC                  <1> 	lodsb
  4617                              <1> 
  4618 00004554 3C0A                <1> 	cmp al, 10
  4619 00004556 741A                <1> 	je .newline
  4620                              <1> 
  4621 00004558 3C20                <1> 	cmp al, ' '
  4622 0000455A 7416                <1> 	je .newline
  4623                              <1> 
  4624 0000455C E8F100              <1> 	call is_number
  4625 0000455F 7217                <1> 	jc get_number_token
  4626                              <1> 
  4627 00004561 3C22                <1> 	cmp al, '"'
  4628 00004563 745F                <1> 	je get_quote_token
  4629                              <1> 
  4630 00004565 3C27                <1> 	cmp al, 39			; Quote mark (')
  4631 00004567 7438                <1> 	je get_char_token
  4632                              <1> 
  4633 00004569 3C24                <1> 	cmp al, '$'
  4634 0000456B 0F848000            <1> 	je near get_string_var_token
  4635                              <1> 
  4636 0000456F E99000              <1> 	jmp get_string_token
  4637                              <1> 
  4638                              <1> 
  4639                              <1> .newline:
  4640 00004572 FF06[D346]          <1> 	inc word [prog]
  4641 00004576 EBD7                <1> 	jmp get_token
  4642                              <1> 
  4643                              <1> 
  4644                              <1> 
  4645                              <1> get_number_token:
  4646 00004578 8B36[D346]          <1> 	mov word si, [prog]
  4647 0000457C BF007B              <1> 	mov di, token
  4648                              <1> 
  4649                              <1> .loop:
  4650 0000457F AC                  <1> 	lodsb
  4651 00004580 3C0A                <1> 	cmp al, 10
  4652 00004582 7416                <1> 	je .done
  4653 00004584 3C20                <1> 	cmp al, ' '
  4654 00004586 7412                <1> 	je .done
  4655 00004588 E8C500              <1> 	call is_number
  4656 0000458B 7206                <1> 	jc .fine
  4657                              <1> 
  4658 0000458D BE0000              <1> 	mov si, err_char_in_num
  4659 00004590 E9D500              <1> 	jmp error
  4660                              <1> 
  4661                              <1> .fine:
  4662 00004593 AA                  <1> 	stosb
  4663 00004594 FF06[D346]          <1> 	inc word [prog]
  4664 00004598 EBE5                <1> 	jmp .loop
  4665                              <1> 
  4666                              <1> .done:
  4667 0000459A B000                <1> 	mov al, 0			; Zero-terminate the token
  4668 0000459C AA                  <1> 	stosb
  4669                              <1> 
  4670 0000459D B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  4671 000045A0 C3                  <1> 	ret
  4672                              <1> 
  4673                              <1> 
  4674                              <1> get_char_token:
  4675 000045A1 FF06[D346]          <1> 	inc word [prog]			; Move past first quote (')
  4676                              <1> 
  4677 000045A5 8B36[D346]          <1> 	mov word si, [prog]
  4678 000045A9 AC                  <1> 	lodsb
  4679                              <1> 
  4680 000045AA A2007B              <1> 	mov byte [token], al
  4681                              <1> 
  4682 000045AD AC                  <1> 	lodsb
  4683 000045AE 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  4684 000045B0 7406                <1> 	je .is_ok
  4685                              <1> 
  4686 000045B2 BE1100              <1> 	mov si, err_quote_term
  4687 000045B5 E9B000              <1> 	jmp error
  4688                              <1> 
  4689                              <1> .is_ok:
  4690 000045B8 FF06[D346]          <1> 	inc word [prog]
  4691 000045BC FF06[D346]          <1> 	inc word [prog]
  4692                              <1> 
  4693 000045C0 B80600              <1> 	mov ax, CHAR
  4694 000045C3 C3                  <1> 	ret
  4695                              <1> 
  4696                              <1> 
  4697                              <1> get_quote_token:
  4698 000045C4 FF06[D346]          <1> 	inc word [prog]			; Move past first quote (") char
  4699 000045C8 8B36[D346]          <1> 	mov word si, [prog]
  4700 000045CC BF007B              <1> 	mov di, token
  4701                              <1> .loop:
  4702 000045CF AC                  <1> 	lodsb
  4703 000045D0 3C22                <1> 	cmp al, '"'
  4704 000045D2 740B                <1> 	je .done
  4705 000045D4 3C0A                <1> 	cmp al, 10
  4706 000045D6 7412                <1> 	je .error
  4707 000045D8 AA                  <1> 	stosb
  4708 000045D9 FF06[D346]          <1> 	inc word [prog]
  4709 000045DD EBF0                <1> 	jmp .loop
  4710                              <1> 
  4711                              <1> .done:
  4712 000045DF B000                <1> 	mov al, 0			; Zero-terminate the token
  4713 000045E1 AA                  <1> 	stosb
  4714 000045E2 FF06[D346]          <1> 	inc word [prog]			; Move past final quote
  4715                              <1> 
  4716 000045E6 B80500              <1> 	mov ax, QUOTE			; Pass back token type
  4717 000045E9 C3                  <1> 	ret
  4718                              <1> 
  4719                              <1> .error:
  4720 000045EA BE1100              <1> 	mov si, err_quote_term
  4721 000045ED EB79                <1> 	jmp error
  4722                              <1> 
  4723                              <1> 
  4724                              <1> get_string_var_token:
  4725 000045EF AC                  <1> 	lodsb
  4726 000045F0 0FB6D8              <1> 	movzx bx, al
  4727 000045F3 80EB31              <1> 	sub bl, 49
  4728                              <1> 
  4729 000045F6 FF06[D346]          <1> 	inc word [prog]
  4730 000045FA FF06[D346]          <1> 	inc word [prog]
  4731                              <1> 
  4732 000045FE B80200              <1> 	mov ax, STRING_VAR
  4733 00004601 C3                  <1> 	ret
  4734                              <1> 	
  4735                              <1> 
  4736                              <1> get_string_token:
  4737 00004602 8B36[D346]          <1> 	mov word si, [prog]
  4738 00004606 BF007B              <1> 	mov di, token
  4739                              <1> .loop:
  4740 00004609 AC                  <1> 	lodsb
  4741 0000460A 3C0A                <1> 	cmp al, 10
  4742 0000460C 740B                <1> 	je .done
  4743 0000460E 3C20                <1> 	cmp al, ' '
  4744 00004610 7407                <1> 	je .done
  4745 00004612 AA                  <1> 	stosb
  4746 00004613 FF06[D346]          <1> 	inc word [prog]
  4747 00004617 EBF0                <1> 	jmp .loop
  4748                              <1> .done:
  4749 00004619 B000                <1> 	mov al, 0			; Zero-terminate the token
  4750 0000461B AA                  <1> 	stosb
  4751                              <1> 
  4752 0000461C B8007B              <1> 	mov ax, token
  4753 0000461F E8D3E4              <1> 	call os_string_uppercase
  4754                              <1> 
  4755 00004622 B8007B              <1> 	mov ax, token
  4756 00004625 E874E4              <1> 	call os_string_length		; How long was the token?
  4757 00004628 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4758 0000462B 7413                <1> 	je .is_not_string
  4759                              <1> 
  4760 0000462D BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4761 00004630 01C6                <1> 	add si, ax
  4762 00004632 4E                  <1> 	dec si
  4763 00004633 AC                  <1> 	lodsb
  4764 00004634 3C3A                <1> 	cmp al, ':'
  4765 00004636 7404                <1> 	je .is_label
  4766                              <1> 
  4767 00004638 B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4768 0000463B C3                  <1> 	ret
  4769                              <1> 
  4770                              <1> .is_label:
  4771 0000463C B80800              <1> 	mov ax, LABEL
  4772 0000463F C3                  <1> 	ret
  4773                              <1> 
  4774                              <1> 
  4775                              <1> .is_not_string:
  4776 00004640 A0007B              <1> 	mov byte al, [token]
  4777 00004643 E81600              <1> 	call is_letter
  4778 00004646 7204                <1> 	jc .is_var
  4779                              <1> 
  4780 00004648 B80700              <1> 	mov ax, UNKNOWN
  4781 0000464B C3                  <1> 	ret
  4782                              <1> 
  4783                              <1> .is_var:
  4784 0000464C B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4785 0000464F C3                  <1> 	ret
  4786                              <1> 
  4787                              <1> 
  4788                              <1> ; ------------------------------------------------------------------
  4789                              <1> ; Set carry flag if AL contains ASCII number
  4790                              <1> 
  4791                              <1> is_number:
  4792 00004650 3C30                <1> 	cmp al, 48
  4793 00004652 7C06                <1> 	jl .not_number
  4794 00004654 3C39                <1> 	cmp al, 57
  4795 00004656 7F02                <1> 	jg .not_number
  4796 00004658 F9                  <1> 	stc
  4797 00004659 C3                  <1> 	ret
  4798                              <1> .not_number:
  4799 0000465A F8                  <1> 	clc
  4800 0000465B C3                  <1> 	ret
  4801                              <1> 
  4802                              <1> 
  4803                              <1> ; ------------------------------------------------------------------
  4804                              <1> ; Set carry flag if AL contains ASCII letter
  4805                              <1> 
  4806                              <1> is_letter:
  4807 0000465C 3C41                <1> 	cmp al, 65
  4808 0000465E 7C06                <1> 	jl .not_letter
  4809 00004660 3C5A                <1> 	cmp al, 90
  4810 00004662 7F02                <1> 	jg .not_letter
  4811 00004664 F9                  <1> 	stc
  4812 00004665 C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> .not_letter:
  4815 00004666 F8                  <1> 	clc
  4816 00004667 C3                  <1> 	ret
  4817                              <1> 
  4818                              <1> 
  4819                              <1> ; ------------------------------------------------------------------
  4820                              <1> ; Print error message and quit out
  4821                              <1> 
  4822                              <1> error:
  4823 00004668 B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4824 0000466B CD10                <1> 	int 10h
  4825                              <1> 
  4826 0000466D E8A4D9              <1> 	call os_print_newline
  4827 00004670 BE[B446]            <1> 	mov si, err_msg
  4828 00004673 E840D2              <1> 	call os_print_string
  4829                              <1> 	
  4830 00004676 88D8                <1> 	mov al, bl
  4831 00004678 E8EDDB              <1> 	call os_print_2hex
  4832                              <1> 	
  4833 0000467B C606[DD46]00        <1> 	mov byte [work_page], 0
  4834 00004680 C606[DE46]00        <1> 	mov byte [disp_page], 0
  4835                              <1> 
  4836 00004685 BE[C846]            <1> 	mov si, line_num_starter
  4837 00004688 E82BD2              <1> 	call os_print_string
  4838                              <1> 
  4839                              <1> 
  4840                              <1> 	; And now print the line number where the error occurred. We do this
  4841                              <1> 	; by working from the start of the program to the current point,
  4842                              <1> 	; counting the number of newline characters along the way
  4843                              <1> 
  4844 0000468B 8B36[D746]          <1> 	mov word si, [load_point]
  4845 0000468F 8B1E[D346]          <1> 	mov word bx, [prog]
  4846 00004693 B90100              <1> 	mov cx, 1
  4847                              <1> 
  4848                              <1> .loop:
  4849 00004696 AC                  <1> 	lodsb
  4850 00004697 3C0A                <1> 	cmp al, 10
  4851 00004699 7501                <1> 	jne .not_newline
  4852 0000469B 41                  <1> 	inc cx
  4853                              <1> .not_newline:
  4854 0000469C 39DE                <1> 	cmp si, bx
  4855 0000469E 7402                <1> 	je .finish
  4856 000046A0 EBF4                <1> 	jmp .loop
  4857                              <1> .finish:
  4858                              <1> 
  4859 000046A2 89C8                <1> 	mov ax, cx
  4860 000046A4 E886E5              <1> 	call os_int_to_string
  4861 000046A7 89C6                <1> 	mov si, ax
  4862 000046A9 E80AD2              <1> 	call os_print_string
  4863                              <1> 
  4864                              <1> 
  4865 000046AC E865D9              <1> 	call os_print_newline
  4866                              <1> 
  4867 000046AF 8B26[D146]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4868                              <1> 
  4869 000046B3 C3                  <1> 	ret				; And finish
  4870                              <1> 
  4871                              <1> 
  4872                              <1> 	; Error messages text...
  4873                              <1> 
  4874                              <1> 	err_char_in_num		equ 00h
  4875                              <1> 	err_cmd_unknown		equ 01h
  4876                              <1> 	err_divide_by_zero	equ 02h
  4877                              <1> 	err_doloop_maximum	equ 03h
  4878                              <1> 	err_file_notfound	equ 04h
  4879                              <1> 	err_goto_notlabel	equ 05h
  4880                              <1> 	err_label_notfound	equ 06h
  4881                              <1> 	err_nest_limit		equ 07h
  4882                              <1> 	err_next			equ 08h
  4883                              <1> 	err_loop			equ 09h
  4884                              <1> 	err_print_type		equ 10h
  4885                              <1> 	err_quote_term		equ 11h
  4886                              <1> 	err_return			equ 12h
  4887                              <1> 	err_string_range	equ 13h
  4888                              <1> 	err_syntax			equ 14h
  4889                              <1> 
  4890 000046B4 4572726F722000      <1> 	err_msg				db "Error ", 0
  4891                              <1> 
  4892 000046BB 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4892 000046C4 4C454400            <1>
  4893                              <1> 
  4894 000046C8 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4895                              <1> 
  4896                              <1> 
  4897                              <1> ; ==================================================================
  4898                              <1> ; DATA SECTION
  4899                              <1> 
  4900 000046D1 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4901                              <1> 
  4902 000046D3 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4903 000046D5 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4904                              <1> 
  4905 000046D7 0000                <1> 	load_point		dw 0
  4906                              <1> 
  4907 000046D9 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4908                              <1> 	token			equ 32768-1024-256
  4909                              <1> 
  4910                              <1> vars_loc:
  4911                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4912                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4913                              <1> 
  4914                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4915                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4916                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4917                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4918                              <1> 	
  4919                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4920                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4921 000046DA 00                  <1> 	loop_in			db 0		; Loop level
  4922                              <1> 
  4923 000046DB 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4924                              <1> 
  4925 000046DC 00                  <1> 	ink_colour		db 0		; Text printing colour
  4926 000046DD 00                  <1> 	work_page		db 0		; Page to print to
  4927 000046DE 00                  <1> 	disp_page		db 0		; Page to display
  4928                              <1> 	
  4929 000046DF 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4930 000046E5 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4931 000046ED 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4932 000046F3 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4933 000046F8 4341534500          <1> 	case_cmd			db "CASE", 0
  4934 000046FD 434C5300            <1> 	cls_cmd				db "CLS", 0
  4935 00004701 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4936 00004708 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4937 00004711 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4938 00004719 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4939 00004721 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4940 00004728 444F00              <1> 	do_cmd				db "DO", 0
  4941 0000472B 454C534500          <1> 	else_cmd			db "ELSE", 0
  4942 00004730 454E4400            <1> 	end_cmd				db "END", 0
  4943 00004734 46494C455300        <1> 	files_cmd			db "FILES", 0
  4944 0000473A 464F5200            <1> 	for_cmd 			db "FOR", 0
  4945 0000473E 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4946 00004744 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4947 00004749 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4948 00004750 494600              <1> 	if_cmd 				db "IF", 0
  4949 00004753 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4950 0000475B 494E4B00            <1> 	ink_cmd				db "INK", 0
  4951 0000475F 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4952 00004765 4C454E00            <1> 	len_cmd				db "LEN", 0
  4953 00004769 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4954 00004771 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4955 00004776 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4956 0000477B 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4957 00004780 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4958 00004785 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4959 0000478C 5041474500          <1> 	page_cmd			db "PAGE", 0
  4960 00004791 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4961 00004797 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4962 0000479C 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4963 000047A4 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4964 000047A9 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4965 000047B1 504F525400          <1> 	port_cmd			db "PORT", 0
  4966 000047B6 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4967 000047BC 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4968 000047C1 5245414400          <1> 	read_cmd			db "READ", 0
  4969 000047C6 52454D00            <1> 	rem_cmd				db "REM", 0
  4970 000047CA 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4971 000047D1 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4972 000047D8 5341564500          <1> 	save_cmd			db "SAVE", 0
  4973 000047DD 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4974 000047E4 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4975 000047E9 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4976 000047EF 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4977 000047F6 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4978                              <1> 
  4979 000047FE 414E4400            <1> 	and_keyword			db "AND", 0
  4980 00004802 5448454E00          <1> 	then_keyword		db "THEN", 0
  4981 00004807 43485200            <1> 	chr_keyword			db "CHR", 0
  4982 0000480B 48455800            <1> 	hex_keyword			db "HEX", 0
  4983                              <1> 	
  4984 0000480F 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4985 00004815 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4986                              <1> 
  4987 0000481B 494E4B00            <1> 	ink_keyword			db "INK", 0
  4988 0000481F 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4988 00004828 00                  <1>
  4989 00004829 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4990 00004832 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4991 00004838 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4991 00004841 00                  <1>
  4992 00004842 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4993                              <1> 
  4994 0000484A 00                  <1> 	gosub_depth		db 0
  4995                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4996                              <1> 
  4997                              <1> 	string_vars		equ 32768-1024
  4998                              <1> 
  4999                              <1> ; ------------------------------------------------------------------
  5000                              <1> 
   823                                  	%INCLUDE "features/int.asm"
   824                              <1> ; -----------------------------------------------------------------
   825                              <1> ; os_modify_int_handler -- Change location of interrupt handler
   826                              <1> ; IN: CL = int number, DI:SI = handler location
   827                              <1> 
   828                              <1> os_modify_int_handler:
   829 0000484B 60                  <1> 	pusha
   830                              <1> 
   831 0000484C FA                  <1> 	cli
   832                              <1> 
   833 0000484D 06                  <1> 	push es
   834                              <1> 	
   835 0000484E 8E06[9405]          <1> 	mov es, [driversgmt]
   836                              <1> 	
   837 00004852 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   838                              <1> 
   839 00004855 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   840                              <1> 	
   841 00004858 268937              <1> 	mov [es:bx], si		; First store offset
   842                              <1> 
   843 0000485B 83C302              <1> 	add bx, 2
   844                              <1> 	
   845 0000485E 26893F              <1> 	mov [es:bx], di		; Then segment of our handler
   846                              <1> 
   847 00004861 07                  <1> 	pop es
   848                              <1> 	
   849 00004862 FB                  <1> 	sti
   850                              <1> 
   851 00004863 61                  <1> 	popa
   852 00004864 C3                  <1> 	ret
   853                              <1> 
   854                              <1> ; -----------------------------------------------------------------
   855                              <1> ; os_get_int_handler -- Change location of interrupt handler
   856                              <1> ; IN: CL = int number; OUT: DI:SI = handler location
   857                              <1> 
   858                              <1> os_get_int_handler:
   859 00004865 60                  <1> 	pusha
   860                              <1> 
   861 00004866 1E                  <1> 	push ds
   862                              <1> 	
   863 00004867 8E1E[9405]          <1> 	mov ds, [driversgmt]
   864                              <1> 	
   865 0000486B 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   866                              <1> 
   867 0000486E C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   868                              <1> 	
   869 00004871 3E8B37              <1> 	mov si, [ds:bx]		; First store offset
   870 00004874 83C302              <1> 	add bx, 2
   871                              <1> 
   872 00004877 3E8B3F              <1> 	mov di, [ds:bx]		; Then segment of our handler
   873                              <1> 
   874 0000487A 1F                  <1> 	pop ds
   875                              <1> 
   876 0000487B 8936[8D48]          <1> 	mov [.tmp_word], si
   877 0000487F 893E[8F48]          <1> 	mov [.tmp_sgmt], di
   878 00004883 61                  <1> 	popa
   879 00004884 8B36[8D48]          <1> 	mov si, [.tmp_word]
   880 00004888 8B3E[8F48]          <1> 	mov di, [.tmp_sgmt]
   881 0000488C C3                  <1> 	ret
   882                              <1> 
   883 0000488D 0000                <1> 	.tmp_word	dw 0
   884 0000488F 0000                <1> 	.tmp_sgmt	dw 0
   885                              <1> 	
   886                              <1> ; -----------------------------------------------------------------
   887                              <1> ; os_attach_timer_interrupt -- Attach a timer interrupt to an application and sets the timer speed
   888                              <1> ; Formula: speed = (105000000 / 88) / frequency
   889                              <1> ; IN: SI = handler location, CX = speed
   890                              <1> 
   891                              <1> os_attach_app_timer:
   892 00004891 60                  <1> 	pusha
   893 00004892 8936[9A49]          <1> 	mov [timer_application_offset], si
   894 00004896 C606[9949]01        <1> 	mov byte [timer_application_attached], 1
   895                              <1> 	
   896 0000489B E81A00              <1> 	call os_set_timer_speed
   897 0000489E 61                  <1> 	popa
   898 0000489F C3                  <1> 	ret
   899                              <1> 	
   900                              <1> ; -----------------------------------------------------------------
   901                              <1> ; os_return_timer_interrupt -- Returns the timer interrupt back to the system and resets the timer speed
   902                              <1> ; IN: nothing
   903                              <1> 
   904                              <1> os_return_app_timer:
   905 000048A0 60                  <1> 	pusha
   906 000048A1 C606[9949]00        <1> 	mov byte [timer_application_attached], 0
   907                              <1> 	
   908 000048A6 B90000              <1> 	mov cx, 0
   909 000048A9 E80C00              <1> 	call os_set_timer_speed
   910                              <1> 	
   911 000048AC B11C                <1> 	mov cl, 1Ch					; RTC handler
   912 000048AE BE[6149]            <1> 	mov si, os_compat_int1C
   913 000048B1 8CCF                <1> 	mov di, cs
   914 000048B3 E895FF              <1> 	call os_modify_int_handler
   915 000048B6 61                  <1> 	popa
   916 000048B7 C3                  <1> 	ret
   917                              <1> 	
   918                              <1> ; -----------------------------------------------------------------
   919                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
   920                              <1> ; Formula: speed = (105000000 / 88) / frequency
   921                              <1> ; IN: CX = speed
   922                              <1> 
   923                              <1> os_set_timer_speed:
   924 000048B8 60                  <1> 	pusha
   925                              <1> 	
   926 000048B9 890E[9C49]          <1> 	mov [current_timer_speed], cx
   927                              <1> 	
   928 000048BD B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   929 000048BF E643                <1> 	out 43h, al
   930 000048C1 88C8                <1> 	mov al, cl
   931 000048C3 E640                <1> 	out 40h, al
   932 000048C5 88E8                <1> 	mov al, ch
   933 000048C7 E640                <1> 	out 40h, al
   934                              <1> 	
   935 000048C9 61                  <1> 	popa
   936 000048CA C3                  <1> 	ret
   937                              <1> 	
   938                              <1> ; -----------------------------------------------------------------
   939                              <1> ; Interrupt call parsers
   940                              <1> 
   941                              <1> ; Division by 0 error handler
   942                              <1> os_compat_int00:
   943 000048CB B8[D148]            <1> 	mov ax, .msg
   944 000048CE E98CCD              <1> 	jmp os_fatal_error
   945                              <1> 
   946 000048D1 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   946 000048DA 73696F6E206279207A- <1>
   946 000048E3 65726F206572726F72- <1>
   946 000048EC 00                  <1>
   947                              <1> 
   948                              <1> os_compat_int05:
   949 000048ED B8[F348]            <1> 	mov ax, .msg
   950 000048F0 E96ACD              <1> 	jmp os_fatal_error
   951                              <1> 
   952 000048F3 557365722074726967- <1> 	.msg db 'User triggered crash', 0
   952 000048FC 676572656420637261- <1>
   952 00004905 736800              <1>
   953                              <1> 
   954                              <1> os_compat_int0C:
   955 00004908 FA                  <1> 	cli
   956 00004909 BCFEFF              <1> 	mov sp, 0FFFEh
   957 0000490C FB                  <1> 	sti
   958                              <1> 	
   959 0000490D B8[1349]            <1> 	mov ax, .msg
   960 00004910 E94ACD              <1> 	jmp os_fatal_error
   961                              <1> 	
   962 00004913 537461636B206F7665- <1> 	.msg db 'Stack overflow', 0
   962 0000491C 72666C6F7700        <1>
   963                              <1> 	
   964                              <1> ; Invalid opcode handler
   965                              <1> os_compat_int06:
   966 00004922 B8[2849]            <1> 	mov ax, .msg
   967 00004925 E935CD              <1> 	jmp os_fatal_error
   968                              <1> 
   969 00004928 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   969 00004931 6C6964206F70636F64- <1>
   969 0000493A 6500                <1>
   970                              <1> 
   971                              <1> ; Processor extension error handler
   972                              <1> os_compat_int07:
   973 0000493C B8[4249]            <1> 	mov ax, .msg
   974 0000493F E91BCD              <1> 	jmp os_fatal_error
   975                              <1> 
   976 00004942 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   976 0000494B 6573736F7220657874- <1>
   976 00004954 656E73696F6E206572- <1>
   976 0000495D 726F7200            <1>
   977                              <1> 
   978                              <1> ; System timer handler (8253/8254)
   979                              <1> os_compat_int1C:
   980 00004961 FA                  <1> 	cli
   981 00004962 6660                <1> 	pushad
   982 00004964 1E                  <1> 	push ds
   983 00004965 06                  <1> 	push es
   984                              <1> 	
   985 00004966 8CC8                <1> 	mov ax, cs
   986 00004968 8ED8                <1> 	mov ds, ax
   987 0000496A 8EC0                <1> 	mov es, ax
   988                              <1> 	
   989 0000496C 803E820001          <1> 	cmp byte [0082h], 1
   990 00004971 740E                <1> 	je .no_update
   991                              <1> 	
   992 00004973 833E[9E49]00        <1> 	cmp word [screensaver_timer], 0
   993 00004978 7404                <1> 	je .no_update_screensaver
   994                              <1> 	
   995 0000497A FF0E[9E49]          <1> 	dec word [screensaver_timer]
   996                              <1> 	
   997                              <1> .no_update_screensaver:	
   998 0000497E E886CC              <1> 	call os_update_clock
   999                              <1> 
  1000                              <1> .no_update:
  1001 00004981 2E803E[9949]01      <1> 	cmp byte [cs:timer_application_attached], 1
  1002 00004987 7406                <1> 	je .app_routine
  1003                              <1> 
  1004 00004989 07                  <1> 	pop es
  1005 0000498A 1F                  <1> 	pop ds
  1006 0000498B 6661                <1> 	popad
  1007 0000498D FB                  <1> 	sti
  1008 0000498E CF                  <1> 	iret
  1009                              <1> 
  1010                              <1> .app_routine:
  1011 0000498F 2EFF16[9A49]        <1> 	call [cs:timer_application_offset]
  1012                              <1> 	
  1013 00004994 07                  <1> 	pop es
  1014 00004995 1F                  <1> 	pop ds	
  1015 00004996 6661                <1> 	popad
  1016 00004998 CF                  <1> 	iret
  1017                              <1> 
  1018 00004999 00                  <1> 	timer_application_attached	db 0
  1019 0000499A 0000                <1> 	timer_application_offset	dw 0
  1020                              <1> 	
  1021 0000499C 0000                <1> 	current_timer_speed			dw 0
  1022                              <1> 	
  1023 0000499E 0000                <1> 	screensaver_timer			dw 0
   824                                  	%INCLUDE "features/graphics.asm"
   825                              <1> ; ==================================================================
   826                              <1> ; MichalOS Graphics functions
   827                              <1> ; ==================================================================
   828                              <1> 
   829                              <1> ; Puts a pixel on the screen.
   830                              <1> ; IN: AL = Color; BH = Page; CX = X position; DX = Y position
   831                              <1> ; OUT: nothing
   832                              <1> os_put_pixel:
   833 000049A0 60                  <1> 	pusha
   834 000049A1 B40C                <1> 	mov ah, 0Ch
   835 000049A3 CD10                <1> 	int 10h
   836 000049A5 61                  <1> 	popa
   837 000049A6 C3                  <1> 	ret
   838                              <1> 	
   839                              <1> ; Gets a pixel from the screen.
   840                              <1> ; IN: BH = Page; CX = X position; DX = Y position
   841                              <1> ; OUT: AL = Color
   842                              <1> os_get_pixel:
   843 000049A7 60                  <1> 	pusha
   844 000049A8 B40D                <1> 	mov ah, 0Dh
   845 000049AA CD10                <1> 	int 10h
   846 000049AC A2[B449]            <1> 	mov [.tmp_byte], al
   847 000049AF 61                  <1> 	popa
   848 000049B0 A0[B449]            <1> 	mov al, [.tmp_byte]
   849 000049B3 C3                  <1> 	ret
   850                              <1> 	
   851 000049B4 00                  <1> 	.tmp_byte	db 0
   852                              <1> 	
   853                              <1> ; ==================================================================
   854                              <1> ; TachyonOS -- The TachyonOS Operating System kernel
   855                              <1> ; Copyright (C) 2013 TachyonOS Developers -- see doc/LICENCE.TXT
   856                              <1> ;
   857                              <1> ; GRAPHICS ROUTINES
   858                              <1> ; ==================================================================
   859                              <1> 	
   860                              <1> os_set_pixel:
   861 000049B5 60                  <1> 	pusha
   862 000049B6 89CA                <1> 	mov dx, cx
   863 000049B8 89C1                <1> 	mov cx, ax
   864 000049BA 88D8                <1> 	mov al, bl
   865 000049BC B700                <1> 	mov bh, 0
   866 000049BE E8DFFF              <1> 	call os_put_pixel
   867 000049C1 61                  <1> 	popa
   868 000049C2 C3                  <1> 	ret
   869                              <1> 	
   870                              <1> ; Implementation of Bresenham's line algorithm. Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   871                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   872                              <1> ; OUT: None, registers preserved
   873                              <1> os_draw_line:
   874 000049C3 60                  <1> 	pusha				; Save parameters
   875                              <1> 	
   876 000049C4 31C0                <1> 	xor ax, ax			; Clear variables
   877 000049C6 BF[294B]            <1> 	mov di, .x1
   878 000049C9 B90B00              <1> 	mov cx, 11
   879 000049CC F3AB                <1> 	rep stosw
   880                              <1> 	
   881 000049CE 61                  <1> 	popa				; Restore and save parameters
   882 000049CF 60                  <1> 	pusha
   883                              <1> 	
   884 000049D0 890E[294B]          <1> 	mov [.x1], cx			; Save points
   885 000049D4 890E[314B]          <1> 	mov [.x], cx
   886 000049D8 8916[2B4B]          <1> 	mov [.y1], dx
   887 000049DC 8916[334B]          <1> 	mov [.y], dx
   888 000049E0 8936[2D4B]          <1> 	mov [.x2], si
   889 000049E4 893E[2F4B]          <1> 	mov [.y2], di
   890                              <1> 	
   891 000049E8 881E[3F4B]          <1> 	mov [.colour], bl		; Save the colour
   892                              <1> 	
   893 000049EC 8B1E[2D4B]          <1> 	mov bx, [.x2]
   894 000049F0 A1[294B]            <1> 	mov ax, [.x1]
   895 000049F3 39C3                <1> 	cmp bx, ax
   896 000049F5 7C0E                <1> 	jl .x1gtx2
   897                              <1> 	
   898 000049F7 29C3                <1> 	sub bx, ax
   899 000049F9 891E[354B]          <1> 	mov [.dx], bx
   900 000049FD B80100              <1> 	mov ax, 1
   901 00004A00 A3[394B]            <1> 	mov [.incx], ax
   902 00004A03 EB0B                <1> 	jmp .test2
   903                              <1> 	
   904                              <1> .x1gtx2:
   905 00004A05 29D8                <1> 	sub ax, bx
   906 00004A07 A3[354B]            <1> 	mov [.dx], ax
   907 00004A0A B8FFFF              <1> 	mov ax, -1
   908 00004A0D A3[394B]            <1> 	mov [.incx], ax
   909                              <1> 	
   910                              <1> .test2:
   911 00004A10 8B1E[2F4B]          <1> 	mov bx, [.y2]
   912 00004A14 A1[2B4B]            <1> 	mov ax, [.y1]
   913 00004A17 39C3                <1> 	cmp bx, ax
   914 00004A19 7C0E                <1> 	jl .y1gty2
   915                              <1> 	
   916 00004A1B 29C3                <1> 	sub bx, ax
   917 00004A1D 891E[374B]          <1> 	mov [.dy], bx
   918 00004A21 B80100              <1> 	mov ax, 1
   919 00004A24 A3[3B4B]            <1> 	mov [.incy], ax
   920 00004A27 EB0B                <1> 	jmp .test3
   921                              <1> 	
   922                              <1> .y1gty2:
   923 00004A29 29D8                <1> 	sub ax, bx
   924 00004A2B A3[374B]            <1> 	mov [.dy], ax
   925 00004A2E B8FFFF              <1> 	mov ax, -1
   926 00004A31 A3[3B4B]            <1> 	mov [.incy], ax
   927                              <1> 	
   928                              <1> .test3:
   929 00004A34 8B1E[354B]          <1> 	mov bx, [.dx]
   930 00004A38 A1[374B]            <1> 	mov ax, [.dy]
   931 00004A3B 39C3                <1> 	cmp bx, ax
   932 00004A3D 7C6E                <1> 	jl .dygtdx
   933                              <1> 	
   934 00004A3F A1[374B]            <1> 	mov ax, [.dy]
   935 00004A42 D1E0                <1> 	shl ax, 1
   936 00004A44 A3[374B]            <1> 	mov [.dy], ax
   937                              <1> 	
   938 00004A47 8B1E[354B]          <1> 	mov bx, [.dx]
   939 00004A4B 29D8                <1> 	sub ax, bx
   940 00004A4D A3[3D4B]            <1> 	mov [.balance], ax
   941                              <1> 	
   942 00004A50 D1E3                <1> 	shl bx, 1
   943 00004A52 891E[354B]          <1> 	mov [.dx], bx
   944                              <1> 	
   945                              <1> .xloop:
   946 00004A56 A1[314B]            <1> 	mov ax, [.x]
   947 00004A59 8B1E[2D4B]          <1> 	mov bx, [.x2]
   948 00004A5D 39D8                <1> 	cmp ax, bx
   949 00004A5F 0F84B600            <1> 	je .done
   950                              <1> 	
   951 00004A63 A1[314B]            <1> 	mov ax, [.x]
   952 00004A66 8B0E[334B]          <1> 	mov cx, [.y]
   953 00004A6A 8A1E[3F4B]          <1> 	mov bl, [.colour]
   954 00004A6E E844FF              <1> 	call os_set_pixel
   955                              <1> 	
   956 00004A71 31F6                <1> 	xor si, si
   957 00004A73 8B3E[3D4B]          <1> 	mov di, [.balance]
   958 00004A77 39F7                <1> 	cmp di, si
   959 00004A79 7C18                <1> 	jl .xloop1
   960                              <1> 	
   961 00004A7B A1[334B]            <1> 	mov ax, [.y]
   962 00004A7E 8B1E[3B4B]          <1> 	mov bx, [.incy]
   963 00004A82 01D8                <1> 	add ax, bx
   964 00004A84 A3[334B]            <1> 	mov [.y], ax
   965                              <1> 	
   966 00004A87 A1[3D4B]            <1> 	mov ax, [.balance]
   967 00004A8A 8B1E[354B]          <1> 	mov bx, [.dx]
   968 00004A8E 29D8                <1> 	sub ax, bx
   969 00004A90 A3[3D4B]            <1> 	mov [.balance], ax
   970                              <1> 	
   971                              <1> .xloop1:
   972 00004A93 A1[3D4B]            <1> 	mov ax, [.balance]
   973 00004A96 8B1E[374B]          <1> 	mov bx, [.dy]
   974 00004A9A 01D8                <1> 	add ax, bx
   975 00004A9C A3[3D4B]            <1> 	mov [.balance], ax
   976                              <1> 	
   977 00004A9F A1[314B]            <1> 	mov ax, [.x]
   978 00004AA2 8B1E[394B]          <1> 	mov bx, [.incx]
   979 00004AA6 01D8                <1> 	add ax, bx
   980 00004AA8 A3[314B]            <1> 	mov [.x], ax
   981                              <1> 	
   982 00004AAB EBA9                <1> 	jmp .xloop
   983                              <1> 	
   984                              <1> .dygtdx:
   985 00004AAD A1[354B]            <1> 	mov ax, [.dx]
   986 00004AB0 D1E0                <1> 	shl ax, 1
   987 00004AB2 A3[354B]            <1> 	mov [.dx], ax
   988                              <1> 	
   989 00004AB5 8B1E[374B]          <1> 	mov bx, [.dy]
   990 00004AB9 29D8                <1> 	sub ax, bx
   991 00004ABB A3[3D4B]            <1> 	mov [.balance], ax
   992                              <1> 	
   993 00004ABE D1E3                <1> 	shl bx, 1
   994 00004AC0 891E[374B]          <1> 	mov [.dy], bx
   995                              <1> 	
   996                              <1> .yloop:
   997 00004AC4 A1[334B]            <1> 	mov ax, [.y]
   998 00004AC7 8B1E[2F4B]          <1> 	mov bx, [.y2]
   999 00004ACB 39D8                <1> 	cmp ax, bx
  1000 00004ACD 744A                <1> 	je .done
  1001                              <1> 	
  1002 00004ACF A1[314B]            <1> 	mov ax, [.x]
  1003 00004AD2 8B0E[334B]          <1> 	mov cx, [.y]
  1004 00004AD6 8A1E[3F4B]          <1> 	mov bl, [.colour]
  1005 00004ADA E8D8FE              <1> 	call os_set_pixel
  1006                              <1> 	
  1007 00004ADD 31F6                <1> 	xor si, si
  1008 00004ADF 8B3E[3D4B]          <1> 	mov di, [.balance]
  1009 00004AE3 39F7                <1> 	cmp di, si
  1010 00004AE5 7C18                <1> 	jl .yloop1
  1011                              <1> 	
  1012 00004AE7 A1[314B]            <1> 	mov ax, [.x]
  1013 00004AEA 8B1E[394B]          <1> 	mov bx, [.incx]
  1014 00004AEE 01D8                <1> 	add ax, bx
  1015 00004AF0 A3[314B]            <1> 	mov [.x], ax
  1016                              <1> 	
  1017 00004AF3 A1[3D4B]            <1> 	mov ax, [.balance]
  1018 00004AF6 8B1E[374B]          <1> 	mov bx, [.dy]
  1019 00004AFA 29D8                <1> 	sub ax, bx
  1020 00004AFC A3[3D4B]            <1> 	mov [.balance], ax
  1021                              <1> 	
  1022                              <1> .yloop1:
  1023 00004AFF A1[3D4B]            <1> 	mov ax, [.balance]
  1024 00004B02 8B1E[354B]          <1> 	mov bx, [.dx]
  1025 00004B06 01D8                <1> 	add ax, bx
  1026 00004B08 A3[3D4B]            <1> 	mov [.balance], ax
  1027                              <1> 	
  1028 00004B0B A1[334B]            <1> 	mov ax, [.y]
  1029 00004B0E 8B1E[3B4B]          <1> 	mov bx, [.incy]
  1030 00004B12 01D8                <1> 	add ax, bx
  1031 00004B14 A3[334B]            <1> 	mov [.y], ax
  1032                              <1> 	
  1033 00004B17 EBAB                <1> 	jmp .yloop
  1034                              <1> 	
  1035                              <1> .done:
  1036 00004B19 A1[314B]            <1> 	mov ax, [.x]
  1037 00004B1C 8B0E[334B]          <1> 	mov cx, [.y]
  1038 00004B20 8A1E[3F4B]          <1> 	mov bl, [.colour]
  1039 00004B24 E88EFE              <1> 	call os_set_pixel
  1040                              <1> 	
  1041 00004B27 61                  <1> 	popa
  1042 00004B28 C3                  <1> 	ret
  1043                              <1> 	
  1044                              <1> 	
  1045 00004B29 0000                <1> 	.x1 dw 0
  1046 00004B2B 0000                <1> 	.y1 dw 0
  1047 00004B2D 0000                <1> 	.x2 dw 0
  1048 00004B2F 0000                <1> 	.y2 dw 0
  1049                              <1> 	
  1050 00004B31 0000                <1> 	.x dw 0
  1051 00004B33 0000                <1> 	.y dw 0
  1052 00004B35 0000                <1> 	.dx dw 0
  1053 00004B37 0000                <1> 	.dy dw 0
  1054 00004B39 0000                <1> 	.incx dw 0
  1055 00004B3B 0000                <1> 	.incy dw 0
  1056 00004B3D 0000                <1> 	.balance dw 0
  1057 00004B3F 00                  <1> 	.colour db 0
  1058 00004B40 00                  <1> 	.pad db 0
  1059                              <1> 	
  1060                              <1> ; Draw (straight) rectangle
  1061                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
  1062                              <1> ; OUT: None, registers preserved
  1063                              <1> os_draw_rectangle:
  1064 00004B41 60                  <1> 	pusha
  1065 00004B42 9C                  <1> 	pushf
  1066                              <1> 	
  1067 00004B43 890E[CD4B]          <1> 	mov word [.x1], cx
  1068 00004B47 8916[D14B]          <1> 	mov word [.y1], dx
  1069 00004B4B 8936[CF4B]          <1> 	mov word [.x2], si
  1070 00004B4F 893E[D34B]          <1> 	mov word [.y2], di
  1071                              <1> 	
  1072 00004B53 9D                  <1> 	popf
  1073 00004B54 7302                <1> 	jnc .draw_line
  1074                              <1> 
  1075 00004B56 EB4E                <1> 	jmp .fill_shape
  1076                              <1> 	
  1077                              <1> .draw_line:
  1078                              <1> 	; top line
  1079 00004B58 8B0E[CD4B]          <1> 	mov cx, [.x1]
  1080 00004B5C 8B16[D14B]          <1> 	mov dx, [.y1]
  1081 00004B60 8B36[CF4B]          <1> 	mov si, [.x2]
  1082 00004B64 8B3E[D14B]          <1> 	mov di, [.y1]
  1083 00004B68 E858FE              <1> 	call os_draw_line
  1084                              <1> 	
  1085                              <1> 	; left line
  1086 00004B6B 8B0E[CD4B]          <1> 	mov cx, [.x1]
  1087 00004B6F 8B16[D14B]          <1> 	mov dx, [.y1]
  1088 00004B73 8B36[CD4B]          <1> 	mov si, [.x1]
  1089 00004B77 8B3E[D34B]          <1> 	mov di, [.y2]
  1090 00004B7B E845FE              <1> 	call os_draw_line
  1091                              <1> 	
  1092                              <1> 	; right line
  1093 00004B7E 8B0E[CF4B]          <1> 	mov cx, [.x2]
  1094 00004B82 8B16[D14B]          <1> 	mov dx, [.y1]
  1095 00004B86 8B36[CF4B]          <1> 	mov si, [.x2]
  1096 00004B8A 8B3E[D34B]          <1> 	mov di, [.y2]
  1097 00004B8E E832FE              <1> 	call os_draw_line
  1098                              <1> 
  1099                              <1> 	; bottom line
  1100 00004B91 8B0E[CD4B]          <1> 	mov cx, [.x1]
  1101 00004B95 8B16[D34B]          <1> 	mov dx, [.y2]
  1102 00004B99 8B36[CF4B]          <1> 	mov si, [.x2]
  1103 00004B9D 8B3E[D34B]          <1> 	mov di, [.y2]
  1104 00004BA1 E81FFE              <1> 	call os_draw_line
  1105                              <1> 		
  1106 00004BA4 EB25                <1> 	jmp .finished_fill
  1107                              <1> 		
  1108                              <1> .fill_shape:
  1109 00004BA6 88D8                <1> 	mov al, bl
  1110                              <1> 
  1111 00004BA8 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
  1112 00004BAA 7C02                <1> 	jl .x_good
  1113 00004BAC 87CE                <1> 	xchg cx, si		; If not, exchange them
  1114                              <1> .x_good:
  1115 00004BAE 39FA                <1> 	cmp dx, di		; Is Y1 smaller than Y2?
  1116 00004BB0 7C02                <1> 	jl .y_good
  1117 00004BB2 87D7                <1> 	xchg dx, di		; If not, exchange them
  1118                              <1> .y_good:
  1119 00004BB4 890E[CD4B]          <1> 	mov [.x1], cx
  1120 00004BB8 B700                <1> 	mov bh, 0
  1121                              <1> .x_loop:
  1122 00004BBA E8E3FD              <1> 	call os_put_pixel
  1123 00004BBD 41                  <1> 	inc cx
  1124                              <1> 	
  1125 00004BBE 39F1                <1> 	cmp cx, si
  1126 00004BC0 7CF8                <1> 	jl .x_loop
  1127                              <1> 	
  1128 00004BC2 42                  <1> 	inc dx
  1129 00004BC3 8B0E[CD4B]          <1> 	mov cx, [.x1]
  1130                              <1> 	
  1131 00004BC7 39FA                <1> 	cmp dx, di
  1132 00004BC9 7CEF                <1> 	jl .x_loop
  1133                              <1> 		
  1134                              <1> .finished_fill:
  1135 00004BCB 61                  <1> 	popa
  1136 00004BCC C3                  <1> 	ret
  1137                              <1> 	
  1138 00004BCD 0000                <1> 	.x1				dw 0
  1139 00004BCF 0000                <1> 	.x2				dw 0
  1140 00004BD1 0000                <1> 	.y1				dw 0
  1141 00004BD3 0000                <1> 	.y2				dw 0
  1142                              <1> 
  1143                              <1> ; Draw freeform shape
  1144                              <1> ; IN: BH = number of points, BL = colour, SI = location of shape points data
  1145                              <1> ; OUT: None, registers preserved
  1146                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
  1147                              <1> os_draw_polygon:
  1148 00004BD5 60                  <1> 	pusha
  1149                              <1> 	
  1150 00004BD6 FECF                <1> 	dec bh
  1151 00004BD8 883E[434C]          <1> 	mov byte [.points], bh
  1152                              <1> 	
  1153 00004BDC 648B04              <1> 	mov word ax, [fs:si]
  1154 00004BDF 83C602              <1> 	add si, 2
  1155 00004BE2 A3[3B4C]            <1> 	mov word [.xi], ax
  1156 00004BE5 A3[3F4C]            <1> 	mov word [.xl], ax
  1157                              <1> 	
  1158 00004BE8 648B04              <1> 	mov word ax, [fs:si]
  1159 00004BEB 83C602              <1> 	add si, 2
  1160 00004BEE A3[3D4C]            <1> 	mov word [.yi], ax
  1161 00004BF1 A3[414C]            <1> 	mov word [.yl], ax
  1162                              <1> 	
  1163                              <1> 	.draw_points:
  1164 00004BF4 8B0E[3F4C]          <1> 		mov cx, [.xl]
  1165 00004BF8 8B16[414C]          <1> 		mov dx, [.yl]
  1166                              <1> 		
  1167 00004BFC 648B04              <1> 		mov word ax, [fs:si]
  1168 00004BFF 83C602              <1> 		add si, 2
  1169 00004C02 A3[3F4C]            <1> 		mov word [.xl], ax
  1170                              <1> 		
  1171 00004C05 648B04              <1> 		mov word ax, [fs:si]
  1172 00004C08 83C602              <1> 		add si, 2
  1173 00004C0B A3[414C]            <1> 		mov word [.yl], ax
  1174                              <1> 		
  1175 00004C0E 56                  <1> 		push si
  1176                              <1> 		
  1177 00004C0F 8B36[3F4C]          <1> 		mov si, [.xl]
  1178 00004C13 8B3E[414C]          <1> 		mov di, [.yl]
  1179                              <1> 		
  1180 00004C17 E8A9FD              <1> 		call os_draw_line
  1181                              <1> 		
  1182 00004C1A 5E                  <1> 		pop si
  1183                              <1> 		
  1184 00004C1B FE0E[434C]          <1> 		dec byte [.points]
  1185 00004C1F 803E[434C]00        <1> 		cmp byte [.points], 0
  1186 00004C24 75CE                <1> 		jne .draw_points
  1187                              <1> 		
  1188 00004C26 8B0E[3F4C]          <1> 	mov cx, [.xl]
  1189 00004C2A 8B16[414C]          <1> 	mov dx, [.yl]
  1190 00004C2E 8B36[3B4C]          <1> 	mov si, [.xi]
  1191 00004C32 8B3E[3D4C]          <1> 	mov di, [.yi]
  1192 00004C36 E88AFD              <1> 	call os_draw_line
  1193                              <1> 	
  1194 00004C39 61                  <1> 	popa
  1195 00004C3A C3                  <1> 	ret
  1196                              <1> 	
  1197 00004C3B 0000                <1> 	.xi				dw 0
  1198 00004C3D 0000                <1> 	.yi				dw 0
  1199 00004C3F 0000                <1> 	.xl				dw 0
  1200 00004C41 0000                <1> 	.yl				dw 0
  1201 00004C43 00                  <1> 	.points				db 0
  1202                              <1> 	
  1203                              <1> 
  1204                              <1> ; Clear the screen by setting all pixels to a single colour
  1205                              <1> ; BL = colour to set
  1206                              <1> os_clear_graphics:
  1207 00004C44 60                  <1> 	pusha
  1208 00004C45 06                  <1> 	push es
  1209                              <1> 	
  1210 00004C46 B800A0              <1> 	mov ax, 0xA000
  1211 00004C49 8EC0                <1> 	mov es, ax
  1212                              <1> 
  1213 00004C4B 88D8                <1> 	mov al, bl
  1214 00004C4D BF0000              <1> 	mov di, 0
  1215 00004C50 B900FA              <1> 	mov cx, 64000
  1216 00004C53 F3AA                <1> 	rep stosb
  1217                              <1> 
  1218 00004C55 07                  <1> 	pop es
  1219 00004C56 61                  <1> 	popa
  1220 00004C57 C3                  <1> 	ret
  1221                              <1> 	
  1222                              <1> 	
  1223                              <1> ; ----------------------------------------
  1224                              <1> ; os_draw_circle -- draw a circular shape
  1225                              <1> ; IN: AL = colour, BX = radius, CX = middle X, DX = middle y
  1226                              <1> 
  1227                              <1> os_draw_circle:
  1228 00004C58 60                  <1> 	pusha
  1229 00004C59 A2[1A4D]            <1> 	mov [.colour], al
  1230 00004C5C 891E[1F4D]          <1> 	mov [.radius], bx
  1231 00004C60 890E[1B4D]          <1> 	mov [.x0], cx
  1232 00004C64 8916[1D4D]          <1> 	mov [.y0], dx
  1233                              <1> 
  1234 00004C68 891E[214D]          <1> 	mov [.x], bx
  1235 00004C6C C706[234D]0000      <1> 	mov word [.y], 0
  1236 00004C72 B80100              <1> 	mov ax, 1
  1237 00004C75 D1E3                <1> 	shl bx, 1
  1238 00004C77 29D8                <1> 	sub ax, bx
  1239 00004C79 A3[254D]            <1> 	mov [.xChange], ax
  1240 00004C7C C706[274D]0000      <1> 	mov word [.yChange], 0
  1241 00004C82 C706[294D]0000      <1> 	mov word [.radiusError], 0
  1242                              <1> 
  1243                              <1> .next_point:
  1244 00004C88 8B0E[214D]          <1> 	mov cx, [.x]
  1245 00004C8C 8B16[234D]          <1> 	mov dx, [.y]
  1246 00004C90 39D1                <1> 	cmp cx, dx
  1247 00004C92 0F8C8200            <1> 	jl .finish
  1248                              <1> 
  1249                              <1> 	;ax bx - function points
  1250                              <1> 	;cx = x 
  1251                              <1> 	;dx = y
  1252                              <1> 	;si = -x
  1253                              <1> 	;di = -y
  1254                              <1> 
  1255 00004C96 89CE                <1> 	mov si, cx
  1256 00004C98 83F6FF              <1> 	xor si, 0xFFFF
  1257 00004C9B 46                  <1> 	inc si
  1258 00004C9C 89D7                <1> 	mov di, dx
  1259 00004C9E 83F7FF              <1> 	xor di, 0xFFFF
  1260 00004CA1 47                  <1> 	inc di
  1261                              <1> 
  1262                              <1> 	; (x + x0, y + y0)
  1263 00004CA2 89C8                <1> 	mov ax, cx
  1264 00004CA4 89D3                <1> 	mov bx, dx
  1265 00004CA6 E85B00              <1> 	call .draw_point
  1266                              <1> 
  1267                              <1> 	; (y + x0, x + y0)
  1268 00004CA9 93                  <1> 	xchg ax, bx
  1269 00004CAA E85700              <1> 	call .draw_point
  1270                              <1> 
  1271                              <1> 	; (-x + x0, y + y0)
  1272 00004CAD 89F0                <1> 	mov ax, si
  1273 00004CAF 89D3                <1> 	mov bx, dx
  1274 00004CB1 E85000              <1> 	call .draw_point
  1275                              <1> 
  1276                              <1> 	; (-y + x0, x + y0)
  1277 00004CB4 89F8                <1> 	mov ax, di
  1278 00004CB6 89CB                <1> 	mov bx, cx
  1279 00004CB8 E84900              <1> 	call .draw_point
  1280                              <1> 
  1281                              <1> 	; (-x + x0, -y + y0)
  1282 00004CBB 89F0                <1> 	mov ax, si
  1283 00004CBD 89FB                <1> 	mov bx, di
  1284 00004CBF E84200              <1> 	call .draw_point
  1285                              <1> 
  1286                              <1> 	; (-y + x0, -x + y0)
  1287 00004CC2 93                  <1> 	xchg ax, bx
  1288 00004CC3 E83E00              <1> 	call .draw_point
  1289                              <1> 
  1290                              <1> 	; (x + x0, -y + y0)
  1291 00004CC6 89C8                <1> 	mov ax, cx
  1292 00004CC8 89FB                <1> 	mov bx, di
  1293 00004CCA E83700              <1> 	call .draw_point
  1294                              <1> 
  1295                              <1> 	; (y + x0, -x + y0)
  1296 00004CCD 89D0                <1> 	mov ax, dx
  1297 00004CCF 89F3                <1> 	mov bx, si
  1298 00004CD1 E83000              <1> 	call .draw_point
  1299                              <1> 	
  1300 00004CD4 FF06[234D]          <1> 	inc word [.y]
  1301 00004CD8 A1[274D]            <1> 	mov ax, [.yChange]
  1302 00004CDB 0106[294D]          <1> 	add [.radiusError], ax
  1303 00004CDF 8306[274D]02        <1> 	add word [.yChange], 2
  1304                              <1> 	
  1305 00004CE4 A1[294D]            <1> 	mov ax, [.radiusError]
  1306 00004CE7 D1E0                <1> 	shl ax, 1
  1307 00004CE9 0306[254D]          <1> 	add ax, [.xChange]
  1308                              <1> 	
  1309 00004CED 83F800              <1> 	cmp ax, 0
  1310 00004CF0 7E96                <1> 	jle .next_point
  1311                              <1> 	
  1312 00004CF2 FF0E[214D]          <1> 	dec word [.x]
  1313 00004CF6 A1[254D]            <1> 	mov ax, [.xChange]
  1314 00004CF9 0106[294D]          <1> 	add [.radiusError], ax
  1315 00004CFD 8306[254D]02        <1> 	add word [.xChange], 2
  1316                              <1> 
  1317 00004D02 EB84                <1> 	jmp .next_point
  1318                              <1> 
  1319                              <1> .draw_point:
  1320                              <1> 	; AX = X, BX = Y
  1321 00004D04 60                  <1> 	pusha
  1322 00004D05 0306[1B4D]          <1> 	add ax, [.x0]
  1323 00004D09 031E[1D4D]          <1> 	add bx, [.y0]
  1324 00004D0D 89D9                <1> 	mov cx, bx
  1325 00004D0F 8A1E[1A4D]          <1> 	mov bl, [.colour]
  1326 00004D13 E89FFC              <1> 	call os_set_pixel
  1327 00004D16 61                  <1> 	popa
  1328 00004D17 C3                  <1> 	ret
  1329                              <1> 	
  1330                              <1> .finish:
  1331 00004D18 61                  <1> 	popa
  1332 00004D19 C3                  <1> 	ret
  1333                              <1> 	
  1334                              <1> 
  1335                              <1> 
  1336 00004D1A 00                  <1> .colour				db 0
  1337 00004D1B 0000                <1> .x0					dw 0
  1338 00004D1D 0000                <1> .y0					dw 0
  1339 00004D1F 0000                <1> .radius				dw 0
  1340 00004D21 0000                <1> .x					dw 0
  1341 00004D23 0000                <1> .y					dw 0
  1342 00004D25 0000                <1> .xChange			dw 0
  1343 00004D27 0000                <1> .yChange			dw 0
  1344 00004D29 0000                <1> .radiusError		dw 0
   825                                  	%INCLUDE "features/name.asm"
   826                              <1> ; ==================================================================
   827                              <1> ; MichalOS Name
   828                              <1> ; ==================================================================
   829                              <1> 
   830 00004D2B 4D696368616C4F5320- <1> 	osname	db 'MichalOS 3.0', 0
   830 00004D34 332E3000            <1>
   826                                  	%INCLUDE "features/shutdown.asm"
   827                              <1> ; ------------------------------------------------------------------
   828                              <1> ; MichalOS Shutdown handler
   829                              <1> ; ------------------------------------------------------------------
   830                              <1> 
   831                              <1> os_shutdown:
   832 00004D38 C606820001          <1> 	mov byte [0082h], 1
   833 00004D3D E827CC              <1> 	call os_hide_cursor
   834 00004D40 E8E000              <1> 	call .drawbackground
   835 00004D43 E87E00              <1> 	call .drawwindow
   836 00004D46 E81200              <1> 	call .selector
   837                              <1> 	
   838 00004D49 3C01                <1> 	cmp al, 1
   839 00004D4B 0F841101            <1> 	je near .shutdown
   840                              <1> 	
   841 00004D4F 3C02                <1> 	cmp al, 2
   842 00004D51 0F840601            <1> 	je near .reset
   843                              <1> 	
   844 00004D55 3C03                <1> 	cmp al, 3
   845 00004D57 0F8460B5            <1> 	je near checkformenu
   846                              <1> 	
   847                              <1> .selector:
   848 00004D5B BA1C0B              <1> 	mov dx, 11 * 256 + 28
   849 00004D5E E8C6CB              <1> 	call os_move_cursor
   850                              <1> 
   851                              <1> .selectorloop:
   852 00004D61 E87000              <1> 	call .drawcontents
   853 00004D64 E83A00              <1> 	call .invert
   854                              <1> 	
   855 00004D67 E8CDC5              <1> 	call os_wait_for_key
   856                              <1> 	
   857 00004D6A 80FC50              <1> 	cmp ah, 80
   858 00004D6D 7417                <1> 	je .selectdown
   859                              <1> 	
   860 00004D6F 80FC48              <1> 	cmp ah, 72
   861 00004D72 741D                <1> 	je .selectup
   862                              <1> 	
   863 00004D74 3C0D                <1> 	cmp al, 13
   864 00004D76 7424                <1> 	je .select
   865                              <1> 	
   866 00004D78 3C1B                <1> 	cmp al, 27
   867 00004D7A 7402                <1> 	je .return
   868                              <1> 	
   869 00004D7C EBE3                <1> 	jmp .selectorloop
   870                              <1> 
   871                              <1> .return:
   872 00004D7E B003                <1> 	mov al, 3
   873 00004D80 C606820001          <1> 	mov byte [0082h], 1
   874 00004D85 C3                  <1> 	ret
   875                              <1> 
   876                              <1> .selectdown:
   877 00004D86 80FE0D              <1> 	cmp dh, 13
   878 00004D89 0F84D4FF            <1> 	je near .selectorloop
   879 00004D8D FEC6                <1> 	inc dh
   880 00004D8F EBD0                <1> 	jmp .selectorloop
   881                              <1> 
   882                              <1> .selectup:
   883 00004D91 80FE0B              <1> 	cmp dh, 11
   884 00004D94 0F84C9FF            <1> 	je near .selectorloop
   885 00004D98 FECE                <1> 	dec dh
   886 00004D9A EBC5                <1> 	jmp .selectorloop
   887                              <1> 
   888                              <1> .select:
   889 00004D9C 88F0                <1> 	mov al, dh
   890 00004D9E 2C0A                <1> 	sub al, 10
   891 00004DA0 C3                  <1> 	ret
   892                              <1> 	
   893                              <1> .invert:
   894 00004DA1 B21C                <1> 	mov dl, 28
   895                              <1> 
   896                              <1> .invertloop:
   897 00004DA3 E881CB              <1> 	call os_move_cursor
   898 00004DA6 B408                <1> 	mov ah, 08h
   899 00004DA8 B700                <1> 	mov bh, 0
   900 00004DAA CD10                <1> 	int 10h
   901                              <1> 
   902 00004DAC BBF000              <1> 	mov bx, 240			; Black on white
   903 00004DAF B409                <1> 	mov ah, 09h
   904 00004DB1 B90100              <1> 	mov cx, 1
   905 00004DB4 CD10                <1> 	int 10h
   906                              <1> 
   907 00004DB6 FEC2                <1> 	inc dl
   908 00004DB8 80FA3C              <1> 	cmp dl, 60
   909 00004DBB 0F840200            <1> 	je near .invertend
   910 00004DBF EBE2                <1> 	jmp .invertloop
   911                              <1> 	
   912                              <1> .invertend:
   913 00004DC1 B21C                <1> 	mov dl, 28
   914 00004DC3 C3                  <1> 	ret
   915                              <1> 	
   916                              <1> .drawwindow:
   917 00004DC4 BA1309              <1> 	mov dx, 9 * 256 + 19			; First, draw white background box
   918 00004DC7 8A1EA9DE            <1> 	mov bl, [57001]
   919 00004DCB BE2A00              <1> 	mov si, 42
   920 00004DCE BF0F00              <1> 	mov di, 15
   921 00004DD1 E89DCB              <1> 	call os_draw_block
   922                              <1> 
   923                              <1> .drawcontents:
   924 00004DD4 60                  <1> 	pusha
   925 00004DD5 8A1EA9DE            <1> 	mov bl, [57001]
   926 00004DD9 BA140A              <1> 	mov dx, 10 * 256 + 20
   927 00004DDC E848CB              <1> 	call os_move_cursor
   928                              <1> 
   929 00004DDF BE[FC4E]            <1> 	mov si, .dialogmsg1
   930 00004DE2 E8FBCA              <1> 	call os_format_string
   931 00004DE5 BECCDE              <1> 	mov si, 57036
   932 00004DE8 E8F5CA              <1> 	call os_format_string
   933 00004DEB BE[064F]            <1> 	mov si, .dialogmsg2
   934 00004DEE E8EFCA              <1> 	call os_format_string
   935                              <1> 
   936 00004DF1 BA140B              <1> 	mov dx, 11 * 256 + 20
   937 00004DF4 E830CB              <1> 	call os_move_cursor
   938 00004DF7 BE[9950]            <1> 	mov si, .logo0
   939 00004DFA E8E3CA              <1> 	call os_format_string
   940                              <1> 
   941 00004DFD BA140C              <1> 	mov dx, 12 * 256 + 20
   942 00004E00 E824CB              <1> 	call os_move_cursor
   943 00004E03 BE[C250]            <1> 	mov si, .logo1
   944 00004E06 E8D7CA              <1> 	call os_format_string
   945                              <1> 
   946 00004E09 BA140D              <1> 	mov dx, 13 * 256 + 20
   947 00004E0C E818CB              <1> 	call os_move_cursor
   948 00004E0F BE[EB50]            <1> 	mov si, .logo2
   949 00004E12 E8CBCA              <1> 	call os_format_string
   950                              <1> 
   951 00004E15 BA140E              <1> 	mov dx, 14 * 256 + 20
   952 00004E18 E80CCB              <1> 	call os_move_cursor
   953 00004E1B BE[1451]            <1> 	mov si, .logo3
   954 00004E1E E8BFCA              <1> 	call os_format_string
   955 00004E21 61                  <1> 	popa
   956 00004E22 C3                  <1> 	ret
   957                              <1> 
   958                              <1> .drawbackground:
   959 00004E23 E8EBCA              <1> 	call os_clear_screen
   960 00004E26 BA0000              <1> 	mov dx, 0
   961 00004E29 E8FBCA              <1> 	call os_move_cursor
   962                              <1> 	
   963 00004E2C B82009              <1> 	mov ax, 0920h
   964 00004E2F BB7000              <1> 	mov bx, 112			; Black on gray
   965 00004E32 B95000              <1> 	mov cx, 80
   966 00004E35 CD10                <1> 	int 10h
   967                              <1> 	
   968 00004E37 BA0001              <1> 	mov dx, 1 * 256
   969 00004E3A E8EACA              <1> 	call os_move_cursor
   970                              <1> 	
   971 00004E3D 8A1EA8DE            <1> 	mov bl, [57000]		; Color from RAM
   972 00004E41 80E3F0              <1> 	and bl, 11110000b
   973 00004E44 B93007              <1> 	mov cx, 1840
   974 00004E47 B0B1                <1> 	mov al, 177
   975 00004E49 CD10                <1> 	int 10h
   976                              <1> 	
   977 00004E4B BA0018              <1> 	mov dx, 24 * 256
   978 00004E4E E8D6CA              <1> 	call os_move_cursor
   979 00004E51 B370                <1> 	mov bl, 112			; Black on gray
   980 00004E53 B95000              <1> 	mov cx, 80
   981 00004E56 B020                <1> 	mov al, 32
   982 00004E58 CD10                <1> 	int 10h
   983 00004E5A C3                  <1> 	ret
   984                              <1> 	
   985                              <1> .reset:
   986 00004E5B EA0000FFFF          <1> 	jmp 0FFFFh:0
   987                              <1> 
   988                              <1> .shutdown:
   989 00004E60 E8AECA              <1> 	call os_clear_screen
   990 00004E63 E8F6CA              <1> 	call os_show_cursor
   991                              <1> 
   992 00004E66 BE[CB4F]            <1> 	mov si, .apmmsg
   993 00004E69 E84ACA              <1> 	call os_print_string
   994                              <1> 	
   995 00004E6C BE[F04F]            <1> 	mov si, .dbgmsg1
   996 00004E6F E844CA              <1> 	call os_print_string
   997                              <1> 	
   998 00004E72 B80053              <1> 	mov ax, 5300h
   999 00004E75 31DB                <1> 	xor bx, bx
  1000 00004E77 CD15                <1> 	int 15h				; check if APM is present
  1001 00004E79 724F                <1> 	jc .APM_missing
  1002                              <1> 
  1003 00004E7B BE[0250]            <1> 	mov si, .dbgmsg2
  1004 00004E7E E835CA              <1> 	call os_print_string
  1005                              <1> 
  1006 00004E81 B80453              <1> 	mov ax, 5304h
  1007 00004E84 31DB                <1> 	xor bx, bx
  1008 00004E86 CD15                <1> 	int 15h				; disconnect any previous APM interface	
  1009                              <1> 	
  1010 00004E88 BE[3050]            <1> 	mov si, .dbgmsg2_1
  1011 00004E8B E828CA              <1> 	call os_print_string
  1012                              <1> 	
  1013 00004E8E B80E53              <1> 	mov ax, 530Eh		; Set APM to version 1.2
  1014 00004E91 31DB                <1> 	xor bx, bx
  1015 00004E93 B90201              <1> 	mov cx, 0102h
  1016 00004E96 CD15                <1> 	int 15h
  1017                              <1> 
  1018 00004E98 BE[5050]            <1> 	mov si, .dbgmsg3
  1019 00004E9B E818CA              <1> 	call os_print_string
  1020                              <1> 
  1021 00004E9E B80153              <1> 	mov ax, 5301h
  1022 00004EA1 31DB                <1> 	xor bx, bx
  1023 00004EA3 31C9                <1> 	xor cx, cx
  1024 00004EA5 CD15                <1> 	int 15h				; open an interface with APM
  1025 00004EA7 7231                <1> 	jc .APM_interface
  1026                              <1> 
  1027 00004EA9 BE[6750]            <1> 	mov si, .dbgmsg4
  1028 00004EAC E807CA              <1> 	call os_print_string
  1029                              <1> 
  1030 00004EAF B80753              <1> 	mov ax, 5307h
  1031 00004EB2 BB0100              <1> 	mov bx, 1
  1032 00004EB5 B90300              <1> 	mov cx, 3
  1033 00004EB8 CD15                <1> 	int 15h				; do a power off
  1034                              <1> 	
  1035                              <1> .APM_error:
  1036 00004EBA B8[084F]            <1> 	mov ax, .errormsg1
  1037 00004EBD BB[6C4F]            <1> 	mov bx, .errormsg4
  1038 00004EC0 B9[934F]            <1> 	mov cx, .errormsg45
  1039 00004EC3 31D2                <1> 	xor dx, dx
  1040 00004EC5 E846D2              <1> 	call os_dialog_box
  1041                              <1> 	
  1042 00004EC8 EB91                <1> 	jmp .reset
  1043                              <1> 	
  1044                              <1> .APM_missing:
  1045 00004ECA B8[2A4F]            <1> 	mov ax, .errormsg2
  1046 00004ECD BB[6C4F]            <1> 	mov bx, .errormsg4
  1047 00004ED0 B9[934F]            <1> 	mov cx, .errormsg45
  1048 00004ED3 31D2                <1> 	xor dx, dx
  1049 00004ED5 E836D2              <1> 	call os_dialog_box
  1050                              <1> 	
  1051 00004ED8 EB81                <1> 	jmp .reset
  1052                              <1> 	
  1053                              <1> .APM_interface:
  1054 00004EDA B8[4E4F]            <1> 	mov ax, .errormsg3
  1055 00004EDD BB[6C4F]            <1> 	mov bx, .errormsg4
  1056 00004EE0 B9[934F]            <1> 	mov cx, .errormsg45
  1057 00004EE3 31D2                <1> 	xor dx, dx
  1058 00004EE5 E826D2              <1> 	call os_dialog_box
  1059                              <1> 	
  1060 00004EE8 E970FF              <1> 	jmp .reset
  1061                              <1> 	
  1062                              <1> .APM_pwrmgmt:
  1063 00004EEB B8[AA4F]            <1> 	mov ax, .errormsg5
  1064 00004EEE BB[6C4F]            <1> 	mov bx, .errormsg4
  1065 00004EF1 B9[934F]            <1> 	mov cx, .errormsg45
  1066 00004EF4 31D2                <1> 	xor dx, dx
  1067 00004EF6 E815D2              <1> 	call os_dialog_box
  1068                              <1> 	
  1069 00004EF9 E95FFF              <1> 	jmp .reset
  1070                              <1> 
  1071                              <1> 	
  1072 00004EFC 476F6F646279652C20- <1> 	.dialogmsg1	db 'Goodbye, ', 0
  1072 00004F05 00                  <1>
  1073 00004F06 2E00                <1> 	.dialogmsg2	db '.', 0
  1074 00004F08 4572726F7220736875- <1> 	.errormsg1	db 'Error shutting down the computer.', 0
  1074 00004F11 7474696E6720646F77- <1>
  1074 00004F1A 6E2074686520636F6D- <1>
  1074 00004F23 70757465722E00      <1>
  1075 00004F2A 5468697320636F6D70- <1> 	.errormsg2	db 'This computer does not support APM.', 0
  1075 00004F33 7574657220646F6573- <1>
  1075 00004F3C 206E6F742073757070- <1>
  1075 00004F45 6F72742041504D2E00  <1>
  1076 00004F4E 4572726F7220636F6D- <1> 	.errormsg3	db 'Error communicating with APM.', 0
  1076 00004F57 6D756E69636174696E- <1>
  1076 00004F60 672077697468204150- <1>
  1076 00004F69 4D2E00              <1>
  1077 00004F6C 506C65617365207475- <1> 	.errormsg4	db 'Please turn off the computer manually,', 0
  1077 00004F75 726E206F6666207468- <1>
  1077 00004F7E 6520636F6D70757465- <1>
  1077 00004F87 72206D616E75616C6C- <1>
  1077 00004F90 792C00              <1>
  1078 00004F93 6F7220707265737320- <1> 	.errormsg45	db 'or press OK to reboot.', 0
  1078 00004F9C 4F4B20746F20726562- <1>
  1078 00004FA5 6F6F742E00          <1>
  1079 00004FAA 4572726F7220656E61- <1> 	.errormsg5	db 'Error enabling power management.', 0
  1079 00004FB3 626C696E6720706F77- <1>
  1079 00004FBC 6572206D616E616765- <1>
  1079 00004FC5 6D656E742E00        <1>
  1080                              <1> 	
  1081 00004FCB 417474656D7074696E- <1> 	.apmmsg		db 'Attempting shutdown through APM...', 13, 10, 0
  1081 00004FD4 672073687574646F77- <1>
  1081 00004FDD 6E207468726F756768- <1>
  1081 00004FE6 2041504D2E2E2E0D0A- <1>
  1081 00004FEF 00                  <1>
  1082                              <1> 	
  1083                              <1> 	
  1084 00004FF0 436865636B696E6720- <1> 	.dbgmsg1	db 'Checking APM...', 13, 10, 0
  1084 00004FF9 41504D2E2E2E0D0A00  <1>
  1085 00005002 446973636F6E6E6563- <1> 	.dbgmsg2	db 'Disconnecting any previous APM interface...', 13, 10, 0
  1085 0000500B 74696E6720616E7920- <1>
  1085 00005014 70726576696F757320- <1>
  1085 0000501D 41504D20696E746572- <1>
  1085 00005026 666163652E2E2E0D0A- <1>
  1085 0000502F 00                  <1>
  1086 00005030 53657474696E672041- <1> 	.dbgmsg2_1	db 'Setting APM version to 1.2...', 13, 10, 0
  1086 00005039 504D2076657273696F- <1>
  1086 00005042 6E20746F20312E322E- <1>
  1086 0000504B 2E2E0D0A00          <1>
  1087 00005050 436F6E6E656374696E- <1> 	.dbgmsg3	db 'Connecting to APM...', 13, 10, 0
  1087 00005059 6720746F2041504D2E- <1>
  1087 00005062 2E2E0D0A00          <1>
  1088 00005067 456E61626C696E6720- <1> 	.dbgmsg4	db 'Enabling power management...', 13, 10, 0
  1088 00005070 706F776572206D616E- <1>
  1088 00005079 6167656D656E742E2E- <1>
  1088 00005082 2E0D0A00            <1>
  1089 00005086 5368757474696E6720- <1> 	.dbgmsg5	db 'Shutting down...', 13, 10, 0
  1089 0000508F 646F776E2E2E2E0D0A- <1>
  1089 00005098 00                  <1>
  1090                              <1> 	
  1091 00005099 DAC4C4B3C4C4BF2020- <1> 	.logo0		db 218, 196, 196, 179, 196, 196, 191, '  Shut down the computer         ', 0
  1091 000050A2 5368757420646F776E- <1>
  1091 000050AB 2074686520636F6D70- <1>
  1091 000050B4 757465722020202020- <1>
  1091 000050BD 2020202000          <1>
  1092 000050C2 B32020B32020B32020- <1> 	.logo1		db 179, 32, 32, 179, 32, 32, 179,     '  Soft reboot the computer       ', 0
  1092 000050CB 536F6674207265626F- <1>
  1092 000050D4 6F742074686520636F- <1>
  1092 000050DD 6D7075746572202020- <1>
  1092 000050E6 2020202000          <1>
  1093 000050EB B32020202020B32020- <1> 	.logo2		db 179, 32, 32, 32, 32, 32, 179,      '  Go back                        ', 0
  1093 000050F4 476F206261636B2020- <1>
  1093 000050FD 202020202020202020- <1>
  1093 00005106 202020202020202020- <1>
  1093 0000510F 2020202000          <1>
  1094 00005114 C0C4C4C4C4C4D900    <1> 	.logo3		db 192, 196, 196, 196, 196, 196, 217, 0
   827                                  
   828                                  ; ==================================================================
   829                                  ; END OF KERNEL
   830                                  ; ==================================================================
   831                                  
   832                                  os_kernel_end:
